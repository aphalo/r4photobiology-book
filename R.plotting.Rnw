<<echo=FALSE, eval=TRUE>>=
# clear everything from the R environment
# rm(list=ls())
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\chapter{Making publication quality plots with R}\label{chap:R:plotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<>>=
library(ggplot2)
library(scales)
library(ggtern)
library(ggmap)
library(rgdal)
library(Hmisc)
library(plyr)
library(grid)
library(photobiologygg)
@

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \code{Lattice} and \code{ggplot2}. There are packages that add extra functionality to these packages.

In the examples in this handbook we mainly use \code{ggplot}, \code{ggmap} and \code{ggtern}, together with our own \code{photobiologygg}. In this appendix we give a very brief introduction to the `grammar of graphics' and \code{ggplot2}.

\section{Bases of plotting with \code{ggplot2}}

The grammar of graphics is based on aesthetics (\code{aes}) as for example colour, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geom:

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line()
@

Aesthetics can be `assigned' to data variables, and to constants:

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.e.irrad, colour="red")) +
  geom_line()
@

Data can be the `result of a calculation':

<<>>=
ggplot(sun.spct * gg400.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line()
@

The aesthetics and data given as \code{ggplot}'s arguments become the defaults for the geoms, but geoms also take aesthetics and data as arguments, which then override the defaults:

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line(colour="red") +
  geom_line(data=sun.spct * gg400.spct, colour="blue")
@

Another way of plotting these data, is to first assemble a single data.frame or data.table with all the data. We will use the example data that is as \code{source.spct} objects. After the operations we need to use \code{e2q} to add the spectral photon irradiance values to plot.

<<>>=
unfiltered_sun.spct <- copy(sun.spct)
unfiltered_sun.spct[ , filter := "none"]
filtered_sun.spct <- sun.spct * gg400.spct
e2q(filtered_sun.spct, byref=TRUE)
filtered_sun.spct[ , filter := "GG400"]
data4plot.spct <- rbind(unfiltered_sun.spct, filtered_sun.spct)
data4plot.spct[ , filter := factor(filter)]
@

Now we can do the plot assigning \code{filter} to an aesthetic:

<<>>=
ggplot(data4plot.spct, aes(x=w.length, y=s.q.irrad, colour=filter)) +
  geom_line()
@

We can assign the same variable to more than one aesthetic:

<<>>=
ggplot(data4plot.spct, aes(x=w.length, y=s.q.irrad,
                   colour=filter, linetype=filter)) +
  geom_line()
@

We can change the labels for the different aesthetics, and give a title:

<<>>=
ggplot(data4plot.spct,
       aes(x=w.length, y=s.q.irrad * 1e6, colour=filter)) +
  geom_line() +
  labs(x="Wavelength (nm)",
       y="Spectral photon irradiance\n(umol m-2 s-1 nm-1)",
       colour="Filter:",
       title="Filtered and unfiltered solar spectrum")
@

We can assign a ggplot object to a variable:

<<>>=
myplot <- ggplot(data4plot.spct,
       aes(x=w.length, y=s.q.irrad * 1e6, colour=filter)) +
  geom_line() +
  labs(x="Wavelength (nm)",
       y="Spectral photon irradiance\n(umol m-2 s-1 nm-1)",
       colour="Filter:",
       title="Filtered and unfiltered solar spectrum")
@

And now we can add more elements to the plot stored in the variable:

<<>>=
myplot + theme_bw()
myplot + scale_y_log10()
@

\section{Adding fitted curves, including splines}

We will now show an example of use of \code{stat\_smooth} using the default spline smoothing.

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth()
@

By adjusting one of its parameters, \code{span}, we make the spline more ``flexible'':

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth(span=0.1)
@

Instead of using the default spline, we can use a linear model fit. In this example we use a polynomial of order 8, fitted by lm, as smoother:

<<>>=
ggplot(sun.spct, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth(method="lm", formula=y~poly(x,8))
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use these more advanced models.

\section{Adding statistical ``summaries''}

It is also possible to summarize data on-the-fly when plotting, but before showing this we will generate some normally distributed artificial data:

<<>>=
fake.data <- data.frame(
  y = c(rnorm(20, mean=2, sd=0.5), rnorm(20, mean=4, sd=0.7)),
  group = factor(c(rep("A", 20), rep("B", 20)))
  )
@

Now we use these data to plot means and confidence intervals by group:

<<>>=
fig2 <- ggplot(data=fake.data, aes(y=y, x=group)) + geom_point()
fig2
@

We have saved the base figure in \code{fig2}, so now we can play with different summaries. We first add just the mean. In this case we need to add as argument to \code{stat\_summary} the geom to use, as the default one expects data for plotting error bars, in later examples, this is not needed.

<<>>=
fig2 + stat_summary(fun.y = "mean", geom="point",
                    colour="red", shape="-", size=20)
@

<<>>=
fig2 + stat_summary(fun.y = "median", geom="point",
                    colour="red", shape="-", size=20)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot",
                    colour="red", size=1, alpha=0.7)
@

We can instead add the means and $p = 0.90$ confidence intervals, by supplying a value to parameter \code{conf.int}:

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot", conf.int=0.90,
                    colour="red", size=1, alpha=0.7)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal",
                    colour="red", size=1, alpha=0.7)
@

In this case the multiplier \code{mult} is by default is calculated from the $t$ distribution according to degrees of freedom, but if we force the multiplier to 1, then we get error bars corresponding to $\pm$s.e. (standard errors).

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal", mult=1,
                    colour="red", size=1, alpha=0.7)
@

Finally we can plot error bars showing $\pm$s.d. (standard deviation). The default value for \code{mult} is 2, giving error bars $\pm 2$ s.d., we use 1 as multiplier instead.

<<>>=
fig2 + stat_summary(fun.data = "mean_sdl",
                    colour="red", size=1, alpha=0.7)
@

We do not show it here, but instead of using these functions (from package \codet{Hmisc}) it is possible to define one's own functions.

Finally we plot the means in a bar plot, with the observations superimposed and $p = 0.95$ C.I. (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets they can be assigned to factors in the data set.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  stat_summary(fun.y = "mean", geom = "bar",
               fill="yellow", colour="black") +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "errorbar",
               width=0.1, size=1, colour="red") +
  geom_point(size=3, alpha=0.3)
@

\section{Plotting functions}

We can also directly plot functions, without need to generate data beforehand:

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
@

We can even pass additional arguments to a function:

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

Of course, user-defined functions (not shown), and anonymous functions can also be used:

<<>>=
ggplot(data.frame(x=0:1), aes(x=x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

Here is another example of a predefined function, but in this case the default scale is not the best:

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin)
@

In this case we need to change the x-axis scale to better suit the sin function and the use of radians as angular units:

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)")
@

\section{Plotting text}

One can use \code{geom\_text} to add text labels to observations. The aesthetic \code{label} gives text and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{colour} aesthetic can be also used for text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of zero for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the labe left or down, and positive values right or up. A value of 1 or -1 sets the text so that its edge is at the supplied coordinate. Values outside the range $-1\ldots 1$ sift the text even further away.

<<>>=
my.data <- data.frame(x=1:10, y=rep(2, 10), label=paste(letters[1:10], " "))
ggplot(my.data, aes(x,y,label=label)) + geom_text(angle=45, hjust=1) + geom_point()
@

In this example we use \code{paste} (which uses recycling here) to add a space at the end of each label. Justification values outside the range $-1\ldots 1$ are allowed, but are relative to the with of the label. As the default font used in this case has variable with characters, the justification would be inconsistent (e.g. try the code above but using \code{hjust} set to 3 instead of to 1 without pasting a space character to the labels.)

\section{Scales}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted object, such as \code{colour}, \code{size}, posititon (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a posiiton in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the x-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also assign the \code{colour} aesthtic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different one, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Be aware that for example for colour, and `numbers' there are both discrete and continuous scales available.

Advanced scale manipulation requires the package \code{scales} to be loaded. Some simple examples follow.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

<<>>=
fake2.data <- data.frame(
  y = c(rnorm(20, mean=20, sd=5), rnorm(20, mean=40, sd=10)),
  group = factor(c(rep("A", 20), rep("B", 20))),
  z = rnorm(40, mean=12, sd=6)
  )
@

<<>>=
fig2 <-
  ggplot(data=fake2.data,
         aes(y=y, x=group, shape=group, colour=group, size=z)) +
  geom_point(alpha=0.3) + ylim(0, NA)
fig2
@

<<>>=
fig2 +
  scale_y_log10(breaks=c(10,20,30,40,50,60)) +
       stat_summary(fun.data = "mean_cl_normal",
                    colour="black", size=1, alpha=1)
@

\section{Adding annotations}

Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the ggplot.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)") +
  annotate(geom="text",
           label=c("+", "-"),
           x=c(0.5, 1.5) * pi, y=c(0.5, -0.5),
           size=20) +
  annotate(geom="point",
           colour="red",
           shape=21,
           fill="white",
           x=c(0, 1, 2) * pi, y=0,
           size=6)
@

\section{Circular plots}

A funny example stolen from the ggplot2 website at \url{http://docs.ggplot2.org/current/coord_polar.html}.

<<>>=
# Hadley's favourite pie chart
df <- data.frame(
  variable = c("resembles", "does not resemble"),
  value = c(80, 20)
)
ggplot(df, aes(x = "", y = value, fill = variable)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_manual(values = c("red", "yellow")) +
  coord_polar("y", start = pi / 3) +
  labs(title = "Pac man")
@

Something just a bit more useful, also stolen from the same page:

<<>>=
# A pie chart = stacked bar chart + polar coordinates
pie <- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
 geom_bar(width = 1)
pie + coord_polar(theta = "y")
@

\section{Pie charts vs.\ bar plots example}

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}). %The original figure was created with the following code (not run):

<<eval=FALSE, echo=FALSE>>=
a <- matrix(c(17, 18, 20, 22, 23,
                20, 20, 19, 21, 20,
                23, 22, 20, 18, 17), nrow=3, byrow=T)
  titles <- c("A", "B", "C")
  cols <- c("red", "blue", "green", "yellow", "black")

  postscript("piecharts.eps", paper="special", width=8, height=6)

  defaultmar <- par()$mar
  layout(matrix(c(1,3,5,
                  2,4,6), nrow=2, byrow=T), height=c(1,1))
  par(cex=1)
  par(font=1)
  par(las=1)
  par(font.axis=1)
  par(mgp=c(1,1,0))

  for (i in 1:nrow(a)) {
    par(mar=c(0,0,2,0))
    pie(a[i,], init=90, clockwise=T, col=cols, radius=0.8)
    title(main=titles[i], line=0)
    par(mar=defaultmar+c(-2,-1.5,-4,-0.5))
    par(mgp=c(0,0.5,0))
    barplot(a[i,], horiz=F, xlim=c(0,10), ylim=c(0,25), col=cols, border=0,
            names.arg=1:5, space=0.8, axes=F)
    par(mgp=c(0,1,0))

    abline(h=5*1:5, col="white")
    axis(2)
  }

  dev.off()
@

Here is my \code{ggplot2} version of the same figure, using much simpler code and obtaining almost the same result.

<<>>=
example.data <-
  data.frame(values = c(17, 18, 20, 22, 23,
                        20, 20, 19, 21, 20,
                        23, 22, 20, 18, 17),
             examples= rep(c("A", "B", "C"), c(5,5,5)),
             cols = rep(c("red", "blue", "green", "yellow", "black"), 3)
  )

ggplot(example.data, aes(x=cols, y=values, fill=cols)) +
  geom_bar(width = 1, stat="identity") +
  facet_grid(.~examples) +
  scale_fill_identity()
ggplot(example.data, aes(x=factor(1), y=values, fill=cols)) +
  geom_bar(width = 1, stat="identity") +
  facet_grid(.~examples) +
  scale_fill_identity() +
  coord_polar(theta="y")
@

\section{A classical example about regression}

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}. The original code (not run):

<<eval=FALSE>>=
 svg("anscombe.svg", width=10.5, height=7)
 par(las=1)

 ##-- some "magic" to do the 4 regressions in a loop:
 ff <- y ~ x
 for(i in 1:4) {
   ff[2:3] <- lapply(paste(c("y","x"), i, sep=""), as.name)
   ## or   ff2 <- as.name(paste("y", i, sep=""))
   ##      ff3 <- as.name(paste("x", i, sep=""))
   assign(paste("lm.",i,sep=""), lmi <- lm(ff, data= anscombe))
 }

 ## Now, do what you should have done in the first place: PLOTS
 op <- par(mfrow=c(2,2), mar=1.5+c(4,3.5,0,1), oma=c(0,0,0,0),
           lab=c(6,6,7), cex.lab=1.5, cex.axis=1.3, mgp=c(3,1,0))
 for(i in 1:4) {
   ff[2:3] <- lapply(paste(c("y","x"), i, sep=""), as.name)
   plot(ff, data =anscombe, col="red", pch=21, bg = "orange", cex = 2.5,
        xlim=c(3,19), ylim=c(3,13),
        xlab=eval(substitute(expression(x[i]), list(i=i))),
        ylab=eval(substitute(expression(y[i]), list(i=i))))
   abline(get(paste("lm.",i,sep="")), col="blue")
 }

 dev.off()
@

My version using \code{ggplot2}:

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- data.frame(x = my.mat[ , 1], y = my.mat[ , 2], case=factor(rep(1:4, rep(11,4))))
# we draw the figure
ggplot(my.anscombe, aes(x,y)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2)
@

It is not much more difficult to make it look simlar to the original

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm", se=FALSE) +
  facet_wrap(~case, ncol=2) +
  theme_bw()
@

Although I think that the confidence bands make the point of the example much clearer

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2) +
  theme_bw()
@

This classical example form Anscombe \cite{xxx} demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

\section{Ternary plots}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

Being an extension to \code{ggplot2} the main difference is that a ternary plot can be created using \code{coord\_tern} and that the three aesthetics \code{x, y, z} are required. By default the values of the variables mapped to these aesthetics are re-expressed as percentages or fractions. We present here only a few examples, and we encourage the readers to check the package's web site at \url{http://www.ggtern.com}.

For the first example we first generate some random data values from the uniform distribution:

<<>>=
# create some artificial data
my.trn1.data <- data.frame(x=runif(50), y=runif(50), z=runif(50))
@

A ternary plot is just a plot with a different system of coordinates, and can be obtained using \code{coord\_tern}:

<<>>=
fig.trn <- ggplot(my.trn1.data, aes(x,y,z)) +
  coord_tern(L="x",T="y",R="z")
@

One can achieve a similar result by using \code{ggtern} instead of \code{ggplot}:

<<eval=FALSE>>=
fig.trn <- ggtern(my.trn1.data, aes(x,y,z))
@

As with any other plot based on \code{ggplot2} one builds the plot by adding `layers'. Themes are also supported.
<<>>=
fig.trn +
  geom_point()
fig.trn +
  geom_point() +
  theme_bw()
@

It is possible to also draw confidence regions:

<<>>=
fig.trn +
  geom_point() +
  geom_confidence()
@

Or density estimates. In this last version of the plot I adjust a few other aesthetics and refine the appearance of the plot:

<<>>=
fig.trn +
  stat_density2d(fullrange=T,n=200,
                       geom="polygon", fill="grey10",
                       aes(alpha =..level..)) +
  geom_point(shape=21, fill="orange", size=4) +
  labs(x="x (%)", y="y (%)", z="z (%)", alpha="Density") +
  theme_rgbw()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

As a final example we reproduce an elaborate ternary plot from \url{http://www.ggtern.com/2014/01/15/usda-textural-soil-classification/}, the website of the package.

<<>>=
# Load the Data. (Available in ggtern 1.0.3.0 next version)
data(USDA)

# Put tile labels at the midpoint of each tile.
USDA.LAB = ddply(USDA, 'Label', function(df) {
    apply(df[, 1:3], 2, mean)
})

# Tweak
USDA.LAB$Angle = 0
USDA.LAB$Angle[which(USDA.LAB$Label == 'Loamy Sand')] = -35
@

<<>>=
# Construct the plot.
ggplot(data = USDA, aes(y=Clay, x=Sand, z=Silt,
                        color = Label,
                        fill = Label)) +
  coord_tern(L="x",T="y",R="z") +
  geom_polygon(alpha = 0.75, size = 0.5, color = 'black') +
  geom_text(data = USDA.LAB,
            aes(label = Label, angle = Angle),
            color = 'black',
            size = 3.5) +
  theme_rgbw() +
  theme_showsecondary() +
  theme_showarrows() +
  custom_percent("Percent") +
  theme(legend.justification = c(0, 1),
        legend.position      = c(0, 1),
        axis.tern.padding    = unit(0.15, 'npc')) +
  labs(title = 'USDA Textural Classification Chart',
       fill  = 'Textural Class',
       color = 'Textural Class')
@

\section{Plotting data onto maps}

Another extension to package \code{ggplot2} is package \code{ggmap}. Package \code{ggmap} makes it possible to plot data using normal \code{ggplot2} syntax on top of a map. Maps can be easily retrieved from the internet through different services. Some of these services require the user to register and obtain a key for access. As Google Maps do not require such a key for normal resolution maps, we use this service in the examples.

The first step is to fetch the desired map. One can fetch the maps base on any valid Google Maps search term, or by giving the coordinates at the center of the map. Although \code{zoom} defaults to "auto", frequently the best result is obtained by providing this argument. Valid values for \code{zoom} are integers in the range 1 to 20.


\begin{framed}

We will fetch maps from Google Maps. We have disabled the messages, to avoid repeated messages about Google's terms of use.

\begin{description}
\item[Google Maps API Terms of Service:] \url{http://developers.google.com/maps/terms}
\item[Information from URL:] \url{http://maps.googleapis.com/maps/api/geocode/json?address=Europe&sensor=false}
\item[Map from URL:] \url{http://maps.googleapis.com/maps/api/staticmap?center=Europe&zoom=3&size=%20640x640&scale=%202&maptype=terrain&sensor=false}
\end{description}

\end{framed}

We start by fetching and plotting a map of Europe of type  \code{satellite}. We use the default extent \code{panel}, and also the extent \code{device} and \code{normal}. The \code{normal} plot includes axes showing the coordinates, while \code{device} does not show them, while \code{panel} shows axes but the map fits tightly into the drawing area:

<<plot-maps-1, echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_very_narrow)
@

<<plot-maps-2, message=FALSE, cache=TRUE>>=
Europe1 <- get_map("Europe", zoom=3, maptype="satellite")
ggmap(Europe1)

ggmap(Europe1, extent = "device")

ggmap(Europe1, extent = "normal")

@

To demostrate the option to fetch a map in black and white instead of the default colour version, we use a map of Europe of type \code{terrain}.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<plot-maps-3, message=FALSE, cache=TRUE>>=
Europe2 <- get_map("Europe", zoom=3,
                  maptype="terrain")
ggmap(Europe2)

Europe3 <- get_map("Europe", zoom=3,
                  maptype="terrain",
                  color="bw")
ggmap(Europe3)
@

To demonstrate the difference between type \code{roadmap} and the default type \code{terrain}, we use the map of Finland. Note that we search for ``Oulu'' instead of ``Finland'' as Google Maps takes the position of the label ``Finland'' as the center of the map, and clips the northern part. By means of \code{zoom} we override the default automatic zooming onto the city of Oulu.


<<plot-maps-4, message=FALSE, cache=TRUE>>=
Finland1 <- get_map("Oulu", zoom=5, maptype="terrain")
ggmap(Finland1)

Finland2 <- get_map("Oulu", zoom=5, maptype="roadmap")
ggmap(Finland2)
@

We can even search for a street address, and in this case with high zoom value, we can see the building where one of us works:

<<plot-maps-5, message=FALSE, cache=TRUE>>=
BIO3 <- get_map("Viikinkaari 1, 00790 Helsinki",
                zoom=18,
                maptype="satellite")
ggmap(BIO3)
@

We will now show a simple example of plotting data on a map, first by expliciply giving the coordinates, and in the second example we show how to fetch from Google Maps coordinate values that can be then plotted. We use function \code{geocode}. In one example we use \code{geom\_point} and \code{geom\_text}, while in the second example we use \code{annotate}, but either approach could have been used for both plots:

<<plot-maps-6, message=FALSE, cache=TRUE>>=
viikki <- get_map("Viikki",
                  zoom=15,
                  maptype="satellite")

our_location <- data.frame(lat=c(60.225, 60.227),
                           lon=c(25.017, 25.018),
                           label=c("BIO3", "field"))
ggmap(viikki, extent = "normal") +
  geom_point(data=our_location, aes(y=lat, x=lon),
             size=4, colour="yellow") +
  geom_text(data=our_location, aes(y=lat, x=lon, label=label),
            hjust=-0.3, colour="yellow")

our_geocode <- geocode("Viikinkaari 1, 00790 Helsinki")
ggmap(viikki, extent = "normal") +
  annotate(geom="point",
           y=our_geocode[ 1, "lat"], x=our_geocode[ 1, "lon"],
           size=4, colour="yellow") +
  annotate(geom="text",
           y=our_geocode[ 1, "lat"], x=our_geocode[ 1, "lon"],
           label="BIO3", hjust=-0.3, colour="yellow")
@

Using \code{get\_map} from package \code{ggmap} for drawing a world map is not possible at the time of writting. In addition a worked out example of how to plot shape files, and how to dowload them from a repository is suitable as our final example. We also show how to change the map projection. The example is adapted from a blog post at \url{http://rpsychologist.com/working-with-shapefiles-projections-and-world-maps-in-ggplot}.

We start by downloading the map data archive files from \url{http://www.naturalearthdata.com} which is available in different layers. We only use three of the available layers: `physical' which describes the coastlines and a grid and bounding box, and `cultural' which gives country borders. We save them in a folder with name `maps', which is expected to already exist. After downloading each file, we unzip it.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<plot-maps-7, cache=TRUE>>=
oldwd <- setwd("./maps")

url_path <-
#  "http://www.naturalearthdata.com/download/110m/"
  "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/"

download.file(paste(url_path,
                    "physical/ne_110m_land.zip",
                    sep=""), "ne_110m_land.zip")
unzip("ne_110m_land.zip")

download.file(paste(url_path,
                    "cultural/ne_110m_admin_0_countries.zip",
                    sep=""), "ne_110m_admin_0_countries.zip")
unzip("ne_110m_admin_0_countries.zip")

download.file(paste(url_path,
                    "physical/ne_110m_graticules_all.zip",
                    sep=""), "ne_110m_graticules_all.zip")
unzip("ne_110m_graticules_all.zip")

setwd(oldwd)
@

We list the layers that we have downloaded.

<<>>=
ogrListLayers(dsn="./maps")
@

Next we read the layer for the coastline, and use \code{fortify} to convert it into a data frame. We also create a second version of the data using the Robinson projection.

<<>>=
wmap <- readOGR(dsn="./maps", layer="ne_110m_land")
wmap.data <- fortify(wmap)
wmap_robin <- spTransform(wmap, CRS("+proj=robin"))
wmap_robin.data <- fortify(wmap_robin)
@

We do the same for country borders,

<<>>=
countries <- readOGR("./maps", layer="ne_110m_admin_0_countries")
countries.data <- fortify(countries)
countries_robin <- spTransform(countries, CRS("+init=ESRI:54030"))
countries_robin.data <- fortify(countries_robin)
@

and for the graticule at $15^\circ$ intervals, and the bounding box.

<<>>=
grat <- readOGR("./maps", layer="ne_110m_graticules_15")
grat.data <- fortify(grat)
grat_robin <- spTransform(grat, CRS("+proj=robin"))
grat_robin.data <- fortify(grat_robin)

bbox <- readOGR("./maps", layer="ne_110m_wgs84_bounding_box")
bbox.data <- fortify(bbox)
bbox_robin <- spTransform(bbox, CRS("+proj=robin"))
bbox_robin.data <- fortify(bbox_robin)
@

Now we plot the world map of the coastlines, on a longitude and latitude scale, as a \code{ggplot} using \code{geom\_polygon}.

<<>>=
ggplot(wmap.data, aes(long,lat, group=group)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  coord_equal()
@

There is one noticeable problem in the map shown above: the Caspian sea is missing. We need to use aesthetic \code{fill} and a manual scale to correct this.

<<>>=
ggplot(wmap.data, aes(long,lat, group=group, fill=hole)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  scale_fill_manual(values=c("#262626", "#e6e8ed"),
                    guide="none") +
  coord_equal()
@


<<echo=FALSE, eval=FALSE>>=
# does not work as expected
ggplot(wmap.data, aes(long,lat, group=group)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  scale_fill_manual(values=c("#262626", "#e6e8ed"),
                    guide="none") +
  coord_map()
@

When plotting a map using a projection, many default elements of the \code{ggplot} theme need to be removed, as the data is no longer in units of degrees of latitude and longitude and axes and their labels are no longer meaningful.

<<>>=
theme_map_opts <-
  list(theme(panel.grid.minor = element_blank(),
             panel.grid.major = element_blank(),
             panel.background = element_blank(),
             plot.background = element_rect(fill="#e6e8ed"),
             panel.border = element_blank(),
             axis.line = element_blank(),
             axis.text.x = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks = element_blank(),
             axis.title.x = element_blank(),
             axis.title.y = element_blank()))
@

Finally we plot all the layers using the Robinson projection. This is still a \code{ggplot} and consequently one can plot data on top of the map, being aware of the transfromation of the scale needed to make the data location match locations in a map using a certain projection.

<<>>=
ggplot(bbox_robin.data, aes(long,lat, group=group)) +
  geom_polygon(fill="white") +
  geom_polygon(data=countries_robin.data,
               aes(long,lat, group=group,
                   fill=hole)) +
  geom_path(data=countries_robin.data,
            aes(long,lat, group=group, fill=hole),
            color="white",
            size=0.3) +
  geom_path(data=grat_robin.data,
            aes(long, lat, group=group, fill=NULL),
            linetype="dashed",
            color="grey50") +
  labs(title="World map (Robinson)") +
  coord_equal() +
  theme_map_opts +
  scale_fill_manual(values=c("black", "white"),
                    guide="none")
@

\section{Inset plots using same data}

Example from \url{http://stackoverflow.com/questions/20708012/embedding-a-subplot-in-ggplot-ggsubplot}, authored by Baptiste Auguié \url{http://baptiste.github.io/}.

<<cache=TRUE>>=
d = data.frame(x = sort(rlnorm(300)),
               y = sort(rlnorm(300)),
               grp = 1)

main <- ggplot(d, aes(x, y)) +
  geom_point() + theme_bw()

sub <- main +
  geom_rect(data=d[1,],
            xmin=0, ymin=0, xmax=5, ymax=5,
            fill="grey50", alpha=0.3)
sub$layers <- rev(sub$layers) # draw rect below

main +
  annotation_custom(ggplotGrob(sub),
                    xmin=2.5, xmax=5,
                    ymin=0, ymax=2.5) +
  scale_x_continuous(limits=c(0, 5)) +
  scale_y_continuous(limits=c(0, 4))
@

\section{Adding elements using \code{grid}}

\code{ggplot2} creates the plots using package \code{grid}, consequently it is possible to manipulate \code{ggplot} objects using \code{grid} functions. Here we present a very simple example. For more information on using \code{grid} together with \code{ggplot2} please see \cite{Murriel2009}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

<<>>=
print(qplot(1,1), vp=viewport(height=0.8))
grid.text(0.5, unit(1,"npc") - unit(1,"line"),
          label="I'm (slightly) out of here!")
@

\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
pdf(file="fig1.pdf", width=8, height=6)
print(fig1)
dev.off()
@

Encapsulated Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file="fig1.eps", width=8, height=6)
print(fig1)
dev.off()
@

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file="fig1.tiff", width=1000, height=800)
print(fig1)
dev.off()
@


