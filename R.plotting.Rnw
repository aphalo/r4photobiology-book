<<echo=FALSE, eval=TRUE>>=
# clear everything from the R environment
# rm(list=ls())
@

\chapter{Making publication quality plots with R}\label{chap:R:plotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<>>=
library(ggplot2)
library(ggtern)
library(ggmap)
library(photobiologygg)
@

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \code{Lattice} and \code{ggplot2}. There are packages that add extra functionality to these packages.

In the examples in this handbook we mainly use \code{ggplot}, \code{ggmap} and \code{ggtern}, together with our own \code{photobiologygg}. In this appendix we give a very brief introduction to the `grammar of graphics' and \code{ggplot2}.

\section{Bases of plotting with \code{ggplot2}}

The grammar of graphics is based on aesthetics (\code{aes}) as for example colour, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geom:

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line()
@

Aesthetics can be `assigned' to data variables, and to constants:

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad, colour="red")) +
  geom_line()
@

Data can be the `result of a calculation':

<<>>=
ggplot(sun.dt * gg400.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line()
@

The aesthetics and data given as \code{ggplot}'s arguments become the defaults for the geoms, but geoms also take aesthetics and data as arguments, which then override the defaults:

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line(colour="red") +
  geom_line(data=sun.dt * gg400.dt, colour="blue")
@

Another way of plotting these data, is to first assemble a single data.frame or data.table with all the data. We will use the example data that is as data.tables:

<<>>=
unfiltered_sun.dt <- copy(sun.dt)
unfiltered_sun.dt[ , filter := "none"]
filtered_sun.dt <- sun.dt * gg400.dt
filtered_sun.dt[ , filter := "GG400"]
data4plot.dt <- rbind(unfiltered_sun.dt, filtered_sun.dt)
data4plot.dt[ , filter := factor(filter)]
@

Now we can do the plot assigning \code{filter} to an aesthetic:

<<>>=
ggplot(data4plot.dt, aes(x=w.length, y=s.q.irrad, colour=filter)) +
  geom_line()
@

We can assign the same variable to more than one aesthetic:

<<>>=
ggplot(data4plot.dt, aes(x=w.length, y=s.q.irrad,
                   colour=filter, linetype=filter)) +
  geom_line()
@

We can change the labels for the different aesthetics, and give a title:

<<>>=
ggplot(data4plot.dt,
       aes(x=w.length, y=s.q.irrad * 1e6, colour=filter)) +
  geom_line() +
  labs(x="Wavelength (nm)",
       y="Spectral photon irradiance\n(umol m-2 s-1 nm-1)",
       colour="Filter:",
       title="Filtered and unfiltered solar spectrum")
@

We can assign a ggplot object to a variable:

<<>>=
myplot <- ggplot(data4plot.dt,
       aes(x=w.length, y=s.q.irrad * 1e6, colour=filter)) +
  geom_line() +
  labs(x="Wavelength (nm)",
       y="Spectral photon irradiance\n(umol m-2 s-1 nm-1)",
       colour="Filter:",
       title="Filtered and unfiltered solar spectrum")
@

And now we can add more elements to the plot stored in the variable:

<<>>=
myplot + theme_bw()
myplot + scale_y_log10()
@

\section{Adding fitted curves, including splines}

We will now show an example of use of \code{stat\_smooth} using the default spline smoothing.

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth()
@

By adjusting one of its parameters, \code{span}, we make the spline more ``flexible'':

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth(span=0.1)
@

Instead of using the default spline, we can use a linear model fit. In this example we use a polynomial of order 8, fitted by lm, as smoother:

<<>>=
ggplot(sun.dt, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  stat_smooth(method="lm", formula=y~poly(x,8))
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use these more advanced models.

\section{Adding statistical ``summaries''}

It is also possible to summarize data on-the-fly when plotting, but before showing this we will generate some normally distributed artificial data:

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(fig.width=4, fig.height=4, out.width='.47\\textwidth')
@

<<>>=
fake.data <- data.frame(
  y = c(rnorm(20, mean=2, sd=0.5), rnorm(20, mean=4, sd=0.7)),
  group = factor(c(rep("A", 20), rep("B", 20)))
  )
@

Now we use these data to plot means and confidence intervals by group:

<<>>=
fig2 <- ggplot(data=fake.data, aes(y=y, x=group)) + geom_point()
fig2
@

We have saved the base figure in \code{fig2}, so now we can play with different summaries. We first add just the mean. In this case we need to add as argument to \code{stat\_summary} the geom to use, as the default one expects data for plotting error bars, in later examples, this is not needed.

<<>>=
fig2 + stat_summary(fun.y = "mean", geom="point",
                    colour="red", shape="-", size=20)
@

<<>>=
fig2 + stat_summary(fun.y = "median", geom="point",
                    colour="red", shape="-", size=20)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot",
                    colour="red", size=1, alpha=0.7)
@

We can instead add the means and $p = 0.90$ confidence intervals, by supplying a value to parameter \code{conf.int}:

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot", conf.int=0.90,
                    colour="red", size=1, alpha=0.7)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal",
                    colour="red", size=1, alpha=0.7)
@

In this case the multiplier \code{mult} is by default is calculated from the $t$ distribution according to degrees of freedom, but if we force the multiplier to 1, then we get error bars corresponding to $\pm$s.e. (standard errors).

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal", mult=1,
                    colour="red", size=1, alpha=0.7)
@

Finally we can plot error bars showing $\pm$s.d. (standard deviation). The default value for \code{mult} is 2, giving error bars $\pm 2$ s.d., we use 1 as multiplier instead.

<<>>=
fig2 + stat_summary(fun.data = "mean_sdl", mult=1,
                    colour="red", size=1, alpha=0.7)
@

We do not show it here, but instead of using these functions (from package \code{Hmisc}) it is possible to define one's one functions.

Finally we plot the means in a bar plot, with the observations superimposed and $p$ = 0.95 C.I. (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets they can be assigned to factors in the data set.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  stat_summary(fun.y = "mean", geom = "bar",
               fill="yellow", colour="black") +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "errorbar",
               width=0.1, size=1, colour="red") +
  geom_point(size=3, alpha=0.3)
@

\section{Plotting functions}

We can also directly plot functions, without need to generate data beforehand:

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
@

We can even pass additional arguments to a function:

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

Of course, user-defined functions (not shown), and anonymous functions can also be used:

<<>>=
ggplot(data.frame(x=0:1), aes(x=x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

Here is another example of a predefined function, but in this case the default scale is not the best:

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin)
@

In this case we need to change the x-axis scale to better suit the sin function and the use of radians as angular units:

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)")
@

Finally we can add annotations. Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the ggplot.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)") +
  annotate(geom="text",
           label=c("+", "-"),
           x=c(0.5, 1.5) * pi, y=c(0.5, -0.5),
           size=20) +
  annotate(geom="point",
           colour="red",
           shape=21,
           fill="white",
           x=c(0, 1, 2) * pi, y=0,
           size=6)
@

\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
pdf(file="fig1.pdf", width=8, height=6)
print(fig1)
dev.off()
@

Encapsulated Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file="fig1.eps", width=8, height=6)
print(fig1)
dev.off()
@

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file="fig1.tiff", width=1000, height=800)
print(fig1)
dev.off()
@


