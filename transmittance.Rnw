<<echo=FALSE, cache=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(concordance=TRUE)
@

\chapter{Transmission and reflection}\label{chap:trans:refl}

%\begin{abstract}
%
%\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<message=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologyFilters)
library(photobiologyLEDs)
@

%%%%
\section{Introduction}\label{sec:}


In\index{transmittance} this chapter we explain how to do calculations related to the description of absorption and reflection of UV and VIS radiation.

\section{Task: absorbance and transmittance}

Transmittance\index{transmittance} is defined as:
\begin{equation}
\tau(\lambda) = \frac{I}{I_0} = \frac{\sirr}{\sirr[0]} = \frac{\spfd}{\spfd[0]}
\end{equation}

Given this simple relation $\tau(\lambda)$ can be calculated as a division between two "source\_spct" objects. This gives the correct answer, but as an object of class "source.scpt".

<<eval=FALSE>>=
tau <- spc_above / spc_below
@

Absorptance\index{absorptance} is just $1 - \tau(\lambda)$, but should be distinguished from absorbance\index{absorbance} ($A(\lambda)$) which is measured on a logarithmic scale:

\begin{equation}
A(\lambda) = -{\log}_{10} \frac{I}{I_0}
\end{equation}

In chemistry 10 is always used as the base of the logarithm, but in other contexts sometimes $\mathrm{e}$ is used as base.

Given the simple equation, $A(\lambda)$ can be also easily calculated using the operators for spectra. This gives the correct answer, but in an object of class "source.scpt".

The conversion between $\tau(\lambda)$ and $A(\lambda)$ is:

\begin{equation}
A(\lambda) = -{\log}_{10} \tau(\lambda)
\end{equation}

which in S language is:

<<eval=FALSE>>=
my_T2A <- function(x) {-log10(x)}
@

The conversion between  $A(\lambda)$ and $\tau(\lambda)$ is:

\begin{equation}
\tau(\lambda) = 10^{-A(\lambda)}
\end{equation}

which in S language is:

<<eval=FALSE>>=
my_A2T <- function(x) {10^-x}
@

Instead of these functions, the package \PB defines generic functions and specialized functions, that can be used on numeric vectors and on \code{filter\_spct} objects. The functions defined above could be directly applied to vectors but doing this on a column in a \code{filter\_spct} is more cumbersome. As the spectra objects are data.tables, one can add a new column, say with transmittances to a copy of the filter data as is shown in the next section.


%%%%
\section{Task: spectral absorbance from spectral transmittance}\label{sec:trans:T2A}

Using \code{filter\_spct} objects, the calculations become very simple.

<<>>=
my_gg400.spct <- schott.mspct$GG400
T2A(my_gg400.spct)
a.gg400.spct <- T2A(my_gg400.spct, action="replace")
@

As in addition to the \code{T2A} method for \code{filter\_spct} there is a \code{T2A} method available for numeric vectors.

<<>>=
my_gg400.spct <- schott.mspct$GG400
my_gg400.spct$A <- T2A(my_gg400.spct$Tfr)
my_gg400.spct
@

or even on single numeric values:
<<>>=
T2A(0.001)
@

%%%%
\section{Task: spectral transmittance from spectral absorbance}

Please, see section \ref{sec:trans:T2A} for more details in the description of the method \code{T2A} which does the opposite conversion than the method \code{A2T} needed for this task, but which works similarly.

<<>>=
A2T(a.gg400.spct)
A2T(a.gg400.spct, action="replace")
@

%%%%
\section{Task: reflected or transmitted spectrum from spectral reflectance and spectral irradiance}

When we multiply a \code{source\_spct} by a \code{filter\_spct} or by a \code{reflector\_spct} we obtain as a result a new \code{source\_spct}.

<<>>=
class(sun.spct)
class(schott.mspct$GG400)
@

<<>>=
my_sun.spct <- sun.spct
my_gg400.spct <- schott.mspct$GG400
filtered_sun.spct <- sun.spct * schott.mspct$GG400
class(filtered_sun.spct)
head(filtered_sun.spct)
@

The result of the calculation can be directly used as an argument, for example, when calculating irradiance.

<<>>=
q_irrad(sun.spct, UV()) * 1e6
q_irrad(my_sun.spct, UV()) * 1e6
q_irrad(filtered_sun.spct, UV()) * 1e6
q_irrad(sun.spct * schott.mspct$GG400, UV()) * 1e6
q_irrad(my_sun.spct * my_gg400.spct, UV()) * 1e6
@

<<>>=
q_irrad(my_sun.spct * my_gg400.spct) * 1e6
q_irrad(my_sun.spct * my_gg400.spct,
             new_waveband(min(sun.spct), max(sun.spct))) * 1e6
@

Remember, that if we want to predict the output of a light source composed of different lamps or LEDs we can add the individual spectral irradiance, but using data measured from the target positions of each individual light source. If we want then to add the effect of a filter we must multiply by the filter transmittance.

<<>>=
my_luminaire <-
  (0.5 * Norlux_B.spct + Norlux_R.spct) *  plexiglas.mspct$Clear_0A000_XT
my_luminaire
# equivalent
my_luminaire <-
  (Norlux_B.spct * 0.5 + Norlux_R.spct) *  plexiglas.mspct$Clear_0A000_XT
my_luminaire

q_ratio(my_luminaire,
             list(Red(), Blue(), Green()), PAR())
q_irrad(my_luminaire,
             list(PAR(), Red(), Blue(), Green())) *  1e6
@

%%%%
\section{Task: total spectral transmittance from internal spectral transmittance and spectral reflectance}\label{sec:}

\index{transmittance}\index{reflectance}
%%%%
\section{Task: combined spectral transmittance of two or more filters}\label{sec:}

\subsection{Ignoring reflectance}


\subsection{Considering reflectance}

%%%%
\section{Task: light scattering media (natural waters, plant and animal tissues)}\label{sec:}

<<>>=
try(detach(package:photobiologyFilters))
try(detach(package:photobiologyLEDs))
try(detach(package:photobiologyWavebands))
try(detach(package:photobiology))
@

