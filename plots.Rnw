% !Rnw root = r4p.main.Rnw

<<echo=FALSE, cache=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(self.contained=FALSE)
opts_knit$set(concordance=TRUE)
@

\chapter{Plotting spectra and colours}

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\begin{abstract}
  In this chapter we explain how to plot spectra and colours, using packages \code{ggplot2}, \code{ggtern}, and the functions in our package \code{photobiologygg}. Both \code{ggtern} for ternary plots and \code{photobiologygg} for annotating spectra build new functionality on top of the \code{ggplot2} package.
\end{abstract}


\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<cache=FALSE>>=
library(ggplot2)
library(ggtern)
library(gridExtra)
library(photobiology)
library(photobiologyFilters)
library(photobiologyWavebands)
library(photobiologygg)
@

<<echo=FALSE, include=FALSE, cache=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_chunk$set(cache=TRUE)
@


%%%%
\section{Introduction to plotting spectra}\label{sec:plot:intro}

We show in this chapter examples of how one can plot spectra. All the examples
are done with package \code{ggplot2}, sometimes using in addition other packages.
\code{ggplot2} provides the most recent type plotting functionality in R, and is
what we use here for most examples. Both \code{base} graphic functions, part of
R itself and `trellis' graphics provided by package \code{lattice} are other popular
alternatives. Several of the functions used in this chapter are extensions to
package \code{ggplot2}\footnote{\code{ggplot2} is feature-frozen. Consequently
it is a good basis for adding application specific functionality through separate
packages. \code{ggplot2} uses the \emph{grammar
of graphics} for describing the plots. This grammar, because it is consistent,
tends to be easier to understand, and makes it easier to design new functionality
that uses extensions based on the same `language grammar' as used by the original package.}

If you are not familiar with \code{ggplot2} plotting, please read Appendix
\ref{chap:R:plotting} on page \pageref{chap:R:plotting} before reading the
present chapter.

%%%%
\section[Task: plotting spectra with ggplot2]{Task: plotting spectra with \code{ggplot2}}\label{sec:plot:spc}

We create a simple line plot, assign it a variable called \code{fig\_sun.e} and then on the next line \code{print} it. We use \code{labs} to set nice axis labels.

<<sun-e-0>>=
fig_sun.e <-
  ggplot(data=sun.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line()  +
  labs(
    y = expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
    x = "Wavelength (nm)")
fig_sun.e
@

As we are going to re-use the same axis-labels, it is handy to save their definition to a variable. These defintions are used later on in this chapter's example code.

<<axis-labs>>=
ylab_watt <-
  expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1}))
ylab_watt_atop <-
  expression(atop(Spectral~~energy~~irradiance,
                  (W~m^{-2}~nm^{-1})))
ylab_umol <-
  expression(Spectral~~photon~~irradiance~~(mu*mol~m^{-2}~s^{-1}~nm^{-1}))
ylab_umol_atop <-
  expression(atop(Spectral~~photon~~irradiance,
                  (mu*mol~m^{-2}~s^{-1}~nm^{-1})))
@


%%%%
\section{Task: using a log scale}\label{sec:plot:log}

Here without need to recreate the figure, we add a logarithmic scale for the y-axis and print on the fly the result. In this case we override the automatic limits of the scale.

<<plot-fig-sun-e-1>>=
fig_sun.e + scale_y_log10(limits=c(1e-3, 1e0))
@

%%%%

\section{Task: compare energy and photon spectral units}\label{sec:plot:phot:energy}

We can use function \code{grid.arrange} to make a single plot from two separate ggplots, and put them side by or on top of each other.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<theme-stack>>=
theme_stack_opts <-
  list(theme(axis.text.x = element_blank(),
             axis.ticks = element_blank(),
             axis.title.x = element_blank()))
num_one_dec <- function(x, ...) {
  format(x, nsmall=1, trim=FALSE, width=4, ...)
  }
fig_sun.q <-
  ggplot(data=sun.spct, aes(x=w.length, y=s.q.irrad * 1e6)) +
  geom_line() +
  scale_y_continuous(labels = num_one_dec) +
  labs(y = ylab_umol_atop) +
  theme_stack_opts
fig_sun.e1 <- fig_sun.e +
  labs(y = ylab_watt_atop,
       x = "Wavelength (nm)")
grid.arrange(fig_sun.q, fig_sun.e1, nrow=2)
@

To make sure that the widths of booth plots are the same, we need to make sure that the tick labels in both plots have the same format. For this we define a formatting function \code{num\_one\_dec} and then use it a the scale definition. We also add \code{atop} to the expression to set the spectral irradiance units on a second line in the axis label.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\section{Task: finding peaks and valleys in spectra}\label{sec:get:pk:vly}

We first show the use of function \code{get\_peaks} that returns the wavelengths at which peaks are located. The parameter \code{span} determines the number of values used to find a local maximum (the higher the value used, the fewer maxima are detected), and the parameter \code{ignore\_threshold} the fraction of the total span along the irradiance that is taken into account (a value of 0.75, requests only peaks in the upper 25\% of the $y$-range to be returned; a value of -0.75 works similarly but for the lower half of the $y$-range)\footnote{In the current example setting \code{ignore\_threshold} equal to 0.75 given that the range of the spectral irradiance data goes from 0.00~\umolnm to \Sexpr{round(max(sun.spct$s.e.irrad), 2)}~\umolnm, causes any peaks having a spectral irradiance of less than \Sexpr{round(max(sun.spct$s.e.irrad) * 0.75, 2)} \umolnm to be ignored.}.  It is good to mention that \code{head} returns the first six rows of its argument, and we use it here just to reduce the length of the output, if you run these examples yourself, you can remove \code{head} from the code. In the output, $x$ corresponds to wavelength, and $y$ to spectral irradiance, while \code{label} is a character string with the wavelngth, possibly formatted.

<<peaks-1>>=
head(with(sun.spct,
          get_peaks(w.length, s.e.irrad, span=31)))
head(with(sun.spct,
          get_peaks(w.length, s.e.irrad, span=31,
                    ignore_threshold=0.75)))
@

The parameter span, indicates the size in number of observations (e.g.\ number of discrete wavelength values) included in the window used to find local maxima (peaks) or minima (valleys). By providing different values for this argument
we can `adjust' how \emph{fine} or \emph{coarse} is the structure described by the peaks returned by the function. The window is always defined using an odd number of observations, if an even number is provided as argument, it is increased by one, with a warning.

<<peaks-2>>=
head(with(sun.spct,
          get_peaks(w.length, s.e.irrad, span=21)))
head(with(sun.spct,
          get_peaks(w.length, s.e.irrad, span=51)))
@

The equivalent function for finding valleys is \code{get\_valleys} taking the same parameters as \code{get\_peaks} but returning the wavelengths at which the valleys are located.

<<valleys-1>>=
head(with(sun.spct,
          get_valleys(w.length, s.e.irrad, span=51)))
head(with(sun.spct,
          get_valleys(w.length, s.e.irrad, span=51,
                      ignore_threshold=0.5)))
@

In the next section, we plot spectra and annotate them with peaks and valleys. If you find the meaning of the
parameters \code{span} and \code{ignore\_threshold} difficult to grasp from the explanation given above, please, study the code and plots in section \ref{sec:stat:pk:vly}.

%%%%
\section{Task: annotating peaks and valleys in spectra}\label{sec:stat:pk:vly}

Here we show an example of the use the new \code{ggplot} `statistics' \code{stat\_peaks}
from our package \code{photobiologygg}. It uses the same parameter names and take the
same arguments as the \code{get\_peaks} function described in section \ref{sec:get:pk:vly}.
We reuse once more \code{fig\_sun.e} saved in section \ref{sec:plot:spc}.

<<fig-sun-e-2>>=
fig_sun.e + stat_peaks(span=31)
@

\sloppy
Now we play with \texttt{ggplot2} to show different ways of plotting the peaks and valleys.
It behaves as a \code{ggplot2} \code{stat\_xxxx} function accepting a \code{geom} argument
and all the aesthetics valid for the chosen geom. By default \code{geom\_text} is used.

We can change aesthetics, for example the colour:
<<fig-sun-e-3>>=
fig_sun.e + stat_peaks(colour="red", span=31) +
            stat_valleys(colour="blue", span=51)
@

We can also use a different geom, in this case \code{geom\_point}, however, be aware that the \code{geom} parameter takes as argument a character string giving the name of the geom, in this case \code{"point"}.
We change a few additional aesthetics of the points: we set \code{shape} to a character, and set its size to 6.

<<fig-sun-e-4>>=
fig_sun.e +
  stat_peaks(colour="red", geom="point",
             shape="|", size=6, span=31)
@

We can add the same \code{stat} two or more times to a ggplot, in this example, each time with a different \code{geom}. First we add points to mark the peaks, and afterwards add labels showing the wavelengths at which they are located using geom \code{"text"}. For the \code{shape}, or type of symbol, we use one that supports `fill', and set the \code{fill} to \code{"white"} but keep the border of the symbol \code{"red"} by setting \code{colour}, we also change the \code{size}. With the labels we use \code{vjust} to `justify' the text moving the labels vertically, so that they do not overlap the line depicting the spectrum\footnote{The default position of labels is to have them centred on the coordinates of the peak or valley. Unless we rotate the label, \code{vjust} can be used to shift the label along the $y$-axis, however, justification is a property of the text, not the plot, so the vertical direction is referenced to the position of the text of the label. A value of 0.5 indicates centering, a negative value `up' and a positive value `down'. For example a value of -1 puts the $x, y$ coordinates of the peak or valley at the lower edge of the `bounding box' of the text. For \code{hjust} values of -1 and 1 right and left justify the label with respect to the $x, y$ coordinates supplied. Values other than -1, 0.5, and 1, are valid input, but are rather tricky to use for \code{hjust} as the displacement is computed relative to the width of the bounding box of the label, the displacement being different for the same numerical value depending on the length of the label text.}
In addition we expand the $y$-axis scale so that all labels fall within the plotting area.

<<fig-sun-e-5>>=
fig_sun.e +
  stat_peaks(colour="red", geom="point", shape=23,
             fill="white", size=3, span=31) +
  stat_peaks(colour="red", vjust=-1, span=31) +
  expand_limits(y=0.9)
@

Finally an example with rotated labels, using different colours for peaks and valleys. Be aware that the `justification' direction, as discussed in the footnote, is referenced to the position of the text, and for this reason to move the rotated labels upwards we need to use \code{hjust} as the desired displacement is horizontal with respect to the orientation of the text of the label. As we put peak labels above the spectrum and valleys bellow it, we need to use \code{hjust} values of opposite sign, but the exact values used were simply adjusted by trial and error until the figure looked as desired.

<<fig-sun-e-6>>=
fig_sun.e +
  stat_peaks(angle=90, hjust=-0.5, colour="red", span=31) +
  stat_valleys(angle=90, hjust=1, color="blue", span=51) +
  expand_limits(y=1.0)
@

See section \ref{?} in chapter \ref{chap:sources} for an example these stats together with facets.

%%%%
\section{Task: annotating wavebands}\label{sec:plot:ann:wband}

The function \code{annotate\_waveband} can be used to highlight a waveband in a plot of spectral data. Its first argument should be a \code{waveband} object, and the second argument a \code{geom} as a character string. The positions on the x-axis are calculated automatically by default, but they can be overridden by explicit arguments. The vertical positions have no default, except for \code{ymin} which is equal to zero by default. The colour has a default value calculated from waveband definition, in addition x is by default set to the midpoint of the waveband along the wavelength limits. The default value of the labels is the `name' of the waveband as returned by \code{labels.waveband}.

Here is an example for \PAR using defaults, and with arguments supplied only for parameters with no defaults. The example does the annotation using two different `geoms', \code{"rect"} for marking the region, and \code{"text"} for the labels.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<figvl-1>>=
figvl <- fig_sun.e + annotate_waveband(PAR(), "rect", ymax=0.82) +
                     annotate_waveband(PAR(), "text", y=0.86)
figvl + theme_bw()
@

This example annotates a narrow waveband.

<<figvl-2>>=
figvl <- fig_sun.e + annotate_waveband(Yellow(), "rect", ymax=0.82) +
                     annotate_waveband(Yellow(), "text", y=0.86)
figvl + theme_bw()
@

Now an example that is more complex, and demonstrates the flexibility of plots produced with \code{ggplot2}. We add annotations for eight different wavebands, some of them overlapping. For each one we use two `geoms' and some labels are rotated and justified. We can also see in this example that the annotations look nicier on a white background, which can be obtained with \code{theme\_bw}. A much simpler, but less fexible approach for adding annotations for several wavedands is decribed on page \pageref{chunk:plot:ann:tag}.

<<figv2>>=
figv2 <- fig_sun.e +
  annotate_waveband(UVC(), "rect",
                    ymax=0.82) +
  annotate_waveband(UVC(), "text",
                    y=0.86) +
  annotate_waveband(UVB(), "rect",
                    ymax=0.82) +
  annotate_waveband(UVB(), "text",
                    y=0.80, angle=90, hjust=1) +
  annotate_waveband(UVA(), "rect",
                    ymax=0.82) +
  annotate_waveband(UVA(), "text",
                    y=0.86) +
  annotate_waveband(Blue("Sellaro"), "rect",
                    ymax=0.82) +
  annotate_waveband(Blue("Sellaro"), "text",
                    y=0.5, angle=90, hjust=1) +
  annotate_waveband(Green("Sellaro"), "rect",
                    ymax=0.82) +
  annotate_waveband(Green("Sellaro"), "text",
                    y=0.50, angle=90, hjust=1) +
  annotate_waveband(Red(), "rect",
                    ymax=0.82) +
  annotate_waveband(Red(), "text",
                    y=0.86) +
  annotate_waveband(Red("Smith"), "rect",
                    ymax=0.82) +
  annotate_waveband(Red("Smith"), "text",
                    y=0.80, angle=90, hjust=1) +
  annotate_waveband(Far_red("Smith"), "rect",
                    ymax=0.82) +
  annotate_waveband(Far_red("Smith"), "text",
                    y=0.80, angle=90, hjust=1)
figv2 + theme_bw()
@

A simple example using \code{geom\_vline}:

<<figvl-3>>=
figvl3 <- fig_sun.q +
  geom_vline(xintercept=range(PAR()))
figvl3
@

And one where we change some of the aesthetics, and add a label:

<<figvl-4>>=
figvl4 <- fig_sun.q +
  geom_vline(xintercept=range(PAR()), linetype="dashed") +
  annotate_waveband(PAR(), "text", y=1.4, size=10, colour="black")
figvl4
@

Now including calculated values in the labels. Because of using expressions to obtain superscripts we need to add \code{parse=TRUE} to the call.

<<sun-0>>=
fig_sun <- ggplot(data=sun.spct,
                  aes(x=w.length, y=s.e.irrad)) +
  geom_line() +
  labs(y = ylab_watt,
       x = "Wavelength (nm)")
uvb <- e_irrad_spct(sun.spct, UVB())
uva <- e_irrad_spct(sun.spct, UVA())
par <- q_irrad_spct(sun.spct, PAR()) * 1e6
fig_sun2 <- fig_sun +
  annotate_waveband(UVB(), "rect", ymax=0.82) +
  annotate_waveband(UVB(), "text",
                    label=paste("UVB:~", signif(uvb, digits=2),
                                "*~W~m^{-2}~nm^{-1}", sep=""),
                    y=0.2, hjust=0, angle=90, colour="black",
                    parse=TRUE) +
  annotate_waveband(UVA(), "rect", ymax=0.82) +
  annotate_waveband(UVA(), "text",
                    label=paste("UVA:~", signif(uva, digits=2),
                                "*~W~m^{-2}~nm^{-1}", sep=""),
                    y=0.86, colour="black", parse=TRUE) +
  annotate_waveband(PAR(), "rect", ymax=0.82) +
  annotate_waveband(PAR(), "text",
                    label=paste("PAR:~", signif(par,digits=2),
                                "*~mu*mol~m^{-2}~s^{-1}", sep=""),
                    y=0.86, colour="black", parse=TRUE)
fig_sun2 + theme_bw()
@

This also works for effective exposures or doses, in this case as we position the annotations manually, we can use ggplot2's `normal' \code{annotate}.

<<fig-dsun, warning=FALSE>>=
fig_dsun <- ggplot(data=sun.daily.spct * polythene.new.spct,
                   aes(x=w.length, y=s.e.irrad * 1e-3)) + geom_line() +
  geom_line(data=sun.daily.spct * polyester.new.spct, colour="red") +
  geom_line(data=sun.daily.spct * PC.spct, colour="blue") +
  labs(y = expression(Spectral~~energy~~exposure~~(kJ~m^{-2}~d^{-1}~nm^{-1})),
       x = "Wavelength (nm)") + xlim(290, 425) + ylim(0, 25)
cie.pe <- e_irrad_spct(sun.daily.spct * polythene.new.spct, CIE()) * 1e-3
cie.ps <- e_irrad_spct(sun.daily.spct * polyester.new.spct, CIE()) * 1e-3
cie.pc <- e_irrad_spct(sun.daily.spct * PC.spct, CIE()) * 1e-3
y.pos = 22.5
fig_dsun2 <- fig_dsun +
  annotate("text",
           label=paste("Polythene~~filter~~CIE:~",
                       signif(cie.pe, digits=3),
                       "*~kJ~m^{-2}~d^{-1}", sep=""),
                    y=y.pos+2, x=300, hjust=0, colour="black",
           parse=TRUE) +
  annotate("text", label=paste("Polyester~~filter~~CIE:~",
                               signif(cie.ps, digits=3),
                               "*~kJ~m^{-2}~d^{-1}", sep=""),
                    y=y.pos, x=300,  hjust=0,  colour="red",
           parse=TRUE) +
  annotate("text", label=paste("Polycarbonate~~filter~~CIE:~",
                               signif(cie.pc, digits=3),
                               "*~kJ~m^{-2}~d^{-1}", sep=""),
                    y=y.pos-2, x=300, hjust=0,  colour="blue",
           parse=TRUE)
fig_dsun2 + theme_bw()
@

% \section{Task: automating plotting}
%
% <<>>=
% fig_sun.z <-
%   ggplot(data=sun.spct, aes(x=w.length, y=s.e.irrad)) +
%   geom_line()  +
%   labs(
%     y = expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
%     x = "Wavelength (nm)")
% fig_sun.z
% @

\section{Task: using colour as data in plots}

The examples in this section use a single spectrum, \code{sun.spct}, but all functions used are methods for \code{generiic.spct} objects, so are equally applicable to the plotting of other spectra like transmittance, reflectance or response ones.

When we want to colour-label individual spectral values, for example, by plotting the individual data points with the colour corresponding to it's wavelength, or fill the area below a plotted spectral curve with colours, we need to first \code{tag} the spectral data set using a waveband defintion or a list of waveband definitions. If we just want to add a guide or labels to the plot, we can create new data instead of tagging the spectral data to be plotted. In section \ref{sec:plot:tag} we show code based on tagging spectral data, and sectio \ref{sec:plot:guide} the case of using different data for plotting the guide or key.

\subsection{Scale definitions}\label{sec:plot:scales}

First we define some new scales for use for plotting with \code{ggplot}. In the future something equivalent may be inclided in package \code{photobiologygg}.

<<scales-1>>=
scale_colour_tgspct <-
  function(...,
           tg.spct,
           labels = NULL,
           guide = NULL,
           na.value=NA) {
    spct.tags <- attr(tg.spct, "spct.tags", exact=TRUE)
    if (is.null(guide)){
      if (spct.tags$wb.num > 12) {
        guide = "none"
      } else {
        guide = guide_legend(title=NULL)
      }
    }
    values <- as.character(spct.tags$wb.colors)
    if (is.null(labels)) {
      labels <- spct.tags$wb.names
    }
    ggplot2:::manual_scale("colour",
                           values = values,
                           labels = labels,
                           guide = guide,
                           na.value = na.value,
                           ...)
}
@

<<scales-2>>=
scale_fill_tgspct <-
  function(...,
           tg.spct,
           labels = NULL,
           guide = NULL,
           na.value=NA) {
    spct.tags <- attr(tg.spct, "spct.tags", exact=TRUE)
    if (is.null(guide)){
      if (spct.tags$wb.num > 12) {
        guide = "none"
      } else {
        guide = guide_legend(title=NULL)
      }
    }
    values <- as.character(spct.tags$wb.colors)
    if (is.null(labels)) {
      labels <- spct.tags$wb.names
    }

    ggplot2:::manual_scale("fill",
                           values = values,
                           labels = labels,
                           guide = guide,
                           na.value = na.value,
                           ...)
}
@

\subsection{Plots using colour for the spectral data}\label{sec:plot:tag}



We add wavelength-dependent colour and waveband information to the spectral data object.

<<tag-par-1>>=
par.sun.spct <- copy(sun.spct)
tag(par.sun.spct, PAR())
@

Here we use the \code{wb.f} factor that was added as part of the tagging, whcih results in a palette unrelated to the real colour of the different wavelengths.

<<tag-par-2>>=
fig_sun.z <-
  ggplot(data=par.sun.spct,
         aes(x=w.length, y=s.e.irrad)) +
  geom_line() +
  geom_point(aes(color=wb.f)) +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.z
@

As part of the tagging colour information was also added to the spectral data object (we may want to increase the number of `observations' in the spectrum by interpolation if there are too few observations for smooth colour gradient. You can play with \code{length.out} and the \code{size} of points until you get the result you like. We tag each observation in the solar spectrum with human vision colours as defined by CIE.

<<tag-vis-1>>=
tg.sun.spct <- copy(sun.spct)
tag(tg.sun.spct, VIS_bands())
@

We first plot using colours by waveband---using the colour definitions by CIE---, with symbols filled with colours. The colour data outside the wavebands is set to \code{NA} so those points are not filled.  See section \ref{sec:plot:scales} on page \pageref{sec:plot:scales} for the definition of the colour and fill scales for tagged spectra. These definitions are needed for most of the plots in the remaining of this section.

<<tag-vis-2>>=
fig_sun.z <-
  ggplot(data=tg.sun.spct,
         aes(x=w.length, y=s.e.irrad)) +
  geom_line() +
  scale_fill_tgspct(tg.spct=tg.sun.spct) +
  geom_point(aes(fill=wb.f), shape=21)  +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.z
@

Using \code{geom\_area} we can fill the area under the curve according to the colour of different wavebands, we set the fill only for this geom, so that the \code{NA}s do not affect other ploting. To get a single black curve for the spectrum we use \code{geom\_line}. This approach works as long as not two wavebands share the same value for the color, which means that it is not suitable either wwhen more than one band is outside the visible range, or when using many narrow wavebands.

<<tag-vis-3>>=
fig_sun.zz <-
ggplot(tg.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_fill_tgspct(tg.spct=tg.sun.spct) +
  geom_line() +
  geom_area(aes(fill=wb.f), alpha=0.5) +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.zz + theme_bw()
@

We can instead tag the solar spectrum with colours using the definitions of plant sensory `colours'.

<<tag-plants-1>>=
pl.sun.spct <- copy(sun.spct)
tag(pl.sun.spct, Plant_bands())
@

Here we plot using colours by waveband using the definitions of plant sensory `colours'.

<<tag-plants-2>>=
fig_sun.pl <-
ggplot(pl.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_fill_tgspct(tg.spct=pl.sun.spct) +
  geom_line() +
  geom_area(aes(fill=wb.f)) +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.pl + theme_bw()
@

We can also use the factor \code{wb.f} which has value \code{NA} outside the wavebands, changing the colour used for \code{NA} to \code{NA} which renders it invisible. We can change the labels in the scale, or when tagging the spectrum.

<<tag-plants-3>>=
fig_sun.pl <-
ggplot(pl.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  geom_area(aes(fill=wb.f)) +
  scale_fill_grey(na.value=NA, name="",
                  labels=c("UVB", "UVA", "Blue", "Green", "Red", "Far red")) +
  geom_line() +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.pl + theme_bw()
@

When using a factor we can play with the scale definitions and represent the wavebands in any way we may want. For example we can use \code{split\_bands} to split a waveband or spectrum into many adjacent narrow bands and get an almost conitnuous gradient, but we need to get around the problem of repeated colours by using the factor and redefining the scale.

When an spectrum has very few observations we can `fake' a longer spectrum by interpolation as a way of getting a more even fill. The example below is not not, in later examples we just use the example spectral data as is.

<<interpolate, eval=FALSE>>=
interpolate_spct(sun.spct, length.out=800)
@

We tag the VIS region of the spectrum with 150 narrow wavebands. As `hinges' are inserted, there is no gap, and usually there is no need to increase the length of the spectrum by intepolation. If needed one could try something
like. However, the longer spectrum should not be used for statistical calculations, not even plotting using \code{geom\_smooth}.

<<split-VIS-1>>=
splt.sun.spct <- copy(sun.spct)
tag(splt.sun.spct, split_bands(VIS(), length.out=150))
@

In the code above, we made a copy of \code{sun.spct} because being part of the package, it is write protected, and \code{tag} works by modifying its argument.

<<split-VIS-2>>=
fig_sun.splt <-
ggplot(splt.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_fill_tgspct(tg.spct=splt.sun.spct) +
  geom_area(aes(fill=wb.f), alpha=0.67) +
  geom_line() +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.splt + theme_bw()
@

In this other example we tag the whole spectrum, dividing it into 200 wavebands.

<<split-all-1>>=
splt1.sun.spct <- copy(sun.spct)
# splt1.sun.spct <- interpolate_spct(splt1.sun.spct, length.out=1000)
tag(splt1.sun.spct, split_bands(sun.spct, length.out=200))
@

We use \code{geom\_area} and \code{fill}, and colour the area under the curve. This does not work with \code{geom\_line} because there would not be anything to fill, here we use \code{geom\_area} instead.

<<split-all-2>>=
fig_sun.splt1 <-
ggplot(splt1.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_fill_tgspct(tg.spct=splt1.sun.spct) +
  geom_area(aes(fill=wb.f)) +
  geom_line() +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.splt1 + theme_bw()
@

We can use \code{alpha} to add transparency to the fill.

<<split-all-3>>=
fig_sun.splt1 <-
ggplot(splt1.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_fill_tgspct(tg.spct=splt1.sun.spct) +
  geom_area(aes(fill=wb.f), alpha=0.5) +
  geom_line() +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.splt1 + theme_bw()
@

This example uses \code{geom\_point} and \code{colour}.

<<split-all-4>>=
fig_sun.splt1 <-
ggplot(splt1.sun.spct,
       aes(x=w.length, y=s.e.irrad)) +
  scale_colour_tgspct(tg.spct=splt1.sun.spct) +
  geom_line() +
  geom_point(aes(colour=wb.f)) +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.splt1 + theme_bw()
@

When ploting points, rather than an area we may instead want to plot the colour calculated for each individual wavelength value, which \code{tag} adds to the spectrum, whether a waveband definition is supplied or not. In
this case we need to use \code{scale\_color\_identity}.

<<split-all-5>>=
fig_sun.y <-
  ggplot(data=tg.sun.spct,
         aes(x=w.length, y=s.e.irrad)) +
  geom_line() +
  scale_color_identity() +
  geom_point(aes(color=wl.color))  +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)")
fig_sun.y  + theme_bw()
@

Other possibilities are for example, using one of the symbols that can be filled, and then for example for symbols with a black border and a colour matching its wavelength as a fill aesthetic. It is also possible to use \code{alpha} with points.

\subsection{Plots using colour for the waveband definitions}\label{sec:plot:guide}


We can also add a colour bar as key. In this case we do not need to tag our spectral data, but we can instead create new data for use in what is closer to the concept of annotation that to plotting. In each of the examples below we use wavevand definitions to create tagged spectral data for use in plotting the guide using \code{geom\_rect}. We present three cases: an almost continuous colour reference guide, a reference guide for colours perceived by plants and one for ISO colour definitions. We also add labels to the bar with \code{geom\_text} and show some examples of how to change the color of the line enclosing the rectangles and of text labels. Finally we show how to use \code{fill} and \code{alpha} to adjust how the guides look.

First we add to our earlier plot a continuous colour bar fo the visible range,

<<>>=
wl.guide.spct <- wb2rect_spct(split_bands(VIS(), length.out=200))
fig_sun.yy <- fig_sun.y +
geom_rect(data=wl.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = NA) +
  scale_fill_tgspct(tg.spct=wl.guide.spct)
fig_sun.yy
@

or for the whole range of the spectral data.

<<>>=
wl.guide.spct <-
  wb2rect_spct(split_bands(new_waveband(min(sun.spct), max(sun.spct)),
                           length.out=200))
fig_sun.yy <- fig_sun.y +
geom_rect(data=wl.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = NA) +
  scale_fill_tgspct(tg.spct=wl.guide.spct)
fig_sun.yy
@

We just replace the tagged spectrum with one based on ISO colours, both in \code{geom\_rect} and in \code{scale\_fill\_tgspct}.

<<>>=
iso.guide.spct <- wb2rect_spct(VIS_bands())
fig_sun.yy <- fig_sun.y +
geom_rect(data=iso.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = NA) +
  scale_fill_tgspct(tg.spct=iso.guide.spct)
fig_sun.yy
@

or on plant's sensory colours.

<<>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())
fig_sun.yy <- fig_sun.y +
geom_rect(data=plant.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = "white") +
  scale_fill_tgspct(tg.spct=plant.guide.spct)
fig_sun.yy
@

We add text labels on top of the guide, and make the rectangle borders white to make the separation between the different `invisible' wavebands clear. As we are adding labels, the `guide' or key becomes redundant and we remove it by adding \code{guide="none"} to the fill scale.

<<>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())
fig_sun.yy <- fig_sun.y +
geom_rect(data=plant.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = "white") +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.875, label = as.character(wb.f), fill=wb.f),
       color = "white") +
  scale_fill_tgspct(tg.spct=plant.guide.spct, guide="none")
fig_sun.yy
@

Here we add \code{alpha} or transparency to make the colours paler, and use black text and lines.

<<>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())
fig_sun.yy <- fig_sun.y +
  geom_rect(data=plant.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.f),
       color = "black", alpha=0.4) +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.875, label = as.character(wb.f), fill=wb.f),
       color = "black") +
  scale_fill_tgspct(tg.spct=plant.guide.spct, guide="none")
fig_sun.yy + theme_bw()
@

We change the guide so that all rectangles are filled with the same shade of grey by moving \code{fill} out of \code{aes} and setting it to a constant. We print this new figure using the black and white theme.

<<>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())
fig_sun.yy <- fig_sun.y +
geom_rect(data=plant.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y + 0.85, ymax = y + 0.9,
           y = 0),
       color = "black", fill="grey90") +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.875, label = as.character(wb.f), fill=wb.f),
       color = "black") +
  scale_fill_tgspct(tg.spct=plant.guide.spct, guide="none")
fig_sun.yy + theme_bw()
@

We can obtain annotations similar to those in \ref{sec:plot:ann:wban} in page \pageref{sec:plot:ann:wban} created with \code{annotate\_waveband} using geoms.\label{chunk:plot:ann:tag}

<<>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())
fig_sun.yy <- fig_sun.y +
  geom_rect(data=plant.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y, ymax = y + 0.85,
           y = 0, fill=wb.f),
       color = "white", alpha=0.3) +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.88, label = as.character(wb.f), fill=wb.f),
       color = "black") +
  scale_fill_tgspct(tg.spct=plant.guide.spct, guide="none")
fig_sun.yy + theme_bw()
@

In the examples above we used predefined lists of wavebands, but one can, of course, use any list of waveband defintions, for example explicitly created with \code{list} and \code{new\_waveband}, or \code{list} and any combination of user-defined and predefined wavebands. Even single waveband definitions are allowed.

<<>>=
par.guide.spct <- wb2rect_spct(PAR())
fig_sun.yy <- fig_sun.y +
geom_rect(data=par.guide.spct,
       aes(xmin = xmin, xmax = xmax, ymin = y - 0.1, ymax = y,
           y = 0),
       color = "black", fill="grey90") +
  geom_text(data=par.guide.spct,
       aes(y = y - 0.05, label = as.character(wb.f), fill=wb.f),
       color = "black") +
  scale_fill_tgspct(tg.spct=par.guide.spct, guide="none")
fig_sun.yy + theme_bw()
@

We can also use \code{geom\_segment} to draw lines, including arrows. In this example we also set a different font \code{family} and label text. We can replace the label in the waveband defintion by assigning a name to the waveband as member of the list. We use single quotes so that the long name containg space characters is accepted by \code{list}.

<<>>=
par.guide.spct <- wb2rect_spct(list('Photosynthetically active radiation' = PAR()))
fig_sun.yy <- fig_sun.y +
  geom_segment(data=par.guide.spct,
       aes(x = xmin, xend = xmax, y = y, yend = y),
       size = 1.5, color = "black") +
  geom_text(data=par.guide.spct,
       aes(y = y + 0.05, label = as.character(wb.f), fill=wb.f),
       color = "black", family="serif") +
  scale_fill_tgspct(tg.spct=par.guide.spct, guide="none")
fig_sun.yy + theme_bw()
@

Possible variations are almost endless, so we invite the reader to continue exploring how the functions from package \code{photobiology} can be used together with \code{ggplot}, to obtain beautiful plots of spectra.

%%%%
\section{Task: plotting colours in Maxwell's triangle}\label{sec:max:tri}

\subsection{Human vision: RGB}
Given a color definition, we can convert it to RGB values by means of R's function \code{col2rgb}. We can obtain a color definition for monochromatic light from its wavelength with function \code{w\_length2rgb} (see section \ref{}), from a waveband with function \code{color} (see section \ref{}), for a wavelength range with \code{w\_length\_range2rgb} (see section \ref{}), and from a spectrum with function \code{s\_e\_irrad2rgb}  (see section \ref{}). The RGB values can be used to locate the position of any colour on Maxwell's triangle, given a set of chromaticity coordinates defining the triangle. In the first example we use some of R's predefined colors. We use the function \code{ggtern} from the package of the same name. It is based on \code{ggplot} and to produce a ternary diagram we need to use \code{ggtern} instead of \code{ggplot}. Geoms, aesthetics, stats and faceting function normally in most cases. Of course, being a ternary plot, the aesthetics \code{x}, \code{y}, and \code{z} should be all assigned to variables in the data.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<tern-1>>=
colours <- c("red", "green", "yellow", "white",
             "orange", "purple", "seagreen", "pink")
rgb.values <- col2rgb(colours)
test.data <- data.frame(colour=colours,
                        R=rgb.values[1, ],
                        G=rgb.values[2, ],
                        B=rgb.values[3, ])
maxwell.tern <- ggtern(data=test.data,
                       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
                       geom_point(shape=23, size=3) +
  geom_text(hjust=-0.2) +
  labs(x = "R", y="G", z="B") + scale_fill_identity()
maxwell.tern
@

\section{Honey-bee vision: GBU}

In this case we start with the spectral responsiveness of the photoreceptors present in the eyes of honey bees. Bees, as humans have three photoreceptors, but instead of red, green and blue (RGB), bees see green, blue and UV-A (GBU). To plot colours seen by bees one can still use a ternary plot, but the axes represent different photoreceptors than for humans, and the colour space is shifted towards shorter wavelengths.

The calculations we will demonstrate here, in addition are geared to compare a background to a foreground object (foliage vs.\ flower). We have followed xxxxx \cite{chitka?} in this example, but be aware that calculations presented in this reference do not match the equations presented. In the original published example, the calculations have been simplified by leaving out $\delta \lambda$. Although not affecting the final result for their example, intermediate results are different (wrong?). We have further generalized the calculations and equations to make the calculations also valid for spectra measured using $\delta \lambda$ that itself varies along the wavelength axis. This is the usual situation with array spectrometers, nowadays frequently used when measuring reflectance.

The assessment of the perceived `colour difference' between background and foreground objects requires taking into consideration several spectra: the incident `light' spectrum, the reflectance spectra of the two objects, and the sensitivity spectra of three photoreceptors in the case of trichromic vision. In addition to these data, we need to take into consideration the shape of the dose response of the photoreceptors.

<<>>=
try(detach(package:photobiologygg))
try(detach(package:ggtern))
try(detach(package:ggplot2))
try(detach(package:gridExtra))
try(detach(package:photobiologyFilters))
try(detach(package:photobiologyWavebands))
try(detach(package:photobiology))
@


