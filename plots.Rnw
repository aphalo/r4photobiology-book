% !Rnw root = r4p.main.Rnw
% SQ: UNICODE

<<echo=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(self.contained=FALSE)
opts_knit$set(concordance=TRUE)
@

\chapter{Plotting spectra and colours}\label{chap:plotting}

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

%\begin{abstract}
%  In this chapter we explain how to plot spectra and colours, using packages \pkg{ggplot2}, \pkg{ggtern}, and the functions in our package \pkg{ggspectra}. Both \pkg{ggtern} for ternary plots and \pkg{ggspectra} for annotating spectra build new functionality on top of the \pkg{ggplot2} package. We also use several functions and data from package \pkg{photobiology} in the examples.
%\end{abstract}


\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<cache=FALSE,message=my.debug>>=
library(ggplot2)
library(scales)
library(ggrepel)
library(gridExtra)
library(dplyr)
library(photobiology)
library(photobiologyFilters)
library(photobiologyWavebands)
library(photobiologyPlants)
library(photobiologyReflectors)
library(ggspectra)
@

<<echo=FALSE, include=FALSE, cache=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\section{Set up}

We create an object with two spectra, to be used to show grouping and faceting work.

<<>>=
two_suns.spct <- rbindspct(list(sun1 = sun.spct, sun2 = sun.spct * 2))
@

%%%%
\section{Introduction to plotting spectra}\label{sec:plot:intro}

We\index{plotting} show in this chapter examples of how spectral data can be plotted. All the examples
are done with package \pkg{ggplot2}, sometimes using in addition other packages.
\pkg{ggplot2} provides the most recent, but stable, type of plotting functionality in R, and is
what we use here for most examples. Both \code{base} graphic functions, part of
R itself and `trellis' graphics provided by package \pkg{lattice} are other popular
alternatives. The new package \pkg{ggvis} uses similar grammar as \pkg{ggplot2} but
drastically improves on functionality for interactive plots.
Several of the functions used in this chapter are extensions to
package \pkg{ggplot2}\footnote{\pkg{ggplot2} is feature-frozen, in other words the user interface
defined by the functions and their arguments will not change in future versions. Consequently
it is a good basis for adding application-specific functionality through separate
packages. \pkg{ggplot2} uses the \emph{grammar
of graphics} for describing the plots. This grammar, because it is consistent,
tends to be easier to understand, and makes it easier to design new functionality
that uses extensions based on the same `language grammar' as used by the original package.}

How to depict a spectrum in a figure has to be thought in relation to what aspect of the
information we want to highlight. A line plot of a spectrum with peaks and/or valleys labelled
highlights the shape of the spectrum, while a spectrum plotted with the area below the curve
filled highlights the total energy irradiance (or photon irradiance) for a given region
of the spectrum. Adding a bar with the colours corresponding to the different
wavelengths, facilitates the reading of the plot for people not familiar with the
interpretation on wavelengths expressed in nanometres. Labeling regions of the spectrum
with waveband names also facilitates the understanding of plotted spectral data.
A basic line plot of spectral data can be easily done with \pkg{ggplot2} or any of the
other plotting functions in R. In this chapter we focus on how to add to basic line and
dot plots all the `fancy decorations' that can so much facilitate their reading and
interpretation.

Towards the end of the chapter we give examples of plotting of RGB (red-green-blue) colours
for human vision on a ternary plot, and show how to do a ternary plot for GBU
(green-blue-ultraviolet) flower colours for honeybee vision using as reference the reflectance
of a background.

If you are not familiar with \pkg{ggplot2} and \pkg{ggtern} plotting, please read the chapter on plotting in the book \emph{Learning R \ldots{}as your learnt your mother tongue} \autocite{Aphalo2016}.

%%%%
\section{Using \texttt{plot()} methods with spectra}

Package \pkg{ggspectra}\index{spectral data!automatic plot} defines specializations of the generic \code{plot} function of R. These methods are available for all the different spectral object classes defined in package \pkg{photobiology} except for \code{generic\_spct}. They return a \code{ggplot} object, to which additional layers can be added if desired. An example of it simplest use follows in the next task. As all the spectral objects have spectral quantities expressed in known units, and an attribute indicating the time unit, the axis labels are produced automatically. If summaries are added, the units in their labels are also produced automatically. The plots produced can be to some extent tailored through options or by adding or replacing \code{ggplot} layers, the intention is for these methods to be a total that is simple, but that caters for the majority of the most frequent tasks.

\subsection{Task: plotting of \code{source\_spct} objects}\label{sec:plot:source:spc}

The defaults arguments cater the exploratory plotting of spectra, returning a plot that is heavily annotated, and using the most common units of expression. The two plots that follow show spectral irradiance, and spectral daily exposure, respectively. The objects plotted contain meta data that informs the time unit, so applying the same \code{plot} method, yields two plots with different units in the $y$-axis label.

<<plot-sun-default-0>>=
plot(sun.spct)
@

<<plot-sun-default-1>>=
plot(sun.daily.spct)
@

The parameter \code{unit} can be set to \code{"photon"} to obtain a plot depicting spectral photon irradiance. This works irrespective of whether the \code{source\_spct} object contains spectral data expressed in photon or energy units---data are converted as needed.

<<plot-sun-default-2>>=
plot(sun.spct, unit.out = "photon")
@

A list of wave bands, or a single wave band, to be used for annotation can be supplied through the \code{bands} parameter. A \code{NULL} waveband results in no waveband labels, while the next example shows how to obtain the total irradiance.

<<plot-sun-default-3>>=
plot(sun.spct, w.band = PAR(), unit.out = "photon")
@

<<plot-sun-default-4>>=
plot(sun.spct, w.band = NULL)
@

<<plot-sun-default-5>>=
plot(sun.spct, w.band = waveband(sun.spct))
@

Of course the arguments to these parameters can be supplied in different combinations, and combined with other functions as needed. This last example shows how to plot using photon-based units, selecting only a specific region of the spectrum, annotated with the red and far-red photon irradiances, using Prof.\ Harry Smith's definitions for these two wavebands using 20-nm wide bands.

<<plot-sun-default-6>>=
plot(trim_wl(sun.spct, waveband(c(600,800))),
     w.band = list(Red("Smith20"), Far_red("Smith20")), unit.out = "photon")
@

The next two examples show how to annotate an irradiance spectrum plot by equal sized wavebands.

<<plot-sun-default-7>>=
plot(sun.spct,
     w.band = split_bands(c(300,800), length.out = 5), unit.out = "photon")
@

<<plot-sun-default-8>>=
plot(trim_wl(sun.spct, PAR()),
     w.band=split_bands(PAR(), length.out = 6), unit.out = "photon")
@

<<plot-sun-default-9>>=
plot(sun.spct,
     w.band = split_bands(c(300,800), length.out = 5), unit.out = "photon")
@

Which annotations are included, depends on the argument supplied, as exemplified below.

<<plot-sun-default-10>>=
plot(sun.spct,
     annotations = c("color.guide","segments","labels"),
     w.band = VIS_bands("ISO"))
@

There are additional meta-data values stored in \code{source\_spct} objects related to re-scaling, normalization and weighting of the spectral data. These all affect axis labels, and in the case of weighting, the name of the spectral weighting function is added to the plot as an annotation. The following examples exemplify some of these, plus the use of \code{range} to limit the range of wavelengths included in the plot.

<<plot-sun-default-11>>=
plot(sun.spct * CIE(), range = c(290,400))
@

<<plot-sun-default-12>>=
plot(normalize(sun.spct))
@

\begin{framed}
\noindent
As the current implementation uses \code{ggplot} `statistic's, waveband irradiance annotations respect global aesthetics and facets. If used for simultaneous plotting in the same panel of several spectra (stored \emph{longitudinally} in a single R object), then a summary annotation should not be used as the values would be over-plotted and ambiguous.
\end{framed}

\subsection{Task: plotting of normalized \code{source\_spct} objects}\label{sec:plot:source:spc}

<<plot-sun-normalizet-0>>=
plot(normalize(sun.spct))
@

<<plot-sun-normalizet-1>>=
plot(normalize(sun.spct, norm = "max"))
@

<<plot-sun-normalizet-2>>=
plot(normalize(sun.spct, norm = 700))
@

<<plot-sun-normalizet-3>>=
plot(normalize(sun.spct, norm = "max"), range = VIS())
@

<<plot-sun-normalizet-4>>=
plot(normalize(sun.spct, norm = "max", range = Red()),
     range = VIS(), w.band = VIS_bands())
@

\subsection{Task: plotting of \code{response\_spct} objects}\label{sec:plot:response:spc}

The defaults arguments cater the exploratory plotting of spectra, returning a plot that is heavily annotated. The two plots that follow show spectral response, expressed on an energy or photon basis. We use as example the action spectrum of photosynthesis in leaves.

<<plot-response-1>>=
plot(McCree_photosynthesis.mspct$oats)
@

<<plot-response-2>>=
plot(McCree_photosynthesis.mspct$oats, unit.out = "photon")
@

For details on how to modify the wavebands used for labels and summaries, and customization of annotations, please see the previous section \ref{sec:plot:source:spc} on page \pageref{sec:plot:source:spc}. As for other \code{plot} methods described in this chapter normalization and scaling meta-data are reflected in the plot axis-labels.

\subsection{Task: plotting of \code{filter\_spct} objects}\label{sec:plot:filter:spc}

The defaults arguments cater the exploratory plotting of spectra, returning a plot that is heavily annotated, and using the most common units of expression. The three plots that follow show spectral transmittance, spectral absorptance and spectral absorbance, respectively. The objects plotted contain meta data that informs wether transmittance is expressed as \emph{internal} or \emph{total}, so applying the same \code{plot} method, will produce plots with different units in the $y$-axis label in these two cases. The difference between internal and total transmittance is explained in section \ref{sec:transmittance}.

<<plot-filter-1>>=
plot(yellow_gel.spct)
@

<<plot-filter-2>>=
plot(yellow_gel.spct, plot.qty = "absorbance")
@

Beware that \emph{absorptance} being the complement to \emph{internal transmittance} can be calculated only from transmittance alone if it is expressed as internal. If total transmittance is available, then reflectance must be also known before absorptance can be calcaluated. For this reason we use different spectral data for this example. We also illustrate how we can force the range of wavelengths included in the plot to match the range of another spectral object.

<<plot-filter-3>>=
plot(filters.mspct$GG495, range = yellow_gel.spct)
@

<<plot-filter-4>>=
plot(filters.mspct$GG495, plot.qty = "absorptance",
     range = yellow_gel.spct)
@

By default transmittance and absorptance are expressed as fractions of one. However, plotting of values expressed as percentages is also possible.

<<plot-filter-5>>=
plot(yellow_gel.spct, pc.out = TRUE)
@

<<plot-filter-6>>=
plot(filters.mspct$GG495, plot.qty = "absorptance",
     pc.out = TRUE, range = yellow_gel.spct)
@

For details on how to modify the wavebands used for labels and summaries, and customization of annotations, please see the previous section \ref{sec:plot:source:spc} on page \pageref{sec:plot:source:spc}.

\subsection{Task: plotting of \code{reflector\_spct} objects}\label{sec:plot:filter:spc}

At the moment, the only \code{plot.qty} supported is \emph{reflectance}.

<<plot-reflector-1>>=
plot(gold.spct)
@

<<plot-reflector-2>>=
plot(gold.spct, pc.out = TRUE)
@

For details on how to modify the wavebands used for labels and summaries, and customization of annotations, please see the previous section \ref{sec:plot:source:spc} on page \pageref{sec:plot:source:spc}.

\subsection{Task: plotting of \code{object\_spct} objects}\label{sec:plot:object:spc}

We will use as example the spectral properties of a plant leaf. This method is the most flexible with respect to the quantity plotted, as \code{object\_spct} objects contain more than one spectral quantity, and as $R + A + T = 1$, the three quantities are always available for plotting. By default, all three are plotted.

<<plot-object-1>>=
plot(Solidago_altissima.mspct$upper_adax)
@

<<plot-object-2>>=
plot(Solidago_altissima.mspct$upper_adax, plot.qty = "all")
@

However, they can be plotted individually, as well as absorbance.

<<plot-object-3>>=
plot(Solidago_altissima.mspct$upper_adax, plot.qty = "reflectance")
@
<<plot-object-4>>=
plot(Solidago_altissima.mspct$upper_adax, plot.qty = "absorptance")
@
<<plot-object-5>>=
plot(Solidago_altissima.mspct$upper_adax, plot.qty = "transmittance")
@
<<plot-object-6>>=
plot(Solidago_altissima.mspct$upper_adax, plot.qty = "absorbance")
@

As for \code{filter\_spct} and \code{reflector\_spct} quantities can be plotted as percentages. We give only one example here.

<<plot-object-7>>=
plot(Solidago_altissima.mspct$upper_adax, pc.out = TRUE)
@

For details on how to modify the wavebands used for labels and summaries, and customization of annotations, please see the previous section \ref{sec:plot:source:spc} on page \pageref{sec:plot:source:spc}.

%%%%
\section[Plotting spectra with ggplot2]{Plotting spectra with \pkg{ggplot2}}\label{sec:plot:spc}

Package \pkg{ggspectra} not only provides simple to use \code{plot} methods, but also `building block' that simplify the construction of custom plots of spectral data with functions from package \pkg{ggplot2}. In this section we give examples of plotting tasks carried out using this more flexible approach. In this chapter's examples we will exploit the power of the grammar of graphics to build figures piece by piece, reusing some of the `pieces' or groups of `pieces' several times to highlight the flexibility of this approach. We also exemplify the `philosophy' of defining everything that needs to be consistent across figures only once. In this section we use a \code{source\_spct} object, \code{sun.spct} in most examples, but the same approaches work with objects of any of the spectral classes from package \pkg{photobiology}. When plotting spectral objects the use of \code{aes} is optional, as \pkg{ggspectra} defines specializations of method \code{ggplot} with suitable defaults aesthetics.

\subsection{Task: plotting \code{source\_spct} objects}

We start with a very simple example, and later add layers to the plot little by little. We\index{spectral data!manual plot} create a line plot, assign it to a variable called \code{fig\_sun.e0} and then on the next line \code{print} it\footnote{we could have used \code{print(fig\_sun.e0)} explicitly, but this is needed only in scripts because printing takes places automatically when working at the R console.}. We obtain a plot with the axis labeled with the names of the variables, which is enough to check the data, but not good enough for publication.

<<plot-sun-linear-0>>=
ggplot(data = sun.spct) +
    geom_line()
@

\begin{framed}
\ilAttention\index{conflict with \pkg{ggtern}}\noindent The code above conflicts with \pkg{ggtern}, but explicitly using \code{aes} as shown below, solves this conflict.

<<plot-sun-linear-0a, eval=FALSE>>=
ggplot(data = sun.spct,
       aes(x = w.length, y = s.e.irrad)) +
       geom_line()
@
\end{framed}

Next we add \code{labs} to obtain nicer axis labels, instead of assigning the result to a variable for reuse, we print it on-the-fly. As we need superscripts for the $y$-label we have to use \code{expression} instead of a character string as we use for the $x$-label. The syntax of expressions is complex, so please look at the documentation with \code{help(plotmath)} or read a book or watch tutorial for more details.

<<plot-sun-linear-1>>=
ggplot(data = sun.spct) +
    geom_line() +
  labs(
    y = expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
    x = "Wavelength (nm)")
@

\subsection{Task: Saving axis-label definitions for re-use}

As we are going to re-use the same axis-labels in later plots, it is handy to save their definitions to variables. These definitions will be used in many of this chapter's plots. We also add \code{atop} to two of the expressions to obtain shorter versions by setting the spectral irradiance units on a second line in the axis labels.


<<plot-axis-labs>>=
ylab_watt <-
  expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1}))
ylab_watt_atop <-
  expression(atop(Spectral~~energy~~irradiance,
                  (W~m^{-2}~nm^{-1})))
ylab_umol <-
  expression(Spectral~~photon~~irradiance~~(mu*mol~m^{-2}~s^{-1}~nm^{-1}))
ylab_umol_atop <-
  expression(atop(Spectral~~photon~~irradiance,
                  (mu*mol~m^{-2}~s^{-1}~nm^{-1})))
xlab_nm <- "Wavelength (nm)"
@

<<>>=
ggplot(data = sun.spct) +
    geom_line() +
    labs(x = xlab_nm, y = ylab_watt)
@

<<>>=
ggplot(data = sun.spct, unit.out = "photon") +
    geom_line() +
    labs(x = xlab_nm, y = ylab_umol)
@

%%%%
\subsection{Task: using a log scale}\label{sec:plot:log}

Here without need to recreate the figure, we add a logarithmic scale for the $y$-axis and two of the just saved axis-labels, printing the plot on the fly. In this case we override the automatic limits of the scale. We do not give further examples of this, but could be also used with later examples, just by adjusting the values used as scale limits.

<<plot-sun-log>>=
ggplot(data = sun.spct) +
       geom_line() + 
       scale_y_log10(limits=c(1e-3, 1e0))
@

The code above generates some harmless warnings, which are due some $y$ values not being valid input for \code{log10}, the function used for the re-scaling, or because they fall outside the scale limits.
%%%%

\subsection{Task: compare energy and photon spectral units}\label{sec:plot:phot:energy}

We use once more the axis-labels saved above, but this time use the two-line label for the $y$-axis. To make sure that the width of the plotting area of both plots is the same, we need to have tick labels of the same width and format in both plots. For this we define a formatting function \code{num\_one\_dec} and then use it in the scale definition.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

As we are re-scaling the data on the fly, we need to override the default \code{aes} as a whole, we have to specify both the $x$ and $y$ aesthetics.

<<plot-par-multiple-0>>=
num_one_dec <- function(x, ...) {
  format(x, nsmall=1, trim=FALSE, width=4, ...)
  }

fig_sun.q <-
  ggplot(data=sun.spct, aes(x=w.length, y=s.q.irrad * 1e6)) +
  geom_line() +
  scale_y_continuous(labels = num_one_dec) +
  labs(x = xlab_nm)

fig_sun.e1 <-
  ggplot(data=sun.spct, aes(x=w.length, y=s.q.irrad)) +
  geom_line() +
  scale_y_continuous(labels = num_one_dec) +
  labs(x = xlab_nm)
@

We can use function \code{multiplot} to make a single plot from two separate ggplot objects, and put them side by or on top of each other. We use different $y$-axis labels in the two cases to make better use of the available space.

<<plot-par-multiple-1>>=
multiplot(fig_sun.q  + labs(y = ylab_umol_atop),
          fig_sun.e1 + labs(y = ylab_watt_atop),
          cols = 1)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_full)
@

<<plot-par-multiple-2,>>=
multiplot(fig_sun.q  + labs(y = ylab_umol),
          fig_sun.e1 + labs(y = ylab_watt),
          cols = 2)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

%%%%
\subsection{Task: annotating peaks and valleys in spectra}\label{sec:stat:pk:vly}

\begin{table}
  \sffamily\small
  \caption{Spectral features-extraction \code{ggplot} statistics defined in package \pkg{ggspectra}}\label{tab:wb:stats:peaks}
  \centering
  \begin{tabular}{ll}
    \toprule
    stat & description \\
    \midrule
    stat\_peaks & Subset and annotate local maxima \\
    stat\_valleys & Subset and annotate local minima \\
    stat\_label\_peaks & Tag and annotate local maxima \\
    stat\_label\_valleys & Tag and annotate local minima \\
    \bottomrule
  \end{tabular}
\end{table}

Here\index{spectral data!annotate peaks in plot}\index{spectral data!annotate valleys in plot} we show an example of the use of \code{stat\_peaks} and \code{stat\_valleys}
from package \pkg{ggspectra}. It uses the same parameter names and take the
same arguments as methods \code{peaks} and \code{valleys} described in section \ref{sec:summaries:peaks} on page \pageref{sec:summaries:peaks}---please, consult this section for details on how to adjust how many and which local maxima and local minima are highlighted.

We reuse once more \code{fig\_sun.e} saved in section \ref{sec:plot:spc} and we start with the simple example of highlighting the overall maximum in a spectrum. By default \code{geom\_point} is used.

<<plot-peaks-1>>=
<<>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(span=NULL)
@

We can change aesthetics, for example the colour.

<<plot-peaks-2>>=
ggplot(data = sun.spct) +
    geom_line() + 
    stat_peaks(span=NULL, color = "red")
@

The span, is the number of consecutive wavelength values in the data used to locate each individual maximum. The larger the value used, the 'coarser' the features detected. It is frequently needed to override the default so as to have only the ``meaningful'' features highlighted.

<<plot-peaks-3>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(span=31, color = "red")
@

\sloppy
Below we continue `playing' with package \pkg{ggplot2} to show different ways of plotting the peaks and valleys.
Being \pkg{ggplot2}-compatible \code{stat\_peaks} and \code{stat\_valleys} accept a \code{geom} argument
and all the aesthetics valid for the chosen \code{geom}. By overriding the default geom argument \code{"point"} with  \code{"text"} we obtain labels for peaks and valleys. Be aware that consistently with package \pkg{ggplot2}, the \code{geom} parameter takes as argument a character string giving the name of the \code{geom}, rather than the name of the function---in this case \code{geom\_text}.

<<plot-peaks-valleys-3>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(geom = "text", colour="red", span=31) +
    stat_valleys(geom = "text", colour="blue", span=51)
@

We can use the default \code{geom}, \code{geom\_point}, but change a few additional aesthetics: we set \code{shape} to a character, and set its size to 6.

<<plot-peaks-4>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(colour="red", geom="point", shape="|", size=6, span=31)
@

We can add the same \code{stat} two or more times to a \code{ggplot} object, in this example, each time with a different \code{geom}. First we add points to mark the peaks, and afterwards add labels showing the wavelengths at which they are located using geom \code{"text"}. For the \code{shape}, or type of symbol, we use one that supports `fill', and set the \code{fill} to \code{"white"} but keep the border of the symbol \code{"red"} by setting \code{colour}, we also change the \code{size}. With the labels we use \code{vjust} to `justify' the text moving the labels vertically, so that they do not overlap the line depicting the spectrum\footnote{The default position of labels is to have them centred on the coordinates of the peak or valley. Unless we rotate the label, \code{vjust} can be used to shift the label along the $y$-axis, however, justification is a property of the text, not the plot, so the vertical direction is referenced to the position of the text of the label. A value of 0.5 indicates centering, a negative value `up' and a positive value `down'. For example a value of -1 puts the $x, y$ coordinates of the peak or valley at the lower edge of the `bounding box' of the text. For \code{hjust} values of -1 and 1 right and left justify the label with respect to the $x, y$ coordinates supplied. Values other than -1, 0.5, and 1, are valid input, but are rather tricky to use for \code{hjust} as the displacement is computed relative to the width of the bounding box of the label, the displacement being different for the same numerical value depending on the length of the label text.}
In addition we expand the $y$-axis scale so that all labels fall within the plotting area.

<<plot-peaks-5>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(colour="red", geom="point", shape=23,
             fill="white", size=3, span=31) +
    stat_peaks(colour="red", geom="text", vjust=-1, span=31) +
    expand_limits(y=0.9)
@

We continue with an example with rotated labels, using different colours for peaks and valleys. As we put peak labels above the spectrum and valleys bellow it, we need to use \code{hjust} values of opposite sign, but the exact values used were simply adjusted by trial and error until the figure looked as desired.

<<plot-peaks-valleys-5>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_peaks(geom = "text", angle=90, hjust=-0.5, colour="red", span=31) +
    stat_valleys(geom = "text", angle=90, hjust=1, color="blue", span=51) +
    expand_limits(y=1.0)
@

\begin{framed}
\ilAttention \noindent Be aware that the `justification' direction, as discussed in the footnote, is referenced to the position of the text, and for this reason to move the rotated labels upwards we need to use \code{hjust} as the desired displacement is horizontal with respect to the orientation of the text of the label.
\end{framed}

The labels mapped to aesthetic can be \emph{computed} on the fly.

<<>>=
ggplot(sun.spct) + 
  geom_line() +
  stat_peaks(span = NULL) +
  stat_peaks(span = NULL, geom = "text", vjust = -0.5,
             aes(label = paste(..y.label.., "at", ..x.label.. , "nm"))) +
  expand_limits(y = c(NA, 0.9))
@

We conclude with a more elaborate plot, with the peaks labelled with wavelengths and color using a repulsive \emph{geom} from package \pkg{ggrepel}.

<<plot-peaks-valleys-6>>=
ggplot(sun.spct) + 
  geom_line() +
  stat_peaks(shape = 21, span = 25, size = 2) +
  stat_label_peaks(geom = "label_repel", span = 25,
                   size = 3.5, nudge_y = 0.075,
                   color = "white") +
  stat_valleys(shape = 21, span = 25, size = 2) +
  stat_label_valleys(geom = "label_repel", span = 25,
                     size = 3.5, nudge_y = -0.075,
                     color = "white") +
  scale_fill_identity() +
  expand_limits(y = c(-0.08, 0.9))
@

See section \ref{sec:plot:effective} on page {sec:plot:effective} for an example these stats together with facets.

%%%%
\section{Annotating wavebands and wavelengths}\label{sec:plot:ann:wband}

Several ggplot-compatible \emph{statistics} are defined in package \pkg{ggspectra} (Table \ref{tab:wb:stats:wb}). An additional high level function \code{decoration} is also provided to facilitate combining the different stats.

\begin{table}
  \sffamily\small
  \caption{Summary \code{ggplot} statistics defined in package \pkg{ggspectra}}\label{tab:wb:stats:wb}
  \centering
  \begin{tabular}{lp{0.68\linewidth}}
    \toprule
    stat & description \\
    \midrule
    stat\_wb\_contribution & Contribution of the integral of each waveband to the integral under the whole \emph{plotted} curve \\
    stat\_wb\_relative & Integral for each waveband expressed relative to the sum of all wavebands\\
    stat\_wb\_label & Label wavelength ranges or wavebands \\
    stat\_wb\_e\_irrad	& Energy irradiance for each waveband (\watt) \\
    stat\_wb\_e\_sirrad & Spectral energy irradiance for each waveband (\wattnm) \\
    stat\_wb\_q\_irrad	& Photon irradiance for each waveband (\umol) \\
    stat\_wb\_q\_sirrad & Spectral photon irradiance for each waveband (\umolnm) \\
    stat\_wb\_irrad & Irradiance for each wavebands (varies) \\
    stat\_wb\_sirrad & Spectral irradiance for each wavebands (varies) \\
    stat\_wb\_total & Integral of the spectral quantity over wavelength for each waveband \\
    stat\_wb\_mean & Mean of the spectral quantity for each waveband \\
    stat\_wl\_strip & Calculate colours from wavelength \\
    stat\_wl\_summary & Average area under curve for regions \\
    \bottomrule
  \end{tabular}
\end{table}


<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\subsection{Task: annotate a plot with waveband names as labels}

Stat \code{stat\_wb\_label} can be used to highlight a waveband in a plot of spectral data. The argument for \code{w.band} should be a \code{waveband} object, or a list of such objects. The argument for parameter \code{geom} should be supplied as a character string. The default \code{aes} provides defaults for different \emph{geoms}, and the aesthetics can be set also to some of the other computed values. The positions on the $x$-axis are calculated automatically assuming that it describes wavelengths in nanometres. The vertical position has defaults that are rarely the best, but that allow output that helps with manual positioning. The colour has a default value calculated from waveband definition, in addition x is by default set to the midpoint of the waveband along the wavelength limits. The default value of the labels is the `name' of the waveband as returned by \code{labels}.

Here is an example for \PAR using defaults except for \code{w.band}.

<<>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_wb_label(w.band = PAR())
@

The next example does the annotation using two different \emph{geoms}, \code{"rect"} for marking the region, and \code{"text"} for the labels. In this example, the order in which the graphical elements are added is important, as it determines the drawing order. In this case, it is what determines that the text is written on top of the rectangle instead of the rectangle covering the text.

<<>>=
ggplot(data = sun.spct) +
   geom_line() +
   stat_wl_strip(w.band = PAR(), geom = "rect", ymax = 0.95, ymin = 0.85) +
   stat_wb_label(w.band = PAR(), geom = "text", ypos.fixed = 0.9, color = "white") +
   ylim(NA, 0.95) +
   scale_fill_identity()
@

Now an example that is more complex, and demonstrates the flexibility of plots produced with \pkg{ggplot2}. We add annotations for all the colors defined in the ISO standard. For each one we use, as above, two \emph{geoms}. We can also see in this example that the annotations look nicer on a white background, which can be obtained with \code{theme\_bw}.

<<>>=
ggplot(data = sun.spct) +
    geom_line() +
    stat_wl_strip(w.band = VIS_bands(), geom = "rect", ymax = 1.05, ymin = 0.85) +
    stat_wb_label(w.band = VIS_bands(),
                 geom = "text", color = "white",
                 ypos.fixed = 0.95, angle = 90) +
    scale_fill_identity() +
    ylim(NA, 1.05)
@

\code{geom\_vline} without need of any ggplot \emph{statistic} allows to delimit a waveband. We use method \code{range} for \code{waveband} objects and \code{geom\_vline} to plot two vertical lines highlighting the wavelength boundaries of the waveband.

<<plot-par-vline-3>>=
ggplot(data=sun.spct, unit.out = "photon") +
    geom_line() +
    geom_vline(xintercept=range(PAR()))
@

We change some of the aesthetics in the previous figure, and add a label using \code{stat\_wb\_label} described above.

<<plot-par-vline-4>>=
ggplot(data=sun.spct, unit.out = "photon") +
    geom_line() +
    geom_vline(xintercept=range(PAR()), linetype="dashed") +
    stat_wb_label(w.band = PAR())
@

\subsection{Task: annotate a plot with waveband summary values as labels}

Next we use calculated values in the label, first for a simple example with a single waveband.
Because we use expressions to obtain superscripts we need to add \code{parse=TRUE} to the call.
In addition as we are expressing the integral in photon based units, we also change the
type of units used for plotting the spectral irradiance (multiplying by $1 \cdot 10^6$ to obtain values in \umol).

<<>>=
ggplot(sun.spct) +
    geom_line() +
    stat_wl_summary(geom = "hline", color = "red") +
    stat_wl_summary(label.fmt = "Mean = %.3g", color = "red", vjust = -0.3)
@

<<>>=
ggplot(two_suns.spct) + aes(color = spct.idx) +
    geom_line() +
    stat_wl_summary(geom = "hline") +
    stat_wl_summary(label.fmt = "Mean = %.3g", vjust = 1.2, show.legend = FALSE) +
    facet_grid(spct.idx~.)
@

<<>>=
ggplot(two_suns.spct) + aes(color = spct.idx) +
    geom_line() +
    stat_wl_summary(geom = "hline") +
    stat_wl_summary(label.fmt = "Mean = %.3g", vjust = 1.2, show.legend = FALSE) +
    facet_grid(spct.idx~., scales = "free_y")
@

<<>>=
ggplot(yellow_gel.spct) +
    stat_wb_mean(w.band = Plant_bands(), geom = "rect", alpha = 0.7) +
    stat_wb_mean(w.band = Plant_bands(), angle = 90, hjust = 0, geom = "text", ypos.fixed = 0.1,
                 aes(label = paste(..wb.name.., " = ", ..y.label.., sep = ""))) +
    geom_line() +
    scale_fill_identity()
@

<<>>=
ggplot(sun.spct, unit.out = "photon") +
    stat_wb_irrad(w.band = PAR(), geom = "rect", alpha = 0.5,
                unit.in = "photon", time.unit = "second") +
    stat_wb_irrad(w.band = PAR(), geom = "text",
                unit.in = "photon", time.unit = "second",
                aes(label = sprintf("%s = %.3g", ..wb.name.., ..yint.. * 1e6))) +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

<<>>=
ggplot(sun.spct, unit.out = "photon") +
    stat_wb_q_irrad(w.band = VIS_bands(), geom = "rect", alpha = 0.5) +
    stat_wb_q_irrad(w.band = VIS_bands(), geom = "text",
                label.mult = 1e6, size = rel(2)) +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

<<>>=
ggplot(sun.spct, unit.out = "photon") +
    stat_wb_q_sirrad(w.band = PAR(), geom = "rect", alpha = 0.5) +
    stat_wb_q_sirrad(w.band = PAR(), geom = "text",
                 aes(label = sprintf("Total %s = %.3g", ..wb.name.., ..yint.. * 1e6))) +
    stat_wb_q_sirrad(w.band = PAR(), geom = "text",
                mapping = aes(label = sprintf("Mean %s = %.3g", ..wb.name.., ..ymean.. * 1e6)),
                ypos.mult = 0.45) +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

<<>>=
ggplot(sun.spct, unit.out = "photon") +
    stat_wb_q_sirrad(w.band = VIS_bands(), geom = "rect", alpha = 0.5) +
    stat_wb_q_irrad(w.band = VIS_bands(), angle = 90, geom = "text",
                  label.mult = 1e6, ypos.fixed = 1e-7, hjust = 0,
                  aes(label = paste(..wb.name.., ..y.label.., sep = " = "),
                      color = "black")) +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

<<>>=
my.bands <- split_bands(c(300,800), length.out = 10)
ggplot(sun.spct) +
    stat_wb_e_sirrad(w.band = my.bands, geom = "rect", alpha = 0.5) +
    stat_wb_e_irrad(w.band = my.bands, angle = 90, geom = "text",
                  ypos.fixed = 0.05, hjust = 0, color = "black") +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

A plot describing ISO colors by themselves, with no $y$-data.

<<plot-par-annotate-1a>>=
ggplot(sun.spct) +
    stat_wb_mean(w.band = PAR(), geom = "rect", alpha = 0.2) +
    stat_wb_irrad(w.band = PAR(), geom = "text",
                  aes(label=paste("PAR:~", ..y.label..,
                              "*~mu*mol~m^{-2}~s^{-1}", sep="")),
                  ypos.mult = 0.5,
                  colour="black", 
                  parse=TRUE,
                  time.unit = "second",
                  unit.in = "energy") +
    geom_line() +
    scale_fill_identity()
@

Using smaller rectangles for annotation, yields plots where the spectrum itself is easier to see than when the rectangle overlaps the spectrum. We achieve this by supplying as argument both \code{ymax} and \code{ymin}, and slightly reducing the size of the text with \code{size = 4}.

<<plot-par-annotate-2>>=
ggplot(sun.spct) +
    stat_wl_strip(w.band = PAR(), geom = "rect",
                  ymin = -0.05, ymax = 0) +
    stat_wb_irrad(w.band = PAR(), geom = "text", size=4,
                  aes(label=paste("PAR:~", ..y.label..,
                              "*~mu*mol~m^{-2}~s^{-1}", sep="")),
                  ypos.fixed = 0.07,
                  colour="black", 
                  parse=TRUE,
                  time.unit = "second",
                  unit.in = "energy") +
    geom_line() +
    scale_fill_identity()
@

A bigger rectangle better shows the range of wavelengths.

<<plot-par-annotate-3>>=
ggplot(sun.spct) +
    stat_wl_strip(w.band = PAR(), geom = "rect", alpha = 0.2,
                  ymin = -Inf, ymax = +Inf) +
    stat_wb_irrad(w.band = PAR(), geom = "text", size=4,
                  aes(label=paste("PAR:~", ..y.label..,
                              "*~mu*mol~m^{-2}~s^{-1}", sep="")),
                  colour="black", 
                  parse=TRUE,
                  time.unit = "second",
                  unit.in = "energy") +
    geom_line() +
    scale_fill_identity()
@

This type of annotations can be also easily done for effective exposures or doses, but in this example as we position the annotations manually, we can use ggplot2's `normal' \code{annotate} function. We use \code{xlim} to restrict the plotted region of the spectrum to the range of wavelengths of interest.

<<>>=
ggplot(sun.spct, unit.out = "photon") +
    geom_vline(xintercept=range(CIE()), linetype = "dashed") +
    stat_wb_e_irrad(w.band = CIE(), geom = "text",
                unit.in = "photon", time.unit = "second",
                aes(label = sprintf("%s\n%.3g", ..wb.name.., ..yint..))) +
    geom_line() +
    scale_color_identity() +
    scale_fill_identity()
@

And finally some figures with multiple spectra, and effective doses.

<<>>=
filtered.lst <- list(none = sun.daily.spct,
                     yellow = sun.daily.spct * yellow_gel.spct,
                     pet = sun.daily.spct * polyester.spct)
filtered.spct <- rbindspct(filtered.lst, idfactor = "filter")
@

<<echo=FALSE, include=FALSE, cache=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<opts_fig_wide_square>>=
ggplot(filtered.spct, unit.out = "energy") +
  stat_wb_e_irrad(w.band = CIE(), geom = "text",
                unit.in = "energy", time.unit = "day",
                aes(label = sprintf("CIE %.3g", ..yint..))) +
  geom_line() +
  facet_wrap(~filter, ncol = 1) +
  scale_color_identity() +
  scale_fill_identity()
@

<<echo=FALSE, include=FALSE, cache=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\section{Using colour as data in plots}

The examples in this section use a single spectrum, \code{sun.spct}, but all functions used are methods for \code{generiic.spct} objects, so are equally applicable to the plotting of other spectra like transmittance, reflectance or response ones.

When we want to colour-label individual spectral values, for example, by plotting the individual data points with the colour corresponding to their wavelengths, or fill the area below a plotted spectral curve with colours, we need to first \code{tag} the spectral data set using a waveband definition or a list of waveband definitions. If we just want to add a guide or labels to the plot, we can create new data instead of tagging the spectral data to be plotted. In section \ref{sec:plot:tag} we show code based on tagging spectral data, and in section \ref{sec:plot:guide} the case of using different data for plotting the guide or key is described.

\subsection{Task: Plots using colour for the spectral data}\label{sec:plot:tag}

\textbf{\textcolor[rgb]{1.00,0.00,0.00}{This section needs to be updated to new version of \pkg{ggspectra} and to use geom\_bar instead of geom\_area as some of the examples produce suboptimal plots. We need also to replace direct use of tag by stat\_color.
}}

First we show how to generate the colour information from wavelengths by means of \code{ggplot} \emph{statistics}.

\code{stat\_wl\_summary()} and \code{stat\_wb\_mean()} return a \emph{reduced} data set with fewer rows than the original data. \code{stat\_wl\_strip()} depending on the input, can also return a data set with more rows than the input data. This is the default behaviour, with \code{w.band} with argument \code{NULL}. This \emph{stat} operates only on the variable mapped to the $x$ \emph{aesthetic}, a $y$-mapping is not required as input.

<<>>=
my.data <- data.frame(x = 300:800)
ggplot(my.data, aes(x)) + 
    stat_wl_strip(ymin = -1, ymax = 1) +
    scale_fill_identity() +
    scale_y_continuous(breaks = NULL)
@

The default \emph{geom} is \code{"rect"} which with suitable mappings of \code{ymin} and \code{ymax} \emph{aesthetics} can be used to add a colour guide to the $x$-axis (if its scale maps wavelengths in nanometres). When \code{w.band} is \code{NULL} a long series of contiguous wavebands is generated to create the illusion of a continuous colour gradient.

<<>>=
ggplot(sun.spct) +
    stat_wl_strip(ymin = -Inf, ymax = -0.025) +
    geom_line() +
    scale_fill_identity()
@

When a list of wavebands is supplied, it is used for the calculation of colours. These calculations do not use the spectral irradiance, they simply assume a flat spectrum, so the represent the colours of the wavelengths, rather than the colour of the light described by the spectral irradiance.

<<>>=
ggplot(sun.spct) +
    stat_wl_strip(w.band = VIS_bands(), ymin = -Inf, ymax = -0.025) +
    geom_line() +
    scale_fill_identity()
@

\code{stat\_wl\_strip()} can also used to produce a background layer with colours corresponding to \emph{wavebands}. Here we use \code{alpha = 0.5} to add transparency.

<<>>=
ggplot(sun.spct) +
    stat_wl_strip(w.band = VIS_bands(), ymin = -Inf, ymax = Inf, alpha = 0.4) +
    geom_line() +
    scale_fill_identity()
@

By default an almost continuous colour gradient can be generated for the background.

<<>>=
ggplot(sun.spct) +
stat_wl_strip(alpha = 0.4, ymin = -Inf, ymax = Inf) +
    geom_line() +
    scale_fill_identity()
@

Next, we show the most flexible, but also most verbose way of plotting using colors derived from the wavelength values in the data. Instead of using a \emph{statistic} in the plot, we can \emph{tag} the spectra before hand with color information. This can be useful if we wish to apply some additional processing to the generated color data or if the same spectrum will be plotted repeatedly as tagging the data before plotting avoid recomputing the color for each geom or plot that uses them. 

Tagging consist in adding wavelength-derived colour data and waveband-related data to a spectral object. We start with a very simple example.

<<plot-tag-1>>=
cp.sun.spct <- tag(sun.spct)
cp.sun.spct
@

As no waveband information was supplied as input, only wavelength-dependent colour information is added to the spectrum plus a factor \code{wb.f} with only \code{NA} level.

If we instead provide a waveband as input then both wavelength-dependent colour and waveband information are added to the spectral data object.

<<plot-tag-2>>=
uvb.sun.spct <- tag(sun.spct, UVB())
levels(uvb.sun.spct[["wb.f"]])
@

The output contains the same variables (columns) but now the factor \code{wb.f} has a level based on the name of the waveband, and a value of \code{NA} outside it.

We can alter the name used for the \code{wb.f} factor levels by using a named list as argument.

<<plot-tag-3>>=
uvb.sun.spct <- tag(uvb.sun.spct, list('ultraviolet-B' = UVB()))
levels(uvb.sun.spct[["wb.f"]])
@

We provide no example for this, but tagging an already tagged spectrum replaces the old tagging data with the new one, with a warning.

If we use a list of wavebands then the tagging is based on all of them, but be aware that the wavelength ranges of the wavebands overlap, the result is undefined.

<<plot-tag-4>>=
plant.sun.spct <- tag(sun.spct, Plant_bands())
levels(plant.sun.spct[["wb.f"]])
@

Tagging also adds some additional data as an attribute to the spectrum. This data can be retrieved with the base R function \code{attr}.

<<plot-tag-5>>=
attr(cp.sun.spct, "spct.tags")
attr(uvb.sun.spct, "spct.tags")
@

We now tag a spectrum for use in our first plot example.

<<plot-tag-6>>=
par.sun.spct <- tag(sun.spct, PAR())
@

We can also use other \code{geom}s like \code{geom\_area} in the next chunk, together with, as an example, a grey fill scale from \pkg{ggplot2}. We need to add \code{scale\_fill\_identity} so that the values of the \code{fill} aesthetic are used as colour definitions rather that factor levels to be mapped a different colour scale.

<<plot-tag-par-3>>=
ggplot(par.sun.spct) +
 geom_area(color=NA, aes(fill=wb.color)) +
 geom_line() +
 scale_fill_identity(na.value=NA)
@

We tag each observation in the solar spectrum with human vision colours as defined by ISO.

<<plot-tag-vis-1>>=
tg.sun.spct <- tag(sun.spct, VIS_bands())
@

The colours when displayed on screens (additive devices, as they emit light) are most frequently defined by three \emph{channels}: red, green and blue (RGB). These three numbers can be represented in different ways. In R it is common to use character strings of hexadecimal digits. The choice of these three colours is not arbitrary, they are those perceived by the three photoreceptors in our eyes\footnote{In other words almost all screen devices and printed material based on dithering of three colours just trick our eyes into seeing certain colours, even if they do not actually exist on the screen or paper. Consequently, we cannot expect other animals, like our pets to make any sense out of TV screens or colour photographs!}.

Here we plot using colours by waveband---using the colour definitions by ISO---, with symbols filled with colours. The colour data outside the wavebands is set to \code{NA} so those points are not filled.  One can play with the \code{size} of points until ones get the result wanted. The default \code{shape}s used by \pkg{ggplot2} do not accept a \code{fill} aesthetic, while shape \code{21} gives circles that can be \emph{filled}.

<<plot-tag-vis-2>>=
ggplot(tg.sun.spct) +
  geom_line() +
  geom_point(aes(fill=wb.color), shape=21) +
  scale_fill_identity()
@

Using \code{geom\_area} we can fill the area under the curve according to the colour of different wavebands, we set the fill only for this geom, so that the \code{NA}s do not affect other plotting. To get a single black curve for the spectrum we use \code{geom\_line}. This approach works as long as wavebands do not share the same value for the color, which means that it is not suitable either when any band is outside the visible range, or when using many narrow wavebands.

<<plot-tag-vis-3>>=
ggplot(tg.sun.spct) +
  scale_fill_identity() +
  geom_line() +
  geom_area(aes(fill=wb.color), alpha=0.75)
@

In the next example we tag the solar spectrum with colours using the definitions of plant sensory `colours'.

<<plot-tag-plants-1>>=
pl.sun.spct <- tag(sun.spct, Plant_bands())
@

Here we plot the wavebands corresponding to plant sensory `colours', using the spectrum we tagged in the previous code chunk.

<<plot-tag-plants-2>>=
ggplot(pl.sun.spct) +
geom_area(aes(fill=wb.color), alpha=0.75) +
  geom_line() +
  scale_fill_identity()
@

We can also use the factor \code{wb.f} which has value \code{NA} outside the wavebands, changing the colour used for \code{NA} to \code{NA} which renders it invisible. We can change the labels used for the wavebands in two different way, when plotting by supplying a labels argument to the scale used, or when tagging the spectrum. The second approach is simpler when producing several different plots from the same spectral object, or when wanting to have consistent labels and names used also in derived results such as irradiance.

<<plot-tag-plants-3>>=
ggplot(pl.sun.spct) +
  geom_area(aes(fill=wb.f)) +
  geom_line() +
  scale_fill_grey(na.value=NA, name="",
                  labels=c("UVB", "UVA", "Blue", "Green", "Red", "Far red"))
@

When using a factor we can play with the scale definitions and represent the wavebands in any way we may want. For example we can use \code{split\_bands} to split a waveband or spectrum into many adjacent narrow bands and get an almost continuous gradient, but we need to get around the problem of repeated colours by using the factor and redefining the scale.

When an spectrum has very few observations we can `fake' a longer spectrum by interpolation as a way of getting a more even fill. The example below is not run, in later examples we just use the example spectral data as is.

<<plot-interpolate, eval=FALSE>>=
dense.sun.spct <- interpolate_spct(sun.spct, length.out=800)
@

We tag the VIS region of the spectrum with 150 narrow wavebands. As `hinges' are inserted, there is no gap, and usually there is no need to increase the length of the spectrum by interpolation. However, the longer spectrum should not be used for statistical calculations, not even plotting using \code{geom\_smooth}.

<<plot-split-VIS-1>>=
splt.sun.spct <- tag(sun.spct, split_bands(VIS(), length.out=150))
@

In the code above, we made a copy of \code{sun.spct} using a different name so as not hide the object in package \PB.

<<plot-split-VIS-2>>=
ggplot(splt.sun.spct) +
    geom_area(aes(fill=wb.color), alpha=0.75) +
    geom_line() +
    scale_fill_identity()
@

In this other example we tag the whole spectrum, dividing it into 200 wavebands.

<<plot-split-all-1>>=
splt1.sun.spct <- tag(sun.spct, split_bands(sun.spct, length.out=200))
@

We use \code{geom\_area} and \code{fill}, and colour the area under the curve. This does not work with \code{geom\_line} because there would not be anything to fill, here we use \code{geom\_area} instead.

<<split-all-2>>=
ggplot(splt1.sun.spct) +
    geom_area(aes(fill=wb.color), alpha=0.75) +
    geom_line() +
    scale_fill_identity()
@

The next example uses \code{geom\_point} and \code{color} to color the data points according to the waveband they are included in.

<<plot-split-all-4>>=
ggplot(tg.sun.spct) +
    geom_line() +
    geom_point(aes(color=wb.color)) +
    scale_colour_identity()
@

When plotting individual observations as points, instead of using colours from wavebands, we will want to plot the colour calculated for each individual wavelength value, which \code{tag} adds to the spectrum, whether a waveband definition is supplied or not. In
this case we need to use \code{scale\_color\_identity}.

<<plot-split-all-5>>=
ggplot(data=tg.sun.spct) +
    scale_color_identity() +
    geom_point(aes(color=wl.color))  +
    geom_line()
@

Other possibilities are for example, using one of the symbols that can be filled, and then for example for symbols with a black border and a colour matching its wavelength as a fill aesthetic. It is also possible to use \code{alpha} with points.

\subsection{Task: Plots using waveband definitions}\label{sec:plot:guide}

In the previous section we showed how tagging spectral data can be used to add colour information that can be used when plotting. In contrast, in the present section we create new `fake' spectral data starting from waveband definitions that then we plot as `annotations'. We show different types of annotations based on plotting with different \code{geom}s. We show the use of \code{geom\_rect}, \code{geom\_text}, \code{geom\_vline}, and \code{geom\_segment}, that we consider the most useful geometries in this context.

We use three different functions from package \pkg{photobiology} to generate the data to be plotted from lists of waveband definitions. We use mainly pre-defined wavebands, but user defined wavebands can be used as well. We start by showing the output of these functions, starting with \code{wb2spct} the simplest one.

<<plot-wb2spct>>=
wb2spct(PAR())
wb2spct(Plant_bands())
@

Function \code{wb2tagged\_spct} returns the same `spectrum', but tagged with the same wavebands as used to create the spectral data, and you will also notice that a `hinge' has been added, which is redundant in the case of a single waveband, but needed in the case of wavebands sharing a limit.

<<plot-wb2tagged-spct>>=
wb2tagged_spct(PAR())
wb2tagged_spct(Plant_bands())
@

The third function, \code{wb2rect\_spct} is what we use in most examples. It generates data that make it easier to plot rectangles with \code{geom\_rect} as we will see in later examples.

<<plot-wb2rect-spct>>=
wb2rect_spct(PAR())
wb2rect_spct(Plant_bands())
@

In this case instead of two rows per waveband, we obtain only one row per waveband, with a \code{w.length} value corresponding to its midpoint but with two additional columns giving the low and high wavelength limits.

As we saw earlier for tagged spectra, additional data is stored in an attribute.

<<>>=
attr(wb2rect_spct(PAR()), "spct.tags")
@

The first plot examples show how to add a colour bar as key. We create new data for use in what is closer to the concept of annotation that to plotting. In most of the examples below we use waveband definitions to create tagged spectral data for use in plotting the guide using \code{geom\_rect}. We present three cases: an almost continuous colour reference guide, a reference guide for colours perceived by plants and one for ISO colour definitions. We also add labels to the bar with \code{geom\_text} and show some examples of how to change the color of the line enclosing the rectangles and of text labels. Finally we show how to use \code{fill} and \code{alpha} to adjust how the guides look. Later on we show some examples using other \code{geom}s and also examples combining the use of tagged spectra as described in the previous section with the `annotations' described here.

We now add to the plot created above a nearly continuous colour bar for the whole spectrum. To obtain an almost continuous colour scale we use a list of 200 wavebands. We need to specify \code{color = NA} to prevent the line enclosing each of the 200 rectangles from being plotted. We position the bar at the top because we think that it looks best, but by changing the values supplied to \code{ymax} and \code{ymin} move the bar vertically and also change its width.

<<plot-wl-all-guide>>=
wl.guide.spct <-
  wb2rect_spct(split_bands(sun.spct,
                           length.out=200))

ggplot(data=sun.spct) +
  geom_line() +
  geom_rect(data=wl.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0, fill=wb.color),
            color = NA) +
  scale_fill_identity()
@

This second example differs very little from the previous one, but by using a waveband definition instead of a spectrum as argument to \code{split\_bands}, we restrict the region covered by the colour fill to that of the waveband. In fax a vector of length two, or any object for which a \code{range} method is available can be used as input to this function.


<<plot-wl-vis-guide>>=
wl.guide.spct <- wb2rect_spct(split_bands(VIS(), length.out=200))

ggplot(data=sun.spct) +
    geom_line() +
    geom_rect(data=wl.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0, fill=wb.color),
            color = NA) +
    scale_fill_identity()
@

In the examples above we have used a list of 200 waveband definitions created with \code{split\_bands}. If we instead use a shorter list of definitions, we get a plot where the wavebands are clearly distinguished. By default if the list of wavebands is short, a key or `guide' is also added to the plot.

To demonstrate this we replace in the previous example, the previous tagged spectrum with one based on ISO colours. We need to do this replacement in the calls to both \code{geom\_rect} and \code{scale\_fill\_tgspct}.

<<plot-iso-guide>>=
iso.guide.spct <- wb2rect_spct(VIS_bands())

ggplot(data=sun.spct) +
    geom_line() +
    geom_rect(data=iso.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0, fill=wb.color),
            color = NA) +
    scale_fill_identity()
@

We use as an example plant's sensory colours, to show the case when the wavebands in the list are not contiguous.

<<plot-plant-guide-1>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
    geom_line() +
    geom_rect(data=plant.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0, fill=wb.color),
            color = "white") +
    scale_fill_identity()
@

We add text labels on top of the guide, and make the rectangle borders and text white to make the separation between the different `invisible' wavebands clear. As we are adding labels, the `guide' or key becomes redundant and we remove it by adding \code{guide="none"} to the fill scale.

<<plot-plant-guide-2>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
  geom_line() +
  geom_rect(data=plant.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0, fill=wb.color),
            color = "white") +
  geom_text(data=plant.guide.spct,
            aes(y = y + 0.875, label = as.character(wb.f)),
            color = "white", size=4) +
  scale_fill_identity()
@

Here we add \code{alpha} or transparency to make the colours paler, and use black text and lines.

<<plot-plant-guide-3>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
  geom_line() +
  geom_rect(data=plant.guide.spct,
       aes(xmin = wl.low, xmax = wl.high,
           ymin = y + 0.85, ymax = y + 0.9,
           y = 0, fill=wb.color),
       color = "black", alpha=0.4) +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.875, label = as.character(wb.f)),
       color = "black", size=4) +
  scale_fill_identity()
@

We change the guide so that all rectangles are filled with the same shade of grey by moving \code{fill} out of \code{aes} and setting it to a constant.

<<plot-plant-guide-4>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
  geom_line() +
  geom_rect(data=plant.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y + 0.85, ymax = y + 0.9,
                y = 0),
            color = "black", fill="grey90") +
  geom_text(data=plant.guide.spct,
            aes(y = y + 0.875, label = as.character(wb.f)),
            color = "black", size=4)
@

We can obtain annotations similar to those in \ref{sec:plot:ann:wband} in page \pageref{sec:plot:ann:wband} created with \code{annotate\_waveband} using geoms.\label{chunk:plot:ann:tag}

By changing the order in which the geoms are added compared to previous examples, we make sure that the line is in the top layer of the plot.

<<plot-plant-guide-5a>>=
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct,
         aes(x=w.length, y=s.e.irrad)) +
  geom_rect(data=plant.guide.spct,
       aes(xmin = wl.low, xmax = wl.high,
           ymin = y, ymax = y + 0.85,
           y = 0, fill=wb.color),
       color = "white", alpha=0.5) +
  scale_fill_identity() +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.88, label = as.character(wb.f)),
       color = "black") +
  geom_line()
@

In the examples above we used predefined lists of wavebands, but one can, of course, use any list of waveband definitions, for example explicitly created with \code{list} and \code{new\_waveband}, or \code{list} and any combination of user-defined and predefined wavebands. Even single waveband definitions are allowed.

<<plot-par-guide-1>>=
par.guide.spct <- wb2rect_spct(PAR())

ggplot(data=sun.spct) +
  geom_line() +
  geom_rect(data=par.guide.spct,
            aes(xmin = wl.low, xmax = wl.high,
                ymin = y - 0.1, ymax = y,
                y = 0),
            color = "black", fill="grey90") +
  geom_text(data=par.guide.spct,
            aes(y = y - 0.05, label = as.character(wb.f)),
            color = "black")
@

We can also use \code{geom\_segment} to draw lines, including arrows. In this example we also set a different font \code{family} and label text. We can replace the label text which is by default obtained from the waveband definition by assigning a name to the waveband as member of the list. We use single quotes so that the long name containing space characters is accepted by \code{list}.

<<plot-par-guide-2>>=
par.guide1.spct <-
  wb2rect_spct(list('Photosynthetically active radiation' = PAR()))

ggplot(data=sun.spct) +
  geom_line() +
  geom_segment(data=par.guide1.spct,
       aes(x = wl.low, xend = wl.high,
           y = y, yend = y),
       size = 1.5, color = "black") +
  geom_text(data=par.guide1.spct,
       aes(y = y + 0.05, label = as.character(wb.f)),
       color = "black", family="serif")
@

In this section we have used until now function \code{wb2rect\_spct} to create `spectral' annotation data from waveband definitions. Two other functions are available, that are needed or easier to use in some cases. One such case is when we have a list of wavebands and we would like to mark their boundaries with vertical lines. How to do this with \code{annotate} and \code{range} was show earlier in this chapter, but this can become tedious when we have several wavebands. Here we show an alternative approach.

<<plot-plant-guide-6>>=
plant.boundaries.spct <- wb2spct(Plant_bands())
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
  geom_line() +
  geom_vline(data=plant.boundaries.spct,
             aes(xintercept = w.length),
             linetype = "dotted") +
  geom_text(data=plant.guide.spct,
       aes(y = y + 0.88, label = as.character(wb.f)),
       color = "black")
@

Function \code{wb2tagged\_spct} returns the same data as \code{wb2spct} but `tagged'. As shown in the next code chunk, tagging allows us to use waveband-dependent colours to the vertical lines.

<<plot-plant-guide-7>>=
plant.boundaries.spct <- wb2tagged_spct(Plant_bands())
plant.guide.spct <- wb2rect_spct(Plant_bands())

ggplot(data=sun.spct) +
  geom_line() +
  geom_vline(data=plant.boundaries.spct,
             aes(xintercept = w.length, color=wb.color),
             size=1, linetype="dashed") +
  geom_label(data=plant.guide.spct,
       aes(y = y + 0.88, label = as.character(wb.f), color=wb.color),
       size=4) +
  scale_color_identity()
@

Of course it is possible to combine tagged data spectra and tagged spectra created from wavebands. The tagging is consistent, so, as demonstrated in the next figure, the same aesthetic `link' works for both spectra. In this case the fill scale and the setting of fill to \code{wb.f} work across different `data' and yield a consistent look. This figure also shows that when assigning a constant to an aesthetic, it is possible to use a vector, which in the present example, saves us some work compared to adding a column to the data and using an identity scale. Contrary to earlier examples where we have added layers to a previously saved plot, here we show the whole code needed to build the figure.

<<>>=
my.sun.spct <- tag(sun.daily.spct, list(UVB(), UVA()))
annotation.spct <- wb2rect_spct(list(UVB(), UVA()))
fig_sun.uv1 <- ggplot(my.sun.spct,
                      aes(x=w.length,
                          y=s.e.irrad * 1e-3,
                          fill=wb.f)) +
  scale_fill_grey(na.value=NA, guide="none") +
  geom_area() + geom_line() +
  labs(x = "Wavelength (nm)",
       y =  expression(atop(Spectral~~daily~~exposure,
                       (kJ~~m^{-2}~d^{-1}~nm^{-1}))),
       fill = "",
       title =
   "Unweighted solar radiation (daily accumulated spectrum)") +
  geom_rect(data=annotation.spct,
            aes(xmin=wl.low, xmax=wl.high, ymin=30, ymax=32)) +
  geom_text(data=annotation.spct,
            aes(label=as.character(wb.f), y=31),
            color=c("black", "white"), size=4) +
  theme_bw()

fig_sun.uv1
@

Possible variations are almost endless, so we invite the reader to continue exploring how the functions from package \pkg{photobiology} can be used together with those from package \pkg{ggplot2}, to obtain beautiful plots of spectra. As an example here we show new versions of two plots from the previous section, one using a filled area to label the PAR region, and another one using symbols with colours according to their wavelength, to which we add a guide for PAR.

<<plot-par-tag-annotate>>=
par <- q_irrad(sun.spct, PAR()) * 1e6

fig_sun.tgrect1 <-
  ggplot(data=par.sun.spct,
         aes(x=w.length, y=s.q.irrad * 1e6)) +
  geom_line() +
  geom_area(color=NA, alpha=0.3, aes(fill=wb.f))  +
  scale_fill_grey(na.value=NA, guide="none") +
  labs(
    y = ylab_umol,
    x = "Wavelength (nm)") #+
#  stat_wb_irrad(w.band = PAR())

fig_sun.tgrect1
@

<<plot-par-tag-segment>>=
par.guide.spct <-
  wb2rect_spct(list('Photosynthetically active radiation' = PAR()))

fig_sun.tgrect2 <-
  ggplot(data=tg.sun.spct,
         aes(x=w.length, y=s.e.irrad)) +
  geom_line() +
  scale_color_identity() +
  geom_point(aes(color=wl.color))  +
  labs(
    y = ylab_watt,
    x = "Wavelength (nm)") +
  geom_segment(data=par.guide.spct,
       aes(x = wl.low, xend = wl.high, y = y, yend = y),
       size = 1.5, color = "black") +
  geom_text(data=par.guide.spct,
       aes(y = y + 0.05, label = as.character(wb.f)),
       color = "black", family="serif")

fig_sun.tgrect2 + theme_bw()
@

\section{Plotting the result of operations on spectral data}

\subsection{Task: plotting effective spectral irradiance}\label{sec:plot:effective}

This task is here simply to show that there is nothing special about plotting spectra based on calculations, and that one can combine different functions to get the job done. We also show how to `row bind' spectra for plotting, in this case to make it easy to use facets.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<plot-eff-cie-1>>=
sun.eff.cie.nf.spct <-
    tag(sun.spct * CIE(), UV_bands())
sun.eff.cie.pe.spct <-
    tag(sun.spct * polyester.spct * CIE(), UV_bands())
sun.eff.cie.spct <-
    rbindspct(list('no filter' = sun.eff.cie.nf.spct,
                   'polyester' = sun.eff.cie.pe.spct),
              idfactor = "filter")

fig_sun.cie0 <-
  ggplot(data=sun.eff.cie.spct, aes(x=w.length, y=s.e.irrad, fill=wb.f)) +
  scale_fill_grey() +
  geom_area() +
  labs(x = xlab_nm,
       y = expression(Effective~~spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
       title = "CIE 1998 erythemal BSWF") +
  facet_grid(filter~.) +
  labs(fill="") +
  xlim(NA, 400) +
  theme_bw() +
  theme(legend.position=c(0.90, 0.9))

fig_sun.cie0
@

There is one warning issued for each panel, as the use of \code{xlim} discards 400 observations for wavelengths longer than 400~\Unit(nm). One should be aware that these are estimated values and in practice stray light reduces the efficiency of the filters for blocking radiation, and the amount of stray light depends on many factors including the relative positions of plants, filter and sun.

A couple of details need to be remembered: the tagging has to be done before row-binding the spectra, as \code{tag} works only on spectra that have unique values for wavelengths and discards `repeated' rows if they are present. We use \code{theme(legend.position=c(0.90, 0.9))} to change where the legend or guide is positioned. In this case, we move the legend to a place within the plotting region. As we are using also \code{theme\_bw()} which resets the legend position to the default, the order in which they are added is significant.

\subsection{Task: making a bar plot of effective irradiance}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

In\index{effective irradiance!bar plot} this task we aim at creating bar plots depicting the contributions of the UVB and UVA bands to the total erythemal effective irradiance in sunlight filtered with different plastic films. First we calculate the effective energy irradiance using the waveband definition for \emph{erythemal} BSWF (CIE98) separately for the estimated solar spectral irradiance under each filter type.

<<plot-bar-cie-0>>=
cie.nf.irrad <- e_irrad(sun.spct * CIE(),
                        list(UVB(), UVA()))
cie.pe.irrad <- e_irrad(sun.spct * polyester.spct * CIE(),
                        list(UVB(), UVA()))
@

We assemble a data table by concatenating the irradiance and adding factors for filter type and wave bands. When
defining the factors, we use \code{levels} to make sure that the levels are ordered as we would like to plot them.

<<plot-bar-cie-1>>=
cie.dt <- data_frame(
  cie.irrad = c(cie.nf.irrad, cie.pe.irrad),
  filter = factor(rep(c('none', 'polyester'), c(2,2)),
                  levels=c('none', 'polyester')),
  w.band = factor(rep(c('UVB', 'UVA'), 2),
                  levels=c('UVB', 'UVA')) )
@

Now we plot stacked bars using \code{geom\_bar}, however as the default \code{stat} of this \code{geom} is not suitable for our data, we specify \code{stat="identity"} to have the data plotted as is. We set a specific palette for fill, and add a black border to the bars by means of \code{color="black"}, we remove the grid lines corresponding to the $x$-axis, and also position the legend within the plotting region.

<<print-bar-cie-data>>=
cie.dt
@

<<plot-bar-cie-2>>=
fig_cie_bars0 <- ggplot(data=cie.dt,
                        aes(y = cie.irrad * 1e3,
                            x = filter,
                            fill = w.band)) +
  scale_fill_brewer(palette="PRGn") +
  geom_bar(stat="identity", colour="black") +
  labs(x = "Filter type",
       y = expression(Effective~~irradiance~~~(mW~m^{-2})),
       title = "CIE 1998 erythemal BSWF",
       fill = "") +
  theme_bw(13) +
  theme(legend.position=c(0.85, 0.85)) +
  theme(panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())

fig_cie_bars0
@

The figure above is good for showing the relative contribution of UVB and UVA radiation to the total effect, and the size of the total effect. On the other hand if we would like to show how much the effective irradiance in the UVB and UVA decreases under each of the filters is better to avoid stacking of the bars, plotting them side by side using \code{position=position\_dodge()}. In addition we swap the aesthetics to which the two factors are linked.

<<plot-bar-cie-3>>=
fig_cie_bars1 <- ggplot(data=cie.dt,
                        aes(y = cie.irrad * 1e3,
                            x = w.band,
                            fill=filter)) +
  geom_bar(stat="identity",
           position=position_dodge(),
           color="black") +
  scale_fill_brewer() +
  labs(x = "Wavelength band",
       y = expression(Effective~~irradiance~~~(mW~m^{-2})),
       title = "CIE 1998 erythemal BSWF",
       fill = "") +
  theme_bw() +
  theme(legend.position=c(0.80, 0.85)) +
  theme(panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank())

fig_cie_bars1
@

\subsection{Task: plotting a spectrum using colour bars}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

We\index{spectral data!bar plot} show now the last example, related to the ones above, but creating a bar plot with more bars. First we calculate photon irradiance for different equally spaced bands within PAR using function \code{split\_bands}. The code is written so that by changing the first two lines you can adjust the output.

<<plot-bar-qirrad-bands-0>>=
wl.range <- range(PAR())
num.bands <- 15
many.bands <- split_bands(wl.range, length.out=num.bands)
w.length <- numeric(num.bands)
wb.name <- wb.color <- character(num.bands)

for (i in 1:num.bands) {
  w.length[i] <- midpoint(many.bands[[i]])
  wb.color[i] <- color(many.bands[[i]], type="CMF")
  wb.name[i] <- labels(many.bands[[i]])[["name"]]
}

q.irrad.bands.sun <- q_irrad(sun.spct, many.bands)
q.irrad.sun.spct <- data_frame(q.irrad = q.irrad.bands.sun,
                                   w.length = w.length,
                                   wb.color = wb.color,
                                   wb.name = wb.name)
@

Now we can plot the data as bars, filling each bar with the corresponding colour. In this case we plot the bars using a continuous variable, wavelength, for the $x$-axis.

<<plot-bar-qirrad-bands-1>>=
fig_qirrad_bar <- ggplot(data=q.irrad.sun.spct,
                        aes(y = q.irrad * 1e6,
                            x = w.length,
                            fill=as.character(wb.color))) +
  geom_bar(stat="identity",
           color="black") +
  scale_fill_identity(guide="none") +
  labs(x = xlab_nm,
       y = expression(Photon~~irradiance~~(mu*mol~m^{-2}~s^{-1})),
       fill = "") +
  theme_bw()

fig_qirrad_bar
@

In the case of the example spectrum with equal wavelength steps, one could have directly summed the values, however, the approach shown here is valid for any type of spacing of the values along the wavelength axis, including variable one, like is the case for array spectrometers.
%%%%
\section{Task: plotting colours in Maxwell's triangle}\label{sec:max:tri}

\subsection{Human vision: RGB}
Given\index{color!Maxwell's triangle} a color definition, we can convert it to RGB values by means of R's function \code{col2rgb}. We can obtain a color definition for monochromatic light from its wavelength with method \code{color} (see section \ref{sec:color:wl}), from a waveband (see section \ref{sec:color:range}), for a wavelength range by first constructing a \code{wavband} object (see section \ref{sec:color:range}), and from a spectrum (see section \ref{sec:color:spc}). The RGB values can be used to locate the position of any colour on Maxwell's triangle, given a set of chromaticity coordinates defining the triangle. In the first example we use some of R's predefined colors. We use the function \code{ggtern} from the package of the same name. It is based on \code{ggplot} and to produce a ternary diagram we need to use \code{ggtern} instead of \code{ggplot}. Geometries, aesthetics, stats and faceting function normally in most cases. Of course, being a ternary plot, the aesthetics \code{x}, \code{y}, and \code{z} should be all assigned to variables in the data.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

We need to load \pkg{ggtern} here because at the moment it conflicts with \pkg{ggspectra} as it redefines \code{ggplot} in a way that does not match its current definition in \pkg{ggplot2} as an S3  method.
<<>>=
library(ggtern)
@

In the first example we use colors pre-defined in R.

<<plot-tern-1>>=
colours <- c("red", "green", "yellow", "white",
             "orange", "purple", "seagreen", "pink")
rgb.values <- col2rgb(colours)
color.data <- data.frame(colour=colours,
                        R=rgb.values[1, ],
                        G=rgb.values[2, ],
                        B=rgb.values[3, ])
ggtern(data=color.data,
       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
       geom_point(shape=23, size=3) +
  geom_text(hjust=-0.2) +
  labs(x = "R", y="G", z="B") + scale_fill_identity()
@

In the second example, we calculate the colours for leaves as seen in sunlight.

<<plot-tern-2>>=
betula_reflected.mspct <-
  convolve_each(as.reflector_mspct(Betula_ermanii.mspct),
                sun.spct)
color.values <- color(betula_reflected.mspct, type = "CC")
rgb.values <- col2rgb(color.values[[2]])
leaf.data <- data.frame(leaf = color.values[[1]],
                        color = color.values[[2]],
                        R=rgb.values[1, ],
                        G=rgb.values[2, ],
                        B=rgb.values[3, ])
ggtern(data=leaf.data,
       aes(x=R, y=G, z=B, fill=color)) +
       geom_point(shape=21, size=3) +
  labs(x = "R", y="G", z="B") + scale_fill_identity()
@

%In the third example, we use wavelengths in nanometres.
%
%<<plot-tern-3>>=
%w.lengths <- c(420, 500, 530, 600, 630, 670)
%rgb.values <- col2rgb(color(w.lengths))
%wl.data <- data.frame(colour=w.lengths,
%                        R=rgb.values[1, ],
%                        G=rgb.values[2, ],
%                        B=rgb.values[3, ])
%ggtern(data=wl.data,
%       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
%       geom_point(shape=23, size=3) +
%  geom_text(hjust=-0.2) +
%  labs(x = "R", y="G", z="B") + scale_fill_identity()
%@

%\section{Honey-bee vision: GBU}
%
%In\index{colour!honey-bee vision} this case we start with the spectral responsiveness of the photoreceptors present in the eyes of honey bees. Bees, as humans have three photoreceptors, but instead of red, green and blue (RGB), bees see green, blue and \UVA (GBU). To plot colours seen by bees one can still use a ternary plot, but the axes represent different photoreceptors than for humans, and the colour space is shifted towards shorter wavelengths.
%
%The calculations we will demonstrate here, in addition are geared to compare a background to a foreground object (foliage vs.\ flower). We have followed xxxxx \cite{chitka?} in this example, but be aware that calculations presented in this reference do not match the equations presented. In the original published example, the calculations have been simplified by leaving out $\delta \lambda$. Although not affecting the final result for their example, intermediate results are different (wrong?). We have further generalized the calculations and equations to make the calculations also valid for spectra measured using $\delta \lambda$ that itself varies along the wavelength axis. This is the usual situation with array spectrometers, nowadays frequently used when measuring reflectance.
%
%The assessment of the perceived `colour difference' between background and foreground objects requires taking into consideration several spectra: the incident `light' spectrum, the reflectance spectra of the two objects, and the sensitivity spectra of three photoreceptors in the case of trichromic vision. In addition to these data, we need to take into consideration the shape of the dose response of the photoreceptors.

<<plot-clean>>=
try(detach(package:ggtern))
try(detach(package:ggspectra))
try(detach(package:photobiologyReflectors))
try(detach(package:photobiologyPlants))
try(detach(package:photobiologyFilters))
try(detach(package:photobiologyWavebands))
try(detach(package:photobiology))
try(detach(package:dplyr))
try(detach(package:gridExtra))
try(detach(package:scales))
try(detach(package:ggplot2))
@
