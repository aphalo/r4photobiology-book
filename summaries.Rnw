<<echo=FALSE, cache=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(concordance=TRUE)
opts_chunk$set(opts_fig_wide)
@

\chapter{Spectra: simple summaries and features}\label{chap:summ:spct}

%\begin{abstract}
%  In this chapter we explain how to obtain different summaries common to all types of spectral data. In addition we describe how to extract spectral features from spectral data.
%\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<message=my.debug>>=
library(photobiology)
library(photobiologyWavebands)
library(ggplot2)
library(ggspectra)
library(photobiologyLamps)
library(photobiologyFilters)
library(photobiologyReflectors)
@

\section{Task: Printing spectra}

Spectral\index{spectral data!print} objects are printed with a special \code{print} method that is an extension to the print method for \code{tibble} objects, consequently, it is possible to use options from package \pkg{tibble} to control printing. The first option set below, \code{tibble.print\_max}, sets the number of rows above which only `head' rows are printed and \code{tibble.print\_min} sets the number of rows printed when the head is printed. Another option, \code{tibble.width} sets width of the output printed for \code{tibble} objects with many columns.

<<printing-spct>>=
options(tibble.print_max = 4, tibble.print_min = 4)
@

The number of rows printed can be also controlled through an explicit argument to the second parameter of \code{print}, \code{head}, and \code{tail}. Setting an option by means of \code{options} changes the default behaviour of \code{print}, but explicit arguments can still be used for changing this behaviour in an individual statement.

\section{Task: Summaries related to object properties}\label{sec:summaries:wavelength}

In the case of the \code{summary} method\index{spectral data!summary}, specializations for \code{source\_spct} and \ldots are provided. But for other spectral objects, the \code{summary} method for \code{data.table} is called. For the \code{summary} specializations defined, the corresponding \code{print} method specializations are also defined.

<<>>=
summary(sun.spct)
@

\section{Task: Integrating spectral data}

Package \PB provides specific functions for frequently used quantities, but in addition `general purpose' function is available to add flexibility for special cases. Function \code{integrate\_spct}\index{spectral data!integral} takes into account each individual wavelength step, so it returns valid results even for spectra measured at arbitrary and varying wavelength steps. This function operates on all \code{numeric} variables contained in a spectral object except for \code{w.length}. The returned value is expressed as a total per spectrum.

<<>>=
integrate_spct(sun.spct)
@

\section{Task: Averaging spectral data}

Package \PB provides specific functions for frequently used quantities, but in addition `general purpose' function is available to add flexibility for special cases. Function \code{average\_spct}\index{spectral data!average} takes into account each individual wavelength step, so it returns valid results even for spectra measured at arbitrary and varying wavelength steps. This function operate on all \code{numeric} variables contained in a spectral object except for \code{w.length}. The returned value is expressed per nanometre.

<<>>=
average_spct(sun.spct)
@

%%%%
\section{Task: Summaries related to wavelength}\label{sec:summaries:wavelength}

Functions \code{max}\index{spectral data!wavelength max}, \code{min}\index{spectral data!wavelength min}, \code{range}\index{spectral data!wavelength range}, \code{midpoint}\index{spectral data!wavelength midpoint} when used with an object of class \code{generic\_spct} (or a derived class) return the result of applying these functions to the \code{w.length} component of these objects, returning always values expressed in nanometres as long as the objects have been correctly created.

<<>>=
range(sun.spct)
midpoint(sun.spct)
max(sun.spct)
min(sun.spct)
@

Functions \code{spread} are \code{stepsize}\index{spectral data!wavelength stepsize} are generics defined in package \PB. \code{spread}\index{spectral data!wavelength spread} returns maximum less minimum wavelengths values in nanometres, while \code{stepsize} returns a numeric vector of length two with the maximum and the minimum wavelength step between observations, also in nanometers.

<<>>=
spread(sun.spct)
stepsize(sun.spct)
@

\section{Task: Finding the class of an object}\label{sec:summaries:class}

R method \code{class} can be used with any R object, including spectra.

<<>>=
class(sun.spct)
class(polyester.spct)
@

The method \code{class\_spct} is a convenience wrapped on \code{class} which returns only class attributes corresponding to spectral classes defined in package \PB.

<<>>=
class_spct(sun.spct)
class_spct(polyester.spct)
@

The method \code{is.any\_spct} is a synonym of \code{is.generic\_spct} as \code{generic\_spct} is the base class from which all spectral classes are derived.
<<>>=
is.any_spct(sun.spct)
is.any_spct(polyester.spct)
@

Equivalent methods exist for all the classes defined in package \PB. We show two examples below, with a radiation source and a filter.

<<>>=
is.source_spct(sun.spct)
is.source_spct(polyester.spct)
@

<<>>=
is.filter_spct(sun.spct)
is.filter_spct(polyester.spct)
@

\section{Task: Querying other attributes}\label{sec:summaries:attributes}

Both\index{spectral data!metadata attributes} \code{response\_spct} and \code{source\_spct} objects have an attribute \code{time.unit} that can be queried.

<<>>=
getTimeUnit(sun.spct)
@

<<>>=
is_effective(sun.spct * CIE())
is_effective(sun.spct * UV())
@

<<>>=
getBSWFUsed(sun.spct * CIE())
@

Normalization and scaling can be applied to different types of spectral objects.

<<>>=
sun.norm.spct <- normalize(sun.spct, norm = 600)
is_normalized(sun.norm.spct)
getNormalized(sun.norm.spct)
@

<<>>=
sun.scaled.spct <- fscale(sun.spct, f = "mean")
is_scaled(sun.scaled.spct)
@

We now consider \code{filter\_spct} objects (see Chapter \ref{chap:trans:refl} for an explanation of the meaning of these attributes and how they affect calculations).

<<>>=
getTfrType(polyester.spct)
@

and  \code{reflector\_spct} objects.

<<>>=
getRfrType(gold.spct)
@

\section{Task: Query how spectral data contained is expressed}

We first consider the case of \code{source.spct} objects.
If an object contains the same data expressed differently, it is possible, as in the example for both statement to return true.

<<>>=
head(sun.spct)
is_energy_based(sun.spct)
is_photon_based(sun.spct)
@

If we delete the energy based spectral data, the result of the test changes.

<<>>=
my.spct <- sun.spct
my.spct$s.e.irrad <- NULL
head(my.spct)
is_energy_based(my.spct)
is_photon_based(my.spct)
@

We now consider \code{filter\_spct} objects.

<<>>=
is_transmittance_based(polyester.spct)
is_absorbance_based(polyester.spct)
@

\section{Task: Querying about `origin' of data}

All\index{spectral data!normalization\index{spectral data!re-scaling}} spectral objects (\code{generic\_spct} and derived types) can be queried whether they are the result of the normalization or re-scaling of another spectrum. In the case of normalization, the normalization wavelength in nanometres is returned, otherwise a logical value.

<<>>=
is_normalized(sun.spct)
is_scaled(sun.spct)
@

\code{source\_spct} objects can be queried to learn if they are the result of a calculation involving a weighting function.

<<>>=
is_effective(sun.spct)
@

\section{Task: Plotting a spectrum}

Method\index{spectral data!plot} \code{plot} is defined for \code{waveband} objects, and can be used to visually check their properties. Plotting is discussed in detail in chapter \ref{chap:plotting}.

<<>>=
plot(sun.spct)
@

<<>>=
plot(polyester.spct)
@

\section{Task: Other R's methods}

Methods \code{names} and \code{comment} should work as usual. In the case of the comment attribute, most operations on spectral objects preserve comments, sometimes with additions, or by merging of comments from operands. Comments are optional, so for some objects \code{comment} may return a \code{NULL}. As some comments contain new line characters, to get them printed nicely we need to use \code{cat}.

<<>>=
names(sun.spct)
cat(comment(sun.spct))
@

\section{Task: Find peaks and valleys}\label{sec:summaries:peaks}

Methods\index{spectral data!find peaks}\index{spectral data!find valleys} \code{peaks} and \code{valleys} can be used on most spectral objects to find local maxima and local minima in spectral data. They return an object of the same class containing only the observations corresponding to these local extremes.

<<>>=
peaks(philips.tl12.spct)
peaks(philips.tl12.spct, unit.out = "photon")
peaks(philips.tl12.spct, span = 50)
@

<<>>=
valleys(schott.mspct$KG5)
peaks(schott.mspct$KG5, filter.qty = "absorbance")
@

\subsection{Obtaining the location of peaks as an index into the spectral data}

Function \code{find\_peaks}, takes as argument a \code{numeric} vector, and returns a logical vector of the same length, with \code{TRUE} for local maxima and \code{FALSE} for all other observations. Infinite values are discarded.

<<>>=
head(find_peaks(sun.spct$s.e.irrad))
@

To obtain the indexes, one can use R's function \code{which}

<<>>=
head(which(find_peaks(sun.spct$s.e.irrad)))
@

\subsection{Obtaining the location of peaks as a wavelength in nanometres}

Function \code{get\_peaks} takes two numeric vectors as as arguments, $x$ is, for spectra assumed to be a vector of wavelengths, and $y$ the spectral variable to search for local maxima.
<<>>=
with(sun.spct, get_peaks(w.length, s.e.irrad, span = 51))[["x"]]
@
The returned value is a (shorter) data frame with two numeric vectors, $x$ and $y$, and an optional character variables \code{label}, for each local maximum found in $y$, but we extract \code{x}.

\section{Task: Refining the location of peaks and valleys}\label{sec:summaries:peak:refine}

The functions described in the previous section locate the observation with the locally highest $y$-value. This is in most cases the true location of the peaks as they may fall in between two observations along the wavelength axis. By fitting a suitable model to describe the shape of the peak, which is the result of the true peak and the slit function of the spectrometer, the true location of a peak can be approximated more precisely. There is no universally useful model, so we show some examples of a possible method of peak-position refinement.

In this example, in the second statement we refine the location of the shortest-wavelength peak found by \code{get\_peaks} in the first statement. For this approach to work, the peaks should be clearly visible, and not very close to each other. We use the spectral irradiance measured from a UV-B lamp as an example.

<<>>=
stepsize(germicidal.spct)
peaks <-
   with(germicidal.spct,
        get_peaks(w.length, s.e.irrad, span = 5))
fit <- nls(s.e.irrad ~ d + a1*exp(-0.5*((w.length-c1)/b1)^2),
           start=list(a1=3.1, b1=1, c1=peaks[1, 1], d=0),
           data=germicidal.spct)
fit
fit$m$getPars()[["c1"]]
peaks[1, 1]
@

In this case the change was rather small, and shows a small wavelength calibration error for the spectrometer that can be calculated as:

<<>>=
signif(fit$m$getPars()[["c1"]], 6) - 253.652
@

<<>>=
predicted <-
  predict(fit,
          data.frame(w.length = seq(250, 260, length.out = 101)))
fitted_peak.spct <-
  source_spct(w.length  = seq(250, 260, length.out = 101),
              s.e.irrad = predicted)
@

<<>>=
ggplot(data = fitted_peak.spct, aes(w.length, s.e.irrad)) +
  geom_line(data = fitted_peak.spct, colour = "blue") +
  geom_point(data = germicidal.spct, colour = "red", size = 3) +
  xlim(250, 260)

@

<<>>=
try(detach(package:photobiologyReflectors))
try(detach(package:photobiologyFilters))
try(detach(package:photobiologyLamps))
try(detach(package:ggspectra))
try(detach(package:ggplot2))
try(detach(package:photobiologyWavebands))
try(detach(package:photobiology))
@
