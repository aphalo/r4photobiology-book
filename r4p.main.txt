\documentclass[a4paper,10pt]{memoir}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage[utf8]{inputenc}

% \title{R for Photobiology: a handbook}
% \author{Pedro J. Aphalo \and others}
% \pretitle{\begin{center}\LARGE}
% \posttitle{\par\end{center}\vskip 0.5em}

% using Lucida bright using now free package from PC TeX
\usepackage[lucidasmallscale,nofontinfo,seriftt=true,math-style=iso]{lucimatx}
% replace option altbullet
\renewcommand{\labelitemi}{%
 {\UseTextSymbol{OMS}\textbullet}}
% needed for Lucida
\linespread{1.04}

\usepackage[footinfo, missing={`none'}]{gitinfo} % remember to setup Git hooks

\usepackage{hologo}

\usepackage[british]{babel}
\usepackage{csquotes}

%\chapterstyle{ell}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.jpg,.pdf}

\usepackage{microtype}
\usepackage[hyperindex,bookmarks,pdfview=FitB,%backref,
            pdftitle={R for Photobiology},%
            pdfkeywords={photobiology, visible radiation, ultraviolet radiation, R, quantification, methods, calculations},%
            pdfsubject={Photobiology},%
            pdfauthor={Pedro J. Aphalo, Andreas Albert}%
            ]{hyperref}
\usepackage[style=authoryear-comp,firstinits,sortcites,maxcitenames=2,%
    mincitenames=1,maxbibnames=10,minbibnames=10,backref,uniquename=mininit,%
    uniquelist=minyear,sortfirstinits=true]{biblatex}%,refsection=chapter

%\chapterstyle{veelo}

\usepackage{color,calc,soul}%,graphicx,fourier
\definecolor{nicegreen}{rgb}{.129,.647,.149}
\definecolor{grey50}{rgb}{.5,.5,.5}
\makeatletter
\newlength\dlf@normtxtw
\setlength\dlf@normtxtw{\textwidth}
%\def\myhelvetfont{\def\sfdefault{mdput}}
\newsavebox{\feline@chapter}
\newcommand\feline@chapter@marker[1][4cm]{%
\sbox\feline@chapter{%
\resizebox{!}{#1}{\fboxsep=1pt%
\colorbox{nicegreen}{\color{white}\normalfont\bfseries\thechapter}%\sffamily
}}%
\rotatebox{90}{%
\resizebox{%
\heightof{\usebox{\feline@chapter}}+\depthof{\usebox{\feline@chapter}}}%
{!}{\scshape\so\@chapapp}}\quad%
\raisebox{\depthof{\usebox{\feline@chapter}}}{\usebox{\feline@chapter}}%
}
\newcommand\feline@chm[1][4cm]{%
\sbox\feline@chapter{\feline@chapter@marker[#1]}%
\makebox[0pt][l]{% aka \rlap
\makebox[1cm][r]{\usebox\feline@chapter}%
}}
\makechapterstyle{daleif1}{
\renewcommand\chapnamefont{\normalfont\Large\scshape\raggedleft\so}
\renewcommand\chaptitlefont{\normalfont\huge\bfseries\upshape\color{nicegreen}}%\sffamily
\renewcommand\chapternamenum{}
\renewcommand\printchaptername{}
\renewcommand\printchapternum{\null\hfill\feline@chm[2.5cm]\par}
\renewcommand\afterchapternum{\par\vskip\midchapskip}
\renewcommand\printchaptertitle[1]{\chaptitlefont\raggedleft ##1\par}
}
\makeatother
\chapterstyle{daleif1}

\newlength{\drop}
%% Some shades

\newcommand*{\titleLL}{\begingroup% Lost Languages
\drop=0.1\textheight
\fboxsep 0.5\baselineskip
\sffamily
\vspace*{\drop}
\centering
{\textcolor{nicegreen}{\HUGE R for Photobiology}}\par
\vspace{0.5\drop}
\colorbox{grey50}{\textcolor{yellow}{\normalfont\itshape\Large
A handbook}}\par
\vspace{\drop}
{\Large Pedro J. Aphalo\\ and\\ Andreas Albert}\par
\vfill
{\footnotesize Git: tag\gitVtagn , committed with hash \gitAbbrevHash\ on \gitAuthorIsoDate\\ by\ \gitAuthorName \\PDF created \today\\ \copyright\ 2013-2014 by the authors}\par
\vspace*{\drop}
\endgroup}

\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{3}

\usepackage{siunitx}
\usepackage{framed}
\renewenvironment{shaded}{%
  \def\FrameCommand{\fboxsep=\FrameSep \colorbox{shadecolor}}%
  \MakeFramed{\advance\hsize-\width \FrameRestore\FrameRestore}}%
 {\endMakeFramed}
\definecolor{shadecolor}{gray}{0.80}

\usepackage{abbrev}
\usepackage{r4photobiology}

\addbibresource{rbooks.bib}
\addbibresource{handbook.bib}
\addbibresource{photobio.bib}

\newcommand{\gls}[1]{} % until start building the glossary.
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}

% knitr setup









\thispagestyle{empty}
\titleLL
\clearpage


\frontmatter
%\begin{titlingpage}
%  \maketitle
%\titleLL
%\end{titlingpage}

\tableofcontents

%\listoftables

%\listoffigures

\include{preface.tr}

\include{abbreviations.tr}

\mainmatter

\part{Getting ready}


\chapter{Introduction}

\begin{abstract}
  In this chapter we explain the physical basis of optics and photochemistry.
\end{abstract}

\section{Radiation and molecules}


\chapter{Optics}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Photochemistry}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Software}\label{chap:software}

\begin{abstract}
  In this chapter we describe the software we used to run the code examples and typeset this handbook, and how to install it.
\end{abstract}

%%%%
\section{Task: }\label{sec:}

%%%%
\section{Introduction}\label{sec:}
\sloppy
The software used for typesetting this handbook and developing the \textsf{r4photobiology} suite is free and open source. All of it is available for the most common operating systems (Unix including OS X, Linux and its variants, and Windows). It is also possible to run everything described here on a Linux server running the server version of RStudio, and access the server through a web browser.

For just running the examples in the handbook, you would need only to have R installed. That would be enough as long as you also have a text editor available. This is possible, but does not give a very smooth workflow for data analyses which are beyond the very simple. The next stage is to use a text editor which integrates to some extent with R, but still this is not ideal, specially for writing packages or long scrips. Currently the best option is to use the integrated development environment (IDE) called `RStudio'. This is an editor, but tightly integrated with R. Its advantages are especially noticeable in the case of errors and `debugging'. We also use a \hologo{LaTeX} for typesetting. Is what we used for the first handbook (Aphalo2012), and what we routinely for reporting data analyses, and that PJA also uses for all `overhead' slides he writes for lectures. You, do not need to go this far to be able to profit from R and our suite, but the set up we will describe here, is what we currently use, it is by far the best one we have encountered in 18 years of using and teaching how to use R.

We will not give software installation instructions in this handbook, but will keep a web page with up-to-date instructions. In the following sections we briefly describe the different components of a full and comfortable working environment, but there many alternatives and the only piece that you cannot replace is R itself.

%%%%
\section{The different pieces}\label{sec:software:pieces}

\subsection{R}

You will not be able to profit from this handbook's `Cook Book' part, unless you have access to R. R (also called Gnu S) is both the name of a software system, and a dialect of the language S. The language S, although designed with data analysis and statistics in mind, is a computer language that is very powerful in its own way. It allows object oriented programming. Being based in a programming language, and being able to call and being called by programs and subroutine libraries written in several other programming languages, makes it easily extensible.

R has a well defined mechanism for ``add-ons'' called packages, that are kept in the computer where R is running, in disk folders that conform the library. There is a standard mechanism for installing packages, that works across operating systems (OSs) and computer architectures. There is also a Comprehensive R Archive Network (CRAN) where publicly released versions of packages are kept. Packages can be installed and updated from CRAN and similar repositories directly from within R.

If you are not familiar with R, please, go through the Appendixes \ref{chap:R:as:calc}, \ref{chap:R:scripts}
and \ref{chap:R:plotting}, before delving into our `Cook Book'.

\subsection{RStudio}

RStudio exists in two versions with identical user interface: a desktop version and a server version. The server version can be used remotely through a web browser. It can be for example run in the 'cloud', for example, as an AWS instance (Amazon Web Services) quite easily and cheaply, or on one's own server hardware.

\subsection{Version control: Git and Subversion}

Version control systems help with keeping track of the history of software development, data analysis, or even manuscript writing. They make it possible for several programmers, data analysts, authors and or editors to work on the same files in parallel and then merge their edits. They also allow easy transfer of whole `projects' between computers. Git is very popular, and Github and Bitbucket are popular hosts for repositories. Git itself is free software, and can be also run locally, or as one's own private server, either as an AWS instance or on other hosting service, or on your own hardware.

\subsection{C++ compiler}

Although R is an interpreted language, a few functions in our suite are written in C++ to achieve better performance. On OS X and Windows, the normal practice is to install binary packages, which are ready compiled. In other systems like Linux and Unix it is the normal practice to install source packages that are compiled at the time of installation.

\subsection{\LaTeX}

\hologo{LaTeX} is built on top of \hologo{TeX}. \hologo{TeX} code and features were `frozen' (only bugs are fixed) long ago. There are currently a few `improved' derivatives: \hologo{pdfTeX}, \hologo{XeTeX}, and \hologo{LuaTeX}. Currently the most popular \hologo{TeX} in western countries is pdftex which can directly output PDF files. \hologo{XeTeX} can handle text both written from left to right and right to left, even in the same document, and is the most popular \hologo{TeX} engine in China and other Asian countries.


\chapter{Photobiology R packages}

\begin{abstract}
  In this chapter we describe the suite of R packages for photobiological calculations `\textsf{r4photobiology}', and explain how to install them.
\end{abstract}

%%%%
\section{The suite}

The suite consists in several packages. The main package is \code{photobiology} which contains all the generally useful functions, including many used in the other, more specialized, packages (Table \ref{tab:suite}).

\begin{table}
\newcommand{\gblt}{\textcolor{green}{$\bullet$}}
\newcommand{\yblt}{\textcolor{yellow}{$\bullet$}}
\newcommand{\rblt}{\textcolor{red}{$\bullet$}}
\caption[Packages in the suite]{Packages in the \textsf{r4photobiology} suite. Packages not yet released are
highlighted with a red bullet \rblt, and those at `beta' stage with a yellow bullet \yblt, those relatively stable with a
green bullet \gblt.}\label{tab:suite}
\begin{small}
\begin{tabular}{c>{\ttshape}lll}
\toprule
 & Package           &  Type        & Contents \\
\midrule
\gblt & photobiology      &  funs + classes & basic functions, class definitions,\\
      &                   &                 & class methods and example data \\
\midrule
\gblt & photobiologyWavebands   &  definitions & quantification of radiation \\
\midrule
\gblt & photobiologySun   &  data        & spectral data for solar radiation \\
\gblt & photobiologyLamps &  data        & spectral data for lamps \\
\gblt & photobiologyLEDs  &  data        & spectral data for LEDs \\
\gblt & photobiologyFilters  &  data     & transmittance data for filters \\
\yblt & photobiologySensors  &  data     & response data for broadband sensors \\
\midrule
\yblt & photobiologyPhy  & funs + data & phytochromes \\
\yblt & photobiologyCry  & funs + data & cryptochromes \\
\rblt & photobiologyPhot & funs + data & phototropins \\
\rblt & photobiologyUVR8 & funs + data & UVR8 \\
\midrule
\gblt & photobiologygg  & functions       & extensions to package \code{ggplot2} \\
\midrule
\rblt & rTUV             & funs + data & TUV model interface \\
\gblt & rOmniDriver      & functions   & control of Ocean Optics spectrometers \\
\bottomrule
\end{tabular}
\end{small}
\end{table}

One of the main difficulties when working with spectral data is that one may need to operate on data sets measured at different wavelength values and steps sizes. The functions in the suite handle any mismatch by interpolation before applying operations or functions. Although by default functions expect spectral data on energy units, this is just a default that can be changed by setting the parameter \code{unit.in = "photon"}. Across all data sets and functions wavelength vectors have name \code{w.length}, spectral (energy) irradiance \code{s.e.irrad}, photon spectral irradiance \code{s.q.irrad}\footnote{\code{q} derives from `quantum'.}, absorbance ($\log_{10}$-based) \code{A}, transmittance (fraction of one) \code{Tfr}, transmittance (\%) \code{Tpc}, reflectance (fraction of one) \code{Rfr}, and reflectance (\%) \code{Rpc}.

Wavelengths should always be in nm, and when conversion between energy and photon based units takes place no scaling factor is used (an input in \wattnm yields an output in \molnm rather than \umolnm).

The suite is still under active development. Even those packages marked as `stable' are likely to acquire new functionality. By stability, we mean that we hope to be able to make most changes backwards compatible, in other words, we hope they will not break existing user code.

%%%%
\section{\lowercase{\code{r4photo}} repository}\label{sec:photoCRAN}
% \lowercase needed for page headers

I have created a small repository for the packages. This repository follows the CRAN folder structure, so now package installation can be done using just the normal R commands. This means that dependencies are installed automatically, and that automatic updates are possible. The build most suitable for the current system and R version is also picked automatically if available. It is normally recommended that you do installs and updates on a clean R session (just after starting R or RStudio).For easy installation and updates of packages, the r4photo repository can be added to the list of repositories that R knows about.

Whether you use RStudio or not it is possible to add the r4photo repository to the current session as follows, which will give you a menu of additional repositories to activate:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

If you know the indexes in the menu you can use this code, where ‘1’ and ‘6’ are the entries in the menu in the command above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{),}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Be careful not to issue this command more than once per R session, otherwise the list of repositories gets corrupted by having two repositories with the same name.

Easiest is to create a text file and name it `\code{.Rprofile}'. The commands above (and any others you would like to run at R start up) should be included, but with the addition that the package names for the functions need to be prepended. The minimum needed is.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{utils::}\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{),}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The \code{.Rprofile} file located in the current folder is sourced at R start up. It is also possible to have such a file affecting all of the user's R sessions, but its location is operating system dependent, it is in most cases the what the OS considers the current user's \textit{HOME} directory or folder (e.g. `My Documents' in recent versions of MS-Windows). If you are using RStudio, after setting up this file, installation and updating of the packages in the suite can take place exactly as for any other package archived at CRAN.

The commands and examples below can be used at the R prompt and in scripts whether RStudio is used or not.

After adding the repository to the session, it will appear in the menu when executing this command:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
and can be enabled and disabled.

In RStudio, after adding the r4photo repository as shown above, the photobiology packages can be installed and uninstalled through the normal RStudio menus and dialogues, and will listed after typing the first few characters of their names. For example when you type ‘photob’ in the packages field, all the packages with names starting with ‘photob’ will be listed.

They can be also installed at the R command prompt with the following command:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"photobiologyAll"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}


and updated with:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}


The added repository will persist only during the current R session. Adding it permanently requires editing the R configuration file, as discussed above. Take into consideration that .Rprofile is read by R itself, and will take effect whether you use RStudio or not. It is possible to have a user wide .Rprofile file, and a different one on those folders needing different settings. There many options that can be modified by means of commands in the .Rprofile file.

\section{How to install the packages}

The examples given in this page assume that ‘r4photo’ is not in the list of repositories known to the current R session. See the section \ref{sec:photoCRAN} on the r4photo repository for a better alternative to the approach given here. We mention these other commands because they may be useful in cases when the user does not have write access to his/hers home directory, or just wants to try the packages.

To install the latest version of one package (photobiology used as example) you just need to indicate the repository. However this simple command will only install the dependencies between the different photobiology packages.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
                 \hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

To update what is already installed, this command is enough (even if the packages have been installed manually before):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{(}\hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


The best way to install the packages is to specify both the r4photo repository and a normal CRAN repository, then all dependencies will be automatically installed. The package photobiolgyAll just loads and imports all the packages in the suite, except for photobiolygg. Because of this dependency all the packages are installed unless already installed by issuing this command.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"photobiologyAll"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{),}
         \hlkwc{repos} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                     \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                   \hlkwc{CRAN} \hlstd{=}
                     \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

This example also shows how one can use an array of package names (in this example all currently available “photobiology” packages) in the call to the function install.packages, this is useful if you want to install only a subset of the files, or if you want to make sure that any older install of the packages is overwritten:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{photobiology_packages} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
    \hlstr{"photobiologyWavebands"}\hlstd{,}
    \hlstr{"photobiologyCry"}\hlstd{,} \hlstr{"photobiologyPhy"}\hlstd{,}
    \hlstr{"photobiologyLamps"}\hlstd{,} \hlstr{"photobiologyLEDs"}\hlstd{,}
    \hlstr{"photobiologySun"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{,}
    \hlstr{"photobiologyFilters"}\hlstd{,}  \hlstr{"photobiologySensors"}\hlstd{)}

\hlkwd{install.packages}\hlstd{(photobiology_packages,}
         \hlkwc{repos} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                     \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                   \hlkwc{CRAN} \hlstd{=}
                     \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The commands above install all packages in the suite and all their dependencies from CRAN if needed. The following command will update all the packages currently installed (if new versions are available) and install any new dependencies.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{(}\hlkwc{repos} \hlstd{=}
                  \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                    \hlkwc{CRAN} \hlstd{=}
                      \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The instructions above should work under Windows as long as you have a supported version of R (3.0.0 or later) because I have built suitable binaries, under other OSs you may need to add type="source" unless this is already the default. We will try to build OS X binaries for Mac so that installation is easier. Meanwhile if installation fails try adding type="source" to the commands given above. For example the first one would become:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
                 \hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                 \hlkwc{type}\hlstd{=}\hlstr{"source"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


When using type=”source” you may need to install some dependencies like the splus2R package beforehand from CRAN if building it from sources fails.

\part{Cookbook}


\chapter{Radiation physics}\label{chap:physics}

\begin{abstract}
  In this chapter we explain how to code some optics and physics computations in R.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: methods}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: photobiology\\\#\# Loading required package: lubridate\\\#\# Loading required package: proto\\\#\# Loading required package: splus2R\\\#\# Loading required package: plyr\\\#\# \\\#\# Attaching package: 'plyr'\\\#\# \\\#\# The following object is masked from 'package:lubridate':\\\#\# \\\#\#\ \ \ \  here}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\end{alltt}
\end{kframe}
\end{knitrout}



%%%%
\section{Introduction}\label{sec:physics:intro}

%%%%
\section{Task: black body emission}\label{sec:physics:intro}

The emitted spectral radiance (\radiance[s]) is described by Planck's law of black body radiation at temperature $T$, measured in degrees Kelvin (K):%\index{Planck's law of black body radiation}\index{black body spectral radiance}
%
\begin{equation}
%\radiance[s](\lambda,T) = \frac{2hc^2}{\lambda^5}\cdot\frac{1}{\exp\left\{hc/k_BT\lambda\right\}-1} \label{equ_planck}
\radiance[s](\lambda,T) = \frac{2hc^2}{\lambda^5}\cdot\frac{1}{\mathrm{e}^{(hc/k_\mathrm{B}T\lambda)}-1} \label{equ_planck}
\end{equation}
%
with Boltzmann's constant $k_\mathrm{B}=1.381\times 10^{-23}$ \Unit{J\,K^{-1}}, Planck's constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond.

We can easily define an R function based on the equation above, which returns \Unit{W\,sr^{−1}\,m^{−3}}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{h} \hlkwb{<-} \hlnum{6.626e-34} \hlcom{# J s-1}
\hlstd{c} \hlkwb{<-} \hlnum{2.998e8} \hlcom{# m s-1}
\hlstd{kB} \hlkwb{<-} \hlnum{1.381e-23} \hlcom{# J K-1}
\hlstd{black_body_spectrum} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{w.length}\hlstd{,} \hlkwc{Tabs}\hlstd{) \{}
  \hlstd{w.length} \hlkwb{<-} \hlstd{w.length} \hlopt{*} \hlnum{1e-9} \hlcom{# nm -> m}
  \hlstd{((}\hlnum{2} \hlopt{*} \hlstd{h} \hlopt{*} \hlstd{c}\hlopt{^}\hlnum{2}\hlstd{)} \hlopt{/} \hlstd{w.length}\hlopt{^}\hlnum{5}\hlstd{)} \hlopt{*}
    \hlnum{1} \hlopt{/} \hlstd{(}\hlkwd{exp}\hlstd{((h} \hlopt{*} \hlstd{c} \hlopt{/} \hlstd{(kB} \hlopt{*} \hlstd{Tabs} \hlopt{*} \hlstd{w.length)))} \hlopt{-} \hlnum{1}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

We can use the function for calculating black body emission spectra for different temperatures:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlnum{500}\hlstd{,} \hlnum{5000}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.212e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

The function is vectorized:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{300}\hlstd{,}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{),} \hlnum{5000}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3.355e+12 8.759e+12 1.212e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlnum{500}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{4500}\hlstd{,}\hlnum{5000}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 6.388e+12 1.212e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

We aware that if two vectors are supplied, then the elements in each one are matched and recycled\footnote{Exercise: calculate each of the four values individually to work out how the two vectors are being used.}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{500}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{600}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{4500}\hlstd{,}\hlnum{5000}\hlstd{))} \hlcom{# tricky!}
\end{alltt}
\begin{verbatim}
## [1] 6.388e+12 1.212e+13 7.475e+12 1.278e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use the function defined above for plotting black body emission spectra for different temperatures. We use \code{ggplot2} and directly plot a function using \code{stat\_function}, using \code{args} to pass the additional argument giving the absolute temperature to be used. We plot three lines using three different temperatures (5600~K, 4500~K, and 3700~K):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{50}\hlstd{,}\hlnum{1500}\hlstd{)),} \hlkwd{aes}\hlstd{(x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{5600}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{4500}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"orange"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{3700}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{radiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{sr}\hlopt{^-}\hlnum{1}\hlopt{~}\hlstd{m}\hlopt{^-}\hlnum{3}\hlstd{)),}
       \hlkwc{x}\hlstd{=}\hlstr{"Wavelength (nm)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-23} 

}



\end{knitrout}


Wien's displacement law, gives the peak wavelength of the radiation emitted by a black body as a function of its absolute temperature.
%
\begin{equation}
\lambda_{max} \cdot T = 2.898 \times 10^6 \,\mathrm{nm\,K} \label{equ_wien}
\end{equation}
%
A function implementing this equation takes just a few lines of code:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{k.wein} \hlkwb{<-} \hlnum{2.8977721e6} \hlcom{# nm K}
\hlstd{black_body_peak_wl} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{Tabs}\hlstd{) \{}
  \hlstd{k.wein} \hlopt{/} \hlstd{Tabs}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

It can be used to plot the temperature dependence of the location of the wavelength at which radiance is at its maximum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=}\hlkwd{data.frame}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{2000}\hlstd{,}\hlnum{7000}\hlstd{)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=Tabs))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_peak_wl)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Temperature (K)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Wavelength at peak of emission (nm)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-25} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologygg)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Astronomy}\label{chap:astronomy}

\begin{abstract}
  In this chapter we explain how to code some astronomical computations in R.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(lubridate)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggmap)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:astro:intro}

This chapter deals with calculations that require times and/or dates as arguments. One could use R's built-in functions for POSIXct but package \code{lubridate} makes working with dates and times, much easier. Package \code{lubridate} defines functions for decoding dates represented as character strings, and for manipulating dates and doing calcualtions on dates. Each one of the different functions shown in the code chunk below can decode dates in different formats as long as the year, month and date order in the string agrees with the name of the function:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"20140320"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014-03-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"14-03-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014-3-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014/3/20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{dmy}\hlstd{(}\hlstr{"20032014"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{mdy}\hlstd{(}\hlstr{"03202014"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\end{kframe}
\end{knitrout}

For astronomical calculations we need as argument the geographical coordinates. It is, of course, possible to enter latitude and longitude values recorded with a GPS instrument or manually obtained from a map. However, when the location is searchable through Google Maps, it is also possible to obtain the coordinates by means of a query from within R using packages \code{RgoogleMaps}, or package \code{ggmap}, as done here. When inputing coordinate values manually, they should in degrees as numeric values (in other words the fractional part is given as part of floating point numberin degrees, and not as separate integers representing minutes and seconds of degree).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 24.94 60.17
\end{verbatim}
\begin{alltt}
\hlkwd{geocode}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki, Finland"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 25.02 60.23
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating the length of the photoperiod}\label{sec:astro:photoperiod}

In function \code{day\_night} from our \code{photobiology} package we use function \code{sun\_angles}, which is an edited version of function \code{sunAngle} from package \code{ode}, to calculate the altitude or elevation of the sun. We first find local solar noon by finding the maximal solar elevation, and then search for sunrise in the first half of the day and for sunset in the second half, defined based on the local solar noon. Sunset and sunrise are by default based on a solar elevation angle equal to zero. The argument \code{twilight} can be used to set the angle according to different conventions.

In the examples we use \code{geocode} to get the latitude and longitude of cities. \code{geocode} accepts any valid Google Maps search terms, including street addresses, and postal codes within cities. \code{day\_night} returns a list containing the times at sunrise, sunset and noon, and day- and night lengths. This first example is for Buenos Aires on two different dates, by use of the optional argument \code{tz} we request the results to be expressed in local time for Buenos Aires.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_BA} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Buenos Aires"}\hlstd{)}
\hlstd{geo_code_BA}
\end{alltt}
\begin{verbatim}
##      lon   lat
## 1 -58.38 -34.6
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-12-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_BA[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_BA[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"America/Argentina/Buenos_Aires"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-12-21 UTC"
## 
## $sunrise
## [1] "2013-12-21 05:42:00 ART"
## 
## $noon
## [1] "2013-12-21 12:51:46 ART"
## 
## $sunset
## [1] "2013-12-21 20:01:32 ART"
## 
## $daylength
## Time difference of 14.33 hours
## 
## $nightlength
## Time difference of 9.675 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-06-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_BA[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_BA[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"America/Argentina/Buenos_Aires"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-06-21 UTC"
## 
## $sunrise
## [1] "2013-06-21 08:04:57 ART"
## 
## $noon
## [1] "2013-06-21 12:55:32 ART"
## 
## $sunset
## [1] "2013-06-21 17:45:49 ART"
## 
## $daylength
## Time difference of 9.681 hours
## 
## $nightlength
## Time difference of 14.32 hours
\end{verbatim}
\end{kframe}
\end{knitrout}

We here repeat the same calculations for Munich on the same days ---note that the output for December is in "EET" time coordinates, and for June it is in "EEST", i.e.\ in `winter-' and `summer time' coordinates.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_Mu} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Munich"}\hlstd{)}
\hlstd{geo_code_Mu}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 11.58 48.14
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-12-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_Mu[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_Mu[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"Europe/Berlin"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-12-21 UTC"
## 
## $sunrise
## [1] "2013-12-21 08:07:27 CET"
## 
## $noon
## [1] "2013-12-21 12:11:49 CET"
## 
## $sunset
## [1] "2013-12-21 16:16:11 CET"
## 
## $daylength
## Time difference of 8.146 hours
## 
## $nightlength
## Time difference of 15.85 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-06-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_Mu[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_Mu[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"Europe/Berlin"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-06-21 UTC"
## 
## $sunrise
## [1] "2013-06-21 05:19:41 CEST"
## 
## $noon
## [1] "2013-06-21 13:15:29 CEST"
## 
## $sunset
## [1] "2013-06-21 21:11:16 CEST"
## 
## $daylength
## Time difference of 15.86 hours
## 
## $nightlength
## Time difference of 8.14 hours
\end{verbatim}
\end{kframe}
\end{knitrout}

As a final example, we calculate day length based on different definitions of twilight for Helsinki, at the equinox:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_He} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\hlstd{geo_code_He}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 24.94 60.17
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 07:08:45 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 19:16:23 EEST"
## 
## $daylength
## Time difference of 12.13 hours
## 
## $nightlength
## Time difference of 11.87 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"civil"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 07:57:16 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 18:28:02 EEST"
## 
## $daylength
## Time difference of 10.51 hours
## 
## $nightlength
## Time difference of 13.49 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"nautical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 08:47:20 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 17:38:05 EEST"
## 
## $daylength
## Time difference of 8.846 hours
## 
## $nightlength
## Time difference of 15.15 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"astronomical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 09:41:31 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 16:44:00 EEST"
## 
## $daylength
## Time difference of 7.041 hours
## 
## $nightlength
## Time difference of 16.96 hours
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Task: calculating the position of the sun}\label{sec:astro:position}

\code{sun\_angles} not only returns solar elevation, but all the angles defining the position of the sun. The time argument to \code{sun\_angles} is internally converted to UTC (universal time coordinates, which is equal to GMT) time zone, so time defined for any time zone is valid input. The time zone used for the output is by default that currently in use in the computer on which R is running, but we can easily specify the time coordinates used for the output with parameter \code{tz}, using any string accepted by package \code{lubridate}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_Jo} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Joensuu"}\hlstd{)}
\hlstd{geo_code_Jo}
\end{alltt}
\begin{verbatim}
##     lon  lat
## 1 29.76 62.6
\end{verbatim}
\begin{alltt}
\hlstd{my_time} \hlkwb{<-} \hlkwd{ymd_hms}\hlstd{(}\hlstr{"2014-05-29 18:00:00"}\hlstd{,} \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
\hlkwd{sun_angles}\hlstd{(my_time,}
         \hlkwc{lon} \hlstd{= geo_code_Jo[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_Jo[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $time
## [1] "2014-05-29 18:00:00 EEST"
## 
## $azimuth
## [1] 267.6
## 
## $elevation
## [1] 25.82
## 
## $diameter
## [1] 0.526
## 
## $distance
## [1] 1.014
\end{verbatim}
\end{kframe}
\end{knitrout}

We can calculate the current position of the sun, in this case giving the position of the sun in the sky of Joensuu when this .PDF file was generated.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sun_angles}\hlstd{(}\hlkwd{now}\hlstd{(),}
         \hlkwc{lon} \hlstd{= geo_code_Jo[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_Jo[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $time
## [1] "2014-08-17 10:01:55 EEST"
## 
## $azimuth
## [1] 125.4
## 
## $elevation
## [1] 31.21
## 
## $diameter
## [1] 0.5266
## 
## $distance
## [1] 1.012
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Task: plotting sun elevation through a day}

Function \code{sun\_angles} described above is vectorized, so it is very easy to calculate the position of the sun throughout a day at a given location on Earth. The example here uses sun only elevation, plotted for Helsinki through the course of 23 June 2014. We first a vector of times, using \code{seq} which can not only be used with numbers, but also with dates. Note that \code{by} is specified as a string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{opts_chunk}\hlopt{$}\hlkwd{set}\hlstd{(opts_fig_wide)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hours} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-06-23"}\hlstd{,} \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{),}
             \hlkwc{by}\hlstd{=}\hlstr{"10 min"}\hlstd{,}
             \hlkwc{length}\hlstd{=}\hlnum{24} \hlopt{*} \hlnum{6}\hlstd{)}
\hlstd{elevations} \hlkwb{<-} \hlkwd{sun_angles}\hlstd{(hours,}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}\hlopt{$}\hlstd{elevation}
\hlstd{sun_elev_hel} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{time_eet} \hlstd{= hours,}
                            \hlkwc{elevation} \hlstd{= elevations,}
                            \hlkwc{location} \hlstd{=} \hlstr{"Helsinki"}\hlstd{,}
                            \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
                           \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\end{kframe}
\end{knitrout}

We also create a small data frame with data for plotting and labeling the different twilight conventions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{twilight} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlopt{-}\hlnum{6}\hlstd{,} \hlopt{-}\hlnum{12}\hlstd{,} \hlopt{-}\hlnum{18}\hlstd{),}
             \hlkwc{label} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Horizon"}\hlstd{,} \hlstr{"Civil twilight"}\hlstd{,}
                       \hlstr{"Nautical twilight"}\hlstd{,}
                       \hlstr{"Astronomical twilight"}\hlstd{),}
             \hlkwc{time} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{ymd_hms}\hlstd{(}\hlstr{"2014-06-23 12:00:00"}\hlstd{,}
                                \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{),}
                        \hlnum{4}\hlstd{) )}
\end{alltt}
\end{kframe}
\end{knitrout}

We draw a plot using the data frames created above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(sun_elev_hel,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= time_eet,} \hlkwc{y} \hlstd{= elevation))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_hline}\hlstd{(}\hlkwc{data}\hlstd{=twilight,}
             \hlkwd{aes}\hlstd{(}\hlkwc{yintercept} \hlstd{= angle,} \hlkwc{linetype}\hlstd{=}\hlkwd{factor}\hlstd{(label)))} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{x}\hlstd{=twilight}\hlopt{$}\hlstd{time,} \hlkwc{y}\hlstd{=twilight}\hlopt{$}\hlstd{angle,}
           \hlkwc{label}\hlstd{=twilight}\hlopt{$}\hlstd{label,} \hlkwc{vjust}\hlstd{=}\hlopt{-}\hlnum{0.4}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=} \hlstr{"Solar elevation at Helsinki (degrees)"}\hlstd{,}
       \hlkwc{x} \hlstd{=} \hlstr{"Time EEST"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-astro-8} 

}



\end{knitrout}

\section{Task: plotting day length through the year}

For this we first need to generate a sequence of dates. We use \code{seq} as in the previous section, but instead of supplying a length as argument we supply an ending time. Instead of giving \code{by} in minutes as above, we now use days:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{days} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-01-01"}\hlstd{),} \hlkwc{to}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-12-31"}\hlstd{),}
            \hlkwc{by}\hlstd{=}\hlstr{"3 day"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

To calculate the length of each day, we need to use an explicit loop as function \code{day\_night} is not vectorized. We repeat the calculations for three locations at different latitudes, then row bind the data frames into a single data frame. Each individual data frame contains information to identify the sites:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{len_days} \hlkwb{<-} \hlkwd{length}\hlstd{(days)}
\hlstd{photoperiods} \hlkwb{<-} \hlkwd{numeric}\hlstd{(len_days)}
\hlstd{geo_code_He} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_hel} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Helsinki"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\hlstd{geo_code_Iv} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Ivalo"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_Iv[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_Iv[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_ivalo} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Ivalo"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_Iv[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_Iv[[}\hlstr{"lat"}\hlstd{]])}
\hlstd{geo_code_At} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Athens, Greece"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_At[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_At[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_athens} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Athens"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_At[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_At[[}\hlstr{"lat"}\hlstd{]])}

\hlstd{daylengths} \hlkwb{<-} \hlkwd{rbind}\hlstd{(daylengths_hel,}
                    \hlstd{daylengths_ivalo,}
                    \hlstd{daylengths_athens)}
\end{alltt}
\end{kframe}
\end{knitrout}

Once we have the data available, plotting is simple:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(daylengths,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= day,} \hlkwc{y} \hlstd{= daylength,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(location)))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{6}\hlstd{,}\hlnum{12}\hlstd{,}\hlnum{18}\hlstd{,}\hlnum{24}\hlstd{),} \hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{24}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Date"}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"Daylength (h)"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"Location"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-astro-11} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{lubridate)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggmap)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Basic operations on spectra}\label{chap:base}

\begin{abstract}
  In this chapter we describe the use of a few basic functions, which can be useful when no predefined functions are available for a given operation.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: lubridate\\\#\# \\\#\# Attaching package: 'lubridate'\\\#\# \\\#\# The following object is masked from 'package:plyr':\\\#\# \\\#\#\ \ \ \  here}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:spct:objects}

\subsection{How are example spectra stored?}

The suite uses to some extent object-oriented programming. Objects are implemented using ``S3'' classes. For spectra the classes are a specialization of data.table which are in turn a specialization of data.frame. This means that they are compatible with functions that operate on these classes.

\sloppy
The suite defines a ``generic.spct'' class, from which two specialized classes, ``filter.spct'', ``reflector.spct'' and ``source.spct'' are derived. Having this class structure allows us to create special methods and operators, which use the same names than the generic ones but take into account the special properties of spectra. Each spectrum object can hold only one spectrum.

Objects of class ``source.spct'' have two mandatory components \code{w.length}, and \code{s.e.irrad}, and an optional one, \code{s.q.irrad}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, \wattnm for \code{s.e.irrad}, and \molnm for \code{s.q.irrad}. Objects have a ``comment'' attribute with a textual description.

Objects of class ``filter.spct'' have two mandatory components \code{w.length}, and \code{Tfr} and two optional components,\code{Tpc} and \code{A}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Tfr}, and \% for \code{Tpc}. Absorbance \code{A} values are expected to be expressed based on $\log_{10}$. Objects have a ``comment'' attribute with a textual description.

Objects of class ``reflector.spct'' have two mandatory components \code{w.length}, and \code{Rfr} and one optional components,\code{Rpc}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Rfr}, and \% for \code{Rpc}. Objects have a ``comment'' attribute with a textual description.

\subsection{How can the user create spectra from his own data}

If the data is already stored in a data frame or data table, or even a list, and if the components have one of the recognized ``standard'' names, specific \code{setGenericSpct}, \code{setSourceSpct}, \code{setFilterSpct}, \code{setReflectorSpct} commands can be used to change the class attribute and check that the object is valid. These functions have the same semantics as \code{setDT} and \code{setDF} from package \code{data.table}, they modify their argument directly---the argument is passed by \emph{reference} instead of by \emph{copy} as is usual in R. As \code{sun.data} is part of the package, we need to make a copy before modifying it, with our own data frames or data tables this step is not need.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlstd{sun.data}
\hlkwd{setSourceSpct}\hlstd{(my_sun.spct)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can query the class of an object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(my_sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{is}\hlstd{(my_sun.spct,} \hlstr{"source.spct"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Table \ref{tab:obj:components} lists the different `names' understood by these functions, and the required and optional components of the different object classes.

\begin{table}
\caption{Names of spectral object components, and the additional names recognized during automatic spectral object creation, and the units of expression.}\label{tab:obj:components}
\begin{center}
\begin{tabular}{lllll}
\toprule
Class    & required & optional & recognized & units\\
\midrule
generic.spct & w.length & --- & wl, wavelength & nm\\
\midrule
source.spct & w.length & --- & wl, wavelength & nm\\
            & s.e.irrad & --- & irradiance & \wattnm\\
            & ---       & s.q.irrad & --- & \molnm\\
\midrule
filter.spct & w.length & --- & wl, wavelength & nm \\
            & Tfr      & --- & --- & $x/1$  \\
            & ---      & Tpc    & transmittance & \% \\
            & ---      & A      & absorbance & a.u. $\log_{10}$-based\\
\midrule
reflector.spct & w.length & --- & wl, wavelength \\
            & Rfr      & --- & --- & $x/1$  \\
            & ---      & Rpc    & reflectance & \% \\
\midrule
response.spct & w.length & --- & wl, wavelength & nm\\
            & response   & --- & response & arbitrary u.\\
%            & ---       & resp.actual & --- & absolute u.\\
\midrule
chroma.spct & w.length & --- & wl, wavelength & nm\\
            & x, y, z  & ---    & X, Y, Z & relative u.\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{What operators are available for operations between spectra?}

All operations with spectral objects affect only the required components listed in Table \ref{tab:obj:components}, all optional components are deleted, while unrecognized components are left alone. There will be seldom need to add numerical components, and the user should take into account that the paradigm of the suite is that each spectrum is stored as a separate object. However, it is allowed, and possibly useful to have factors as components with levels identifying different bands, or color vectors with RGB values. Ancilary information information useful for presentation and plotting might sometimes be useful.

Several operators are defined for spectral objects. Using operators is an easy and familiar way of doing calculations, but operators are rather inflexible (they can take at most two arguments, the operands) and performance could be slower than with functions with additional parameters that allow optimizing the algorithm. The operators are defined so that an operation between two \code{filter.spct} objects yields another \code{filter.spct} object, an operation between two \code{reflector.spct} yields a \code{reflector.spct} object, and operations between a \code{filter.spct} object and a \code{source.spct}, between a \code{reflector.spct} and a \code{source.spct}, or between two \code{source.spct} objects yields a \code{source.spct} object. The object returned contains data only for the overlapping region of wavelengths. The objects do NOT need to have values at the same wavelengths, as interpolation is handled transparently. All four basic maths operations are supported with any combination of spectra, and the user is responsible for deciding which calculations make sense and which not. Operations can be concatenated and combined. The unary negation operator is also implemented.

\subsection{What operators are available for operations between spectra and numeric vectors?}

The same four basic math operators plus power (`\verb|^|') are defined for the case when the first term or factor is a spectrum and the second one a numeric vector, possibly of length one. Recycling rules apply. These operations do not alter \code{w.length}, just the other \textit{required} components such as spectral irradiance and transmittance. The optional components are deleted as they can be recalculated if needed. Unrecognized `user' components are left unchanged.

\subsection{What math functions are available for operations on spectra?}

Logarithms (\code{log, log10}), square root (\code{sqrt}) and exponentiation (\code{exp}) are defined for spectra. These functions are not applied on \code{w.length}, but instead to the other mandatory component \code{s.e.irrad}, \code{Rfr} or \code{Tfr}. Any optional numeric components are discarded. (Other user-supplied components should remain unchanged, but this needs further checking!)

\subsection{What `summary' functions are available for spectra?}

The R functions \code{summary, print} work in their R-defined form, however, there are special versions of \code{range, min, max} that when applied to spectra return values corresponding to wavelengths, two generic functions defined in the suite give additional summaries of spectra \code{spread, midpoint}.

\subsection{Examples}

Package \code{phobiologyFilters} makes available many different filter spectra, from which we choose Schott filter GG400. Package \code{photobiology} makes available one example solar spectrum. Using these data we will simulate the filtered solar spectrum.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct}
\hlstd{filtered_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.610e-11
##   2:      294 6.142e-11
##   3:      295 2.176e-10
##   4:      296 6.780e-10
##   5:      297 1.533e-09
##  ---                   
## 504:      796 3.958e-01
## 505:      797 4.017e-01
## 506:      798 4.109e-01
## 507:      799 4.060e-01
## 508:      800 3.947e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

The GG440 data is for internal transmittance, consequently the results above would be close to the truth only for filters treated with an anti-reflexion multicoating. Let's assume a filter with 9\% reflectance across all wavelengths (a coarse approximation for uncoated glass):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_uncoated_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct} \hlopt{*} \hlstd{(}\hlnum{100} \hlopt{-} \hlnum{9}\hlstd{)} \hlopt{/} \hlnum{100}
\hlstd{filtered_uncoated_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.375e-11
##   2:      294 5.590e-11
##   3:      295 1.980e-10
##   4:      296 6.170e-10
##   5:      297 1.395e-09
##  ---                   
## 504:      796 3.602e-01
## 505:      797 3.655e-01
## 506:      798 3.739e-01
## 507:      799 3.695e-01
## 508:      800 3.592e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

Calculations related to filters will be explained in detail in chapter \ref{chap:filters}. This is just an example of how the operators work, even when, as in this example, the wavelength values do not coincide bertween the two spectra.

%%%%
\section{Task: uniform scaling of a spectrum}\label{sec:base:scale}

As noted above operators are available for \code{generic.scpt}, \code{source.spct}, \code{filter.spct} and \code{reflector.spct} objects, and `recycling' takes places when needed:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{sun.spct} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 5.219e-06
##   2:      294 1.228e-05
##   3:      295 4.352e-05
##   4:      296 1.356e-04
##   5:      297 3.067e-04
##  ---                   
## 504:      796 8.161e-01
## 505:      797 8.282e-01
## 506:      798 8.473e-01
## 507:      799 8.372e-01
## 508:      800 8.138e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, but when operating between a spectrum an a numeric value the spectrum should be the first term or factor. If an operation on a ``source.spct'' would yield different values for data on energy and photon basis, only the value based on energy data is returned in \code{s.e.irrad} and \code{s.q.irrad} is set to NA.

%%%%
\section{Task: simple operations between two spectra}\label{sec:base:simple:opper}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{ug1.spct} \hlopt{*} \hlstd{sun.spct}
\hlstd{filtered_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.286e-07
##   2:      294 6.192e-07
##   3:      295 2.481e-06
##   4:      296 8.624e-06
##   5:      297 2.153e-05
##  ---                   
## 504:      796 1.069e-01
## 505:      797 1.073e-01
## 506:      798 1.084e-01
## 507:      799 1.059e-01
## 508:      800 1.017e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, and they can be combined into equations.

%%%%
\section{Task: arithmetic operations within one spectrum}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can simply use the built in R mat operators on vectors (e.g.\ when only individual vectors are available, or a data frame). These operators are vectorized, which means that an addition between two vectors adds the elements at each position. A non-nonsensical example follows using R syntax on a data frame, returning a vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.data, s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length)}
\end{alltt}
\end{kframe}
\end{knitrout}

Using data table syntax on a data table or spectral object, returning a vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlstd{sun.dt[ , s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length]}
\end{alltt}
\end{kframe}
\end{knitrout}

Using data table syntax, adding the result to the \code{data.table} object, or a \code{\_\_\_.spct} object:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# run}
\hlstd{my_sun.dt} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.dt)}
\hlstd{my_sun.dt[ , result} \hlkwb{:=} \hlstd{s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length]}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad    result
##   1:      293 2.610e-06 6.392e-12 2.324e-14
##   2:      294 6.142e-06 1.510e-11 1.283e-13
##   3:      295 2.176e-05 5.366e-11 1.605e-12
##   4:      296 6.780e-05 1.678e-10 1.553e-11
##   5:      297 1.533e-04 3.807e-10 7.918e-11
##  ---                                       
## 504:      796 4.081e-01 2.715e-06 2.092e-04
## 505:      797 4.141e-01 2.759e-06 2.152e-04
## 506:      798 4.236e-01 2.826e-06 2.249e-04
## 507:      799 4.186e-01 2.796e-06 2.193e-04
## 508:      800 4.069e-01 2.721e-06 2.070e-04
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Task: other operations between two spectra}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can simply use the built in R math operators. These operators are vectorized, which means that an addition between two vectors adds the elements at the same index position in the two vectors with data, in this case for two different spectra. So, they do not differ from the examples in the previous section for normal R syntax. Data table syntax is no longer so convenient in this case.

In contrast to the previous case, operations using built-in R operators cannot be done if the wavelengths in two spectral data sets are not matched. In this situation is when functions and operators defined in package \code{photobiology} come to the rescue by transparently making the two operand spectra compatible by interpolation. The result they return includes all the individual wavelength values (the set union of the wavelengths from the two spectra in the region where they overlap). The functions are \code{sum\_spectra}, \code{subt\_spectra}, \code{prod\_spectra}, \code{div\_spectra}, and \code{oper\_spectra}. Here is a very simple hypothetical example:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{out1.dt} \hlkwb{<-} \hlkwd{sum_spectra}\hlstd{(spc1}\hlopt{$}\hlstd{w.length, spc2}\hlopt{$}\hlstd{w.length,}
                       \hlstd{spc1}\hlopt{$}\hlstd{s.e.irrad, spc2}\hlopt{$}\hlstd{s.e.irrad)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can achieve the same result, with simpler syntax, using spectral objects and the corresponding operators. The actual computations are done in both cases by the same code, but the example below adds some ``syntactic sugar'' to make the script code more readable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{out2.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{+} \hlstd{sun.spct}
\hlstd{out3.spct} \hlkwb{<-} \hlkwd{e2q}\hlstd{(sun.spct} \hlopt{+} \hlstd{sun.spct)}
\hlstd{out3.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 5.219e-06 1.278e-11
##   2:      294 1.228e-05 3.019e-11
##   3:      295 4.352e-05 1.073e-10
##   4:      296 1.356e-04 3.355e-10
##   5:      297 3.067e-04 7.614e-10
##  ---                             
## 504:      796 8.161e-01 5.430e-06
## 505:      797 8.282e-01 5.518e-06
## 506:      798 8.473e-01 5.652e-06
## 507:      799 8.372e-01 5.591e-06
## 508:      800 8.138e-01 5.442e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

In both cases only spectral energy irradiance is calculated during the summing operation, while in the second example, it is simple to convert the returned spectral energy irradiance values into spectral photon irradiance. \code{out1.data} is a "data.table", while the second will be a spectrum of a class dependent on the classes of \code{spc1} and \code{spc2}. Obviously, the second calculation will be slower, but in most cases unnoticeable so\footnote{The reason behind keeping \code{e2q} as a separately called function is that otherwise calculations would be slowed-down by doing the conversion when it is not needed, either at intermediate steps in the calculation, or when the user has no use for the result}.

The function \code{oper\_spectra} takes the operator to use as an argument, and this abstraction both simplifies the package code, and also makes it easy for users to add other operators if needed:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{out.data} \hlkwb{<-} \hlkwd{oper_spectra}\hlstd{(spc1}\hlopt{$}\hlstd{w.length, spc2}\hlopt{$}\hlstd{w.length,}
                         \hlstd{spc1}\hlopt{$}\hlstd{s.e.irrad, spc2}\hlopt{$}\hlstd{s.e.irrad,}
                         \hlkwc{bin.oper}\hlstd{=`^`)}
\end{alltt}
\end{kframe}
\end{knitrout}

and yields one spectrum to a power of a second one. Such additional functions are not predefined, as I cannot think of any use for them. \code{oper\_spectra} is used internally to define the functions for the four basic maths operators, and the corresponding operators.

\section{Task: trimming a spectrum}\label{sec:base:trim}

This is basically a subsetting operation, but our functions operate only based on wavelengths, while R \code{subset} is more general. On the other hand, our functions \code{trim\_spct} and \code{trim\_tails} add a few `bells and whistles'. The trimming is based on wavelengths and by default the cut points are inserted by interpolation, so that the spectrum returned includes the limits given as arguments. In addition, by default the trimming is done by deleting both spectral irradiance and wavelength values outside the range delimited by the limits (just like \code{subset} does), but through parameter \code{fill} the values outside the limits can be replaced by any value desired (most commonly \code{NA} or 0.) It is possible to supply only one, or both of \code{low.limit} and \code{high.limit}, depending on the desired trimming, or use a \code{waveband} definition. If the limits are outside the original data set, then the output spectrum is expanded and the tails filled with the value given as argument for \code{fill}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwd{UV}\hlstd{())}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Not trimming short end as low.limit is outside spectral data range.}}\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 104:      396 4.055e-01 1.342e-06
## 105:      397 2.542e-01 8.435e-07
## 106:      398 5.036e-01 1.675e-06
## 107:      399 5.861e-01 1.955e-06
## 108:      400 6.081e-01 2.033e-06
\end{verbatim}
\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwd{UV}\hlstd{(),} \hlkwc{fill}\hlstd{=}\hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      100         0         0
##   2:      101         0         0
##   3:      102         0         0
##   4:      103         0         0
##   5:      104         0         0
##  ---                             
## 698:      796         0         0
## 699:      797         0         0
## 700:      798         0         0
## 701:      799         0         0
## 702:      800         0         0
\end{verbatim}
\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwc{low.limit}\hlstd{=}\hlnum{400}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      400    0.6081 2.033e-06
##   2:      401    0.6262 2.099e-06
##   3:      402    0.6497 2.183e-06
##   4:      403    0.6207 2.091e-06
##   5:      404    0.6370 2.151e-06
##  ---                             
## 397:      796    0.4081 2.715e-06
## 398:      797    0.4141 2.759e-06
## 399:      798    0.4236 2.826e-06
## 400:      799    0.4186 2.796e-06
## 401:      800    0.4069 2.721e-06
\end{verbatim}
\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwc{low.limit}\hlstd{=}\hlnum{250}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      250    0.0000 0.000e+00
##   2:      251    0.0000 0.000e+00
##   3:      252    0.0000 0.000e+00
##   4:      253    0.0000 0.000e+00
##   5:      254    0.0000 0.000e+00
##  ---                             
## 547:      796    0.4081 2.715e-06
## 548:      797    0.4141 2.759e-06
## 549:      798    0.4236 2.826e-06
## 550:      799    0.4186 2.796e-06
## 551:      800    0.4069 2.721e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{trim\_tails} can be used for trimming spectra when data is available as vectors. We here present different examples for both functions, we encourage readers to try to reproduce all examples using both functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlkwa{NULL}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{NA}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

If the limits are outside the range of the input spectral data, and \code{fill} is set to a value other than \code{NULL} the output is expanded up to the limits and filled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{NA}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Task: conversion from energy to photon base}\label{sec:base:e2q}

The energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ_energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ_energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ_energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ_molenergy}
\label{eq:energy:mol:photons}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ_energy} while \code{as\_quantum\_mol} uses equation \ref{equ_molenergy}. To obtain \umol we multiply by $10^6$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as_quantum_mol}\hlstd{(}\hlnum{550}\hlstd{,} \hlnum{200}\hlstd{)} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## [1] 919.5
\end{verbatim}
\end{kframe}
\end{knitrout}

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorized, so they can be applied to whole spectra (when data are available as vectors), to convert \wattnm to \molnm:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(sun.data}\hlopt{$}\hlstd{s.e.irrad,} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 2.610e-06 6.142e-06 2.176e-05 6.780e-05
##  [5] 1.533e-04 3.670e-04 7.845e-04 1.265e-03
##  [9] 2.624e-03 3.923e-03
\end{verbatim}
\begin{alltt}
\hlstd{s.q.irrad} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,}
                  \hlkwd{as_quantum_mol}\hlstd{(w.length, s.e.irrad))}
\hlkwd{head}\hlstd{(s.q.irrad,} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 6.392e-12 1.510e-11 5.366e-11 1.678e-10
##  [5] 3.807e-10 9.141e-10 1.961e-09 3.171e-09
##  [9] 6.602e-09 9.903e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

Once again, easiest is to use spectral objects. The default is to add \code{s.q.irrad} to the source spectrum, unless it is already present in the object in which case values are not recalculated.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{e2q}\hlstd{(my_sun.spct)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{e2q} has a parameter \code{action}, with default \code{"add"}. Another valid argument value is \code{"replace"}, but it should be used with extreme care, as the returned object, is no longer a \code{source.spct} object and is not compatible with all operators and functions defined for \code{source.spct} objects.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{e2q}\hlstd{(my_sun.spct,} \hlstr{"replace"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.q.irrad
##   1:      293 6.392e-12
##   2:      294 1.510e-11
##   3:      295 5.366e-11
##   4:      296 1.678e-10
##   5:      297 3.807e-10
##  ---                   
## 504:      796 2.715e-06
## 505:      797 2.759e-06
## 506:      798 2.826e-06
## 507:      799 2.796e-06
## 508:      800 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Task: conversion from photon to energy base}\label{sec:base:q2e}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

In \cite{aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ_energy} and \ref{equ_molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output from \code{as\_energy} is expressed in \jmole we multiply the result by $10^{-3}$ to obtain \kjmole:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as_energy}\hlstd{(}\hlnum{600}\hlstd{,} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{1e-3}
\end{alltt}
\begin{verbatim}
## [1] 199.4
\end{verbatim}
\begin{alltt}
\hlkwd{as_energy}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{1e-3}
\end{alltt}
\begin{verbatim}
## [1] 398.8
\end{verbatim}
\end{kframe}
\end{knitrout}

Because of vectorization we can also operate on a whole spectrum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{s.e.irrad} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,} \hlkwd{as_energy}\hlstd{(w.length, s.q.irrad))}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \code{q2e} is the reverse of \code{e2q}, it is rarely needed in user code and \code{source.spct} objects almost always contain \code{s.e.irrad}. It can also be used as a roundabout way of removing a \code{s.q.irrad} column, which cloud be usefull when some objects may be missing spectral energy itrradiance data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{q2e}\hlstd{(my_sun.spct,} \hlstr{"replace"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.610e-06
##   2:      294 6.142e-06
##   3:      295 2.176e-05
##   4:      296 6.780e-05
##   5:      297 1.533e-04
##  ---                   
## 504:      796 4.081e-01
## 505:      797 4.141e-01
## 506:      798 4.236e-01
## 507:      799 4.186e-01
## 508:      800 4.069e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

Otherwise it feels more natural to use the following data.table syntax:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_sun.spct[ , s.q.irrad} \hlkwb{:=} \hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.610e-06
##   2:      294 6.142e-06
##   3:      295 2.176e-05
##   4:      296 6.780e-05
##   5:      297 1.533e-04
##  ---                   
## 504:      796 4.081e-01
## 505:      797 4.141e-01
## 506:      798 4.236e-01
## 507:      799 4.186e-01
## 508:      800 4.069e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

As we have seen above by default \code{q2e} and \code{e2q} return a modified copy of the spectrum as a new object. This is safe, but inefficient in use of memory and computing resources. We first copy the data to a new object, and delete the \code{s.e.irrad} variable, so that we can test the use of the functions by reference.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:      293 2.610e-06 6.392e-12
##   2:      294 6.142e-06 1.510e-11
##   3:      295 2.176e-05 5.366e-11
##   4:      296 6.780e-05 1.678e-10
##   5:      297 1.533e-04 3.807e-10
##  ---                             
## 504:      796 4.081e-01 2.715e-06
## 505:      797 4.141e-01 2.759e-06
## 506:      798 4.236e-01 2.826e-06
## 507:      799 4.186e-01 2.796e-06
## 508:      800 4.069e-01 2.721e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_sun.spct[ , s.e.irrad} \hlkwb{:=} \hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length s.q.irrad
##   1:      293 6.392e-12
##   2:      294 1.510e-11
##   3:      295 5.366e-11
##   4:      296 1.678e-10
##   5:      297 3.807e-10
##  ---                   
## 504:      796 2.715e-06
## 505:      797 2.759e-06
## 506:      798 2.826e-06
## 507:      799 2.796e-06
## 508:      800 2.721e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

When parameter \code{byref} is given \code{TRUE} as argument the original spectrum is modified.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q2e}\hlstd{(my_sun.spct,} \hlkwc{byref}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.q.irrad s.e.irrad
##   1:      293 6.392e-12 2.610e-06
##   2:      294 1.510e-11 6.142e-06
##   3:      295 5.366e-11 2.176e-05
##   4:      296 1.678e-10 6.780e-05
##   5:      297 3.807e-10 1.533e-04
##  ---                             
## 504:      796 2.715e-06 4.081e-01
## 505:      797 2.759e-06 4.141e-01
## 506:      798 2.826e-06 4.236e-01
## 507:      799 2.796e-06 4.186e-01
## 508:      800 2.721e-06 4.069e-01
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.q.irrad s.e.irrad
##   1:      293 6.392e-12 2.610e-06
##   2:      294 1.510e-11 6.142e-06
##   3:      295 5.366e-11 2.176e-05
##   4:      296 1.678e-10 6.780e-05
##   5:      297 3.807e-10 1.533e-04
##  ---                             
## 504:      796 2.715e-06 4.081e-01
## 505:      797 2.759e-06 4.141e-01
## 506:      798 2.826e-06 4.236e-01
## 507:      799 2.796e-06 4.186e-01
## 508:      800 2.721e-06 4.069e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Task: interpolating a spectrum}\label{sec:base:interpol}

Functions \code{interpolate\_spct} and \code{interpolate\_spectrum} allow interpolation to different wavelength values. \code{interpolate\_spectrum} is used internally, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible in the data analysis.

In this example we generate interpolated data for the range 280~nm to 300~nm at 1~nm steps, by default output values outside the wavelength range of the input are set to \code{NA}s unless a different argument is provided for parameter \code{fill}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwd{seq}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{300}\hlstd{,} \hlkwc{by}\hlstd{=}\hlnum{0.1}\hlstd{))}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:    290.0        NA        NA
##   2:    290.1        NA        NA
##   3:    290.2        NA        NA
##   4:    290.3        NA        NA
##   5:    290.4        NA        NA
##  ---                             
##  97:    299.6  0.001073 2.687e-09
##  98:    299.7  0.001121 2.808e-09
##  99:    299.8  0.001169 2.929e-09
## 100:    299.9  0.001217 3.050e-09
## 101:    300.0  0.001265 3.171e-09
\end{verbatim}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwd{seq}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{300}\hlstd{,} \hlkwc{by}\hlstd{=}\hlnum{0.1}\hlstd{),} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad
##   1:    290.0  0.000000 0.000e+00
##   2:    290.1  0.000000 0.000e+00
##   3:    290.2  0.000000 0.000e+00
##   4:    290.3  0.000000 0.000e+00
##   5:    290.4  0.000000 0.000e+00
##  ---                             
##  97:    299.6  0.001073 2.687e-09
##  98:    299.7  0.001121 2.808e-09
##  99:    299.8  0.001169 2.929e-09
## 100:    299.9  0.001217 3.050e-09
## 101:    300.0  0.001265 3.171e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{interpolate\_spct} takes any \code{\_\_.spct} object, and returns an object of the same type as its imput. It can be used to interpolate source spectra as well as transmittance, reflectance, response, and even generic spectra.

\code{interpolate\_spectrum} takes numeric vectors as arguments, but is otherwise functionally equivalent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.dt,}
     \hlkwd{interpolate_spectrum}\hlstd{(w.length, s.e.irrad,} \hlnum{290}\hlopt{:}\hlnum{300}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1]        NA        NA        NA 2.610e-06
##  [5] 6.142e-06 2.176e-05 6.780e-05 1.533e-04
##  [9] 3.670e-04 7.845e-04 1.265e-03
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.dt,}
     \hlkwd{interpolate_spectrum}\hlstd{(w.length, s.e.irrad,} \hlnum{290}\hlopt{:}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] 0.000e+00 0.000e+00 0.000e+00 2.610e-06
##  [5] 6.142e-06 2.176e-05 6.780e-05 1.533e-04
##  [9] 3.670e-04 7.845e-04 1.265e-03
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{framed}
These functions, in their current implementation, always return
interpolated values, even when the density of wavelengths in the output is less than that in the input.
A future version of the package will include a \code{smooth\_spectrum} function, and possibly a \code{remap\_w.length} function that will automatically choose between interpolation and smoothing/averaging as needed.
\end{framed}

\section{Internal-use functions}\label{sec:base:internal}

The generic function \code{check} can be used on any type of \code{.spct} object, and depending on its types checks that the required components are present. If they are missing they are added. If it is possible to calculate the missing values from other optional components, they are calculated, otherwise they are filled with \code{NA}. It is used internally during the creation of spectral objects.

The function \code{check\_spectrum} may need to be called by the user if he/she disables automatic sanity checking to increase calculation speed. The family of functions for calculating multipliers are used internally by the package.

The function \code{insert\_hinges} is used internally to insert individual interpolated values to the spectra when needed to reduce errors in calculations.

The function \code{integrate\_irradiance} is used internally for integrating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible, or never. This function makes it possible to work with spectral data on the original pixel wavelengths.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyLEDs)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Unweighted irradiance}\label{chap:uw:irrad}

\begin{abstract}
  In this chapter we explain how to calculate unweighted energy and photon irradiances from spectral irradiance.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:uw:intro}


%%%%
\section{Task: (energy) irradiance from spectral irradiance}\label{sec:uw:e2e}

The task to be completed is to calculate the (energy) irradiance ($\irr$) in \watt from spectral (energy) irradiance ($\sirr$) in \wattnm and the corresponding wavelengths ($\lambda$) in nm.

\begin{equation}
\irr[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \sirr\ \mathrm{d}\ \lambda
\label{eq:energy:irrad}
\end{equation}

Let's assume that we want to calculate photosynthetically active radiation (PAR) energy irradiance, for which the most accepted limits are $\lambda_1 = 400 \mathrm{nm}$ and $\lambda_1 = 700 \mathrm{nm}$. In this example we will use example data for sunlight to calculate $\irr[400\,\mathrm{nm} < \lambda < 700\,\mathrm{nm}]$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##         196.7
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \code{PAR()} is predefined in package \PBWB as a convenience function, so the code above can be replaced by:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##   PAR 
## 196.7
\end{verbatim}
\end{kframe}
\end{knitrout}

If no waveband is supplied as argument, then the whole range of wavelengths in the spectral data is used for the integration, and the `name' attribute is generated accordingly:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## range.293.800 
##         269.1
\end{verbatim}
\end{kframe}
\end{knitrout}

If a waveband that does not fully overlap with the data is supplied as argument, then spectral irradiance for wavelengths outside the range is assumed to be zero:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{700}\hlstd{,}\hlnum{1000}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.700.1000 
##           44.1
\end{verbatim}
\end{kframe}
\end{knitrout}

If a waveband that does not overlap with the data is supplied as argument, then spectral irradiance for wavelengths outside the range is assumed to be zero:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{100}\hlstd{,}\hlnum{200}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.100.200 
##             0
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: photon irradiance from spectral irradiance}\label{sec:uw:e2q}

The task to be completed is to calculate the photon irradiance ($\pfd$) in \mol from spectral (energy) irradiance ($\sirr$) in \wattnm and the corresponding wavelengths ($\lambda$) in nm.

Combining equations \ref{eq:energy:irrad} and \ref{eq:energy:mol:photons} we obtain:

\begin{equation}
\pfd[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \sirr\ \frac{h' \cdot c}{\lambda} \mathrm{d}\ \lambda
\end{equation}

Let's assume that we want to calculate photosynthetically active radiation (PAR) photon irradiance. In this example we will use example data for sunlight.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##       PAR 
## 0.0008938
\end{verbatim}
\end{kframe}
\end{knitrout}

If we want to have $\pfd[\PAR]$ (\PPFD) expressed in the usual units of \umol, we need to multiply the result above by $10^6$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   PAR 
## 893.8
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{PAR()} is predefined in package \PBWB as a convenience function, see section \ref{sec:energy:irrad} for an example with arbitrary values for $\lambda_1$ and $\lambda_2$.

%%%%
\section[Task: irradiance from spectral photon irradiance]{Task: calculate energy and photon irradiances from spectral photon irradiance}\label{sec:uw:irrad:q2e}

In the case of the calculation of energy irradiance from spectral photon irradiance the calculation is:
\begin{equation}
\irr[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \spfd\ \frac{\lambda}{h' \cdot c} \mathrm{d}\ \lambda
\end{equation}

And the code\footnote{The dataframe \code{sun.data} contains both spectral energy irradiance vales in `column' \code{s.e.irrad} and spectral photon irradiance in `column' \code{s.q.irrad}}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.q.irrad,}
                       \hlkwd{PAR}\hlstd{()),} \hlkwc{unit.in}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##       PAR 
## 0.0008938
\end{verbatim}
\end{kframe}
\end{knitrout}

The calculation of photon irradiance from spectral photon irradiance, is a simple integration, analogous to that in equation \ref{eq:energy:irrad}, and the code is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.q.irrad,}
                       \hlkwd{PAR}\hlstd{()),} \hlkwc{unit.in}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##       PAR 
## 4.158e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: irradiances for more than one waveband}\label{sec:uw:mult:wb}

It is possible to calculate the irradiances for several wavebands with a single function call by supplying a \code{list} of \code{wavebands} as argument:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Green}\hlstd{(),} \hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   Red.ISO Green.ISO  Blue.ISO 
##     452.2     220.2     149.0
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Green}\hlstd{(),} \hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\hlkwd{signif}\hlstd{(Q.RGB,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   Red.ISO Green.ISO  Blue.ISO 
##       452       220       149
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB[}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## Red.ISO 
##   452.2
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB[}\hlstr{"Green.ISO"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## Green.ISO 
##     220.2
\end{verbatim}
\end{kframe}
\end{knitrout}

A named list can be used to override the use as names for the output of the waveband names:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwc{R}\hlstd{=}\hlkwd{Red}\hlstd{(),} \hlkwc{G}\hlstd{=}\hlkwd{Green}\hlstd{(),} \hlkwc{B}\hlstd{=}\hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##     R     G     B 
## 452.2 220.2 149.0
\end{verbatim}
\end{kframe}
\end{knitrout}

Even when using a single waveband:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwc{UVB}\hlstd{=}\hlkwd{UVB}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   UVB 
## 1.527
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: use simple wavebands}\label{sec:wavebands}

Please, consult the packages' documentation for a list of predefined functions for creating wavebands. Here we will present just a few examples of their use. We usually associate wavebands with colours, however, in many cases there are different definitions in use. For this reason, the functions provided accept an argument that can be used to select the definition to use. In general, the default, is to use the ISO standard whenever it is applicable. The case of the various definitions in use for the \UVB waveband are described on page \pageref{pag:UVB:stds}

We can use a predefined function to create a new \code{waveband} object, which as any other R object can be assigned to a variable:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{uvb} \hlkwb{<-} \hlkwd{UVB}\hlstd{()}
\hlstd{uvb}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

As seen above, there is a specialized \code{print} function for \code{wavebands}. Functions available are \code{min}, \code{max}, \code{range}, \code{center\_wl}, \code{labels}, and \code{color}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{red} \hlkwb{<-} \hlkwd{Red}\hlstd{()}
\hlstd{red}
\end{alltt}
\begin{verbatim}
## Red.ISO 
## low (nm) 610 
## high (nm) 760 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{min}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 610
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 760
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 610 760
\end{verbatim}
\begin{alltt}
\hlkwd{midpoint}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 685
\end{verbatim}
\begin{alltt}
\hlkwd{labels}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## $label
## [1] "Red"
## 
## $name
## [1] "Red.ISO"
\end{verbatim}
\begin{alltt}
\hlkwd{color}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## $CMF
##   Red.CMF 
## "#900000" 
## 
## $CC
##    Red.CC 
## "#FF0000"
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate the use of an argument to choose a certain definition:\label{pag:UVB:stds}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{UVB}\hlstd{()}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"ISO"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"CIE"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.CIE 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"medical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.medical 
## low (nm) 290 
## high (nm) 320 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"none"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.none 
## low (nm) 280 
## high (nm) 320 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate the importance of complying with standards, and how much the photon irradiance calculated can depend on the definition used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(}\hlstr{"ISO"}\hlstd{)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
##   1.527
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(}\hlstr{"none"}\hlstd{)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UVB.none 
##    3.282
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: define simple wavebands}\label{sec:wavebands}

Here we briefly introduce \code{new\_waveband}, and only in chapter \ref{chap:wtirrad} we describe its use in full detail, including the use of spectral weighting functions (SWFs).

Defining a new \code{waveband} based on extreme wavelengths expressed in nm.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wb1} \hlkwb{<-} \hlkwd{new_waveband}\hlstd{(}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{)}
\hlstd{wb1}
\end{alltt}
\begin{verbatim}
## range.500.600 
## low (nm) 500 
## high (nm) 600 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, wb1))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.500.600 
##         314.1
\end{verbatim}
\begin{alltt}
\hlstd{wb2} \hlkwb{<-} \hlkwd{new_waveband}\hlstd{(}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{,} \hlkwc{wb.name}\hlstd{=}\hlstr{"my.colour"}\hlstd{)}
\hlstd{wb2}
\end{alltt}
\begin{verbatim}
## my.colour 
## low (nm) 500 
## high (nm) 600 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, wb2))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## my.colour 
##     314.1
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: photon ratios}\label{sec:photon:ratio}

In photobiology sometimes we are interested in calculation the photon ratio between two wavebands. It makes more sense to calculate such ratios if both numerator and denominator wavebands have the same `width' or if the numerator waveband is fully nested in the denominator waveband. However, frequently used ratios like the \UVB to \PAR photon ratio do not comply with this. For this reason, our functions do not enforce any such restrictions.

For example a ratio frequently used in plant photobiology is the read to far-red photon ratio (R:FR photon ratio or $\zeta$). If we follow the wavelength ranges in the definition given by \cite{Morgan1981a}, using photon irradiance\footnote{In the original text photon fluence rate is used but it not clear whether photon irradiance was meant instead.}:

\begin{equation}
\zeta = \frac{\pfd[655 \mathrm{nm} < \lambda < 665  \mathrm{nm}]}{\pfd[725 \mathrm{nm} < \lambda < 735 \mathrm{nm}]}
\end{equation}

To calculate this for our example sunlight spectrum we can use the following code:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_ratio}\hlstd{(w.length, s.e.irrad,}
                  \hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] 1.251
\end{verbatim}
\end{kframe}
\end{knitrout}

or using the predefined convenience function \code{R\_FR\_ratio}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{R_FR_ratio}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## [1] 1.251
\end{verbatim}
\end{kframe}
\end{knitrout}

Using defaults for waveband definitions:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(),} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## [1] 0.00299
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: energy ratios}\label{sec:energy:ratio}

An energy ratio, equivalent to $\zeta$ can be calculated as follows:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_ratio}\hlstd{(w.length, s.e.irrad,}
                  \hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] 1.384
\end{verbatim}
\end{kframe}
\end{knitrout}

For this infrequently used ratio, no pre-defined function is provided.

%%%%
\section{Task: calculate average number of photons per unit energy}\label{sec:photons:energy}

When comparing photo-chemical and photo-biological responses under different light sources it is of interest to calculate the photons per energy in \moljoule. In this case only one waveband definition is used to calculate the quotient:

\begin{equation}
\bar{q'} = \frac{\pfd[\lambda_1 < \lambda < \lambda_2]}{\irr[\lambda_1 < \lambda < \lambda_2]}
\end{equation}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photons_energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## [1] 4.544e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

For obtaining the same quotient in \umoljoule we just need to multiply by $10^6$. We can use such a multiplier to convert $\irr$ [\watt] into $\pfd$ [\umol] (as \Unit{W} = \Unit{J\,s^{-1}}), or as a divisor to convert $\pfd$ [\umol] into $\irr$ [\watt], \emph{for a given light source and waveband}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photons_energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## [1] 4.544
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section[Task: split energy irradiance into regions]{Task: calculate the contribution of different regions of a spectrum to energy irradiance}\label{sec:split:energy}

\sloppy
It can be of interest to split the total (energy) irradiance into adjacent regions delimited by arbitrary wavelengths. We can use the function \code{split\_energy\_irradiance} to obtain to energy of each of the regions delimited by the values in nm supplied in a numeric vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##         69.63         68.53         58.54
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate that the sum of the four `split' irradiances add to the total for the range of wavelengths covered:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{sum}\hlstd{(}\hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                                 \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{))))}
\end{alltt}
\begin{verbatim}
## [1] 196.7
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##   PAR 
## 196.7
\end{verbatim}
\end{kframe}
\end{knitrout}

It also possible to obtain the `split' as a vector of fractions adding up to one,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"relative"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##        0.3540        0.3484        0.2976
\end{verbatim}
\end{kframe}
\end{knitrout}

or as percentages:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##         35.40         34.84         29.76
\end{verbatim}
\end{kframe}
\end{knitrout}

If the `limits' cover only a region of the spectral data, relative and percent values will be calculated with that region as a reference.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{,}\hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##         35.40         34.84         29.76
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 
##          50.4          49.6
\end{verbatim}
\end{kframe}
\end{knitrout}

A vector of two wavelengths is valid input, although not very useful for percentages:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##           100
\end{verbatim}
\end{kframe}
\end{knitrout}

In contrast, for \code{scale="absolute"}, the default, it can be used as a quick way of calculating an irradiance for a range of wavelengths without having to define a \code{waveband}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##         196.7
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section[Task: split photon irradiance into regions]{Task: calculate the contribution of different regions of a spectrum to photon irradiance}\label{sec:split:photons}

The function \code{split\_photon\_irradiance} takes the same arguments as the equivalent function for photon irradiance, consequently only one code example is provided here (see section \ref{sec:split:energy} for more details):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##         29.41         35.14         35.45
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Weighted and effective irradiance}

\begin{abstract}
  In this chapter we explain how to calculate weighted energy and photon irradiances from spectral irradiance.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:wt:intro}

Weighted irradiance is usually reported in weighted energy units, but it is possible to also use weighted photon based units. In practice the R code to use is exactly the same as for unweighted irradiances, as all the information needed is stored in the \code{waveband} object. An additional factor comes into play and it is the \emph{normalization wavelength}, which is accepted as an argument by the predefined waveband creation functions that use a biological spectral weighting function (BSWF). The focus of this chapter is on the differences between calculations for weighted irradiances compared to those for unweighted irradiances described in chapter \ref{chap:uw:irrad}. In particular it is important that you read sections \ref{sec:uw:e2e}, \ref{sec:uw:e2q}, \ref{sec:uw:q2e}, and \ref{sec:uw:mult:wb} before reading the present chapter.

%%%%
\section{Task: choosing the normalization wavelength}\label{sec:wt:intro}

Function \code{GEN.G()} is predefined in package \PBWB as a convenience function for Green's formulation of Caldwell's generalized plant action spectrum (GPAS) \cite{Green198x}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
##    0.1034
\end{verbatim}
\end{kframe}
\end{knitrout}

The code above uses the default normalization wavelength of 300 nm. Any arbitrary wavelength (nm), within the range of the waveband can be provided as an argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{range}\hlstd{(}\hlkwd{GEN.G}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 250.0 313.3
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{(}\hlnum{280}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## GEN.G.280 
##   0.02402
\end{verbatim}
\end{kframe}
\end{knitrout}


%%%%
\section{Task: use weighted wavebands}\label{sec:wt:intro}

Please, consult the packages' documentation for a list of predefined functions for creating weighted wavebands. Here we will present just a few examples of their use. We usually think of weighted irradiances as being defined by the weighting function, however, in many cases different normalizations are in use, and the result of any calculation depends very strongly on the wavelength used for normalization. For this reason, the functions provided accept an argument that can be used to select the normalization wavelength. In general, the default, is to use the most frequently used normalization.

In a few cases different mathematical formulations are available for the same spectrum, and the differences among them can be quite large. In such cases separate functions are provided for each of them (e.g. \code{GEN.N} and \code{GEN.T} for Green's and Thimijan's formulations of Caldwell's GPAS).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{()}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 300 nm
\end{verbatim}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{(}\hlnum{300}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 300 nm
\end{verbatim}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{(}\hlnum{280}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.280 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 280 nm
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use one of the predefined functions to create a new \code{waveband} object, which as any other R object can be assigned to a variable:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cie} \hlkwb{<-} \hlkwd{CIE}\hlstd{()}
\hlstd{cie}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## low (nm) 250 
## high (nm) 400 
## weighted SWF 
## normalized at 298 nm
\end{verbatim}
\end{kframe}
\end{knitrout}

As seen above, there is a specialized \code{print} function for \code{wavebands}. Functions available are \code{min}, \code{max}, \code{range}, \code{midpoint}, \code{labels}, and \code{color}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{min}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 250
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 400
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 250 400
\end{verbatim}
\begin{alltt}
\hlkwd{midpoint}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 325
\end{verbatim}
\begin{alltt}
\hlkwd{normalization}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 298
\end{verbatim}
\begin{alltt}
\hlkwd{labels}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## $label
## [1] "CIE98"
## 
## $name
## [1] "CIE98.298"
\end{verbatim}
\begin{alltt}
\hlkwd{color}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## $CMF
## CIE98.CMF 
## "#02000F" 
## 
## $CC
##  CIE98.CC 
## "#1A00DD"
\end{verbatim}
\end{kframe}
\end{knitrout}


%%%%
\section{Task: define wavebands}\label{sec:wt:wavebands}

In section \ref{sec:uw:wavebands} we briefly introduced \code{new\_waveband}, and here we describe its use in full detail, including the use of spectral weighting functions (SWFs).

Defining a new weighted \code{waveband}. We start with a simple `toy' example:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{toy.wb} \hlkwb{<-} \hlkwd{new_waveband}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{,} \hlstr{"SWF"}\hlstd{,}
                       \hlkwc{SWF.e.fun}\hlstd{=}\hlkwa{function}\hlstd{(}\hlkwc{wl}\hlstd{)\{(wl} \hlopt{-} \hlnum{400}\hlstd{)}\hlopt{^}\hlnum{2}\hlstd{\},}
                       \hlkwc{norm}\hlstd{=}\hlnum{550}\hlstd{,} \hlkwc{SWF.norm}\hlstd{=}\hlnum{550}\hlstd{,}
                       \hlkwc{wb.name}\hlstd{=}\hlstr{"TOY"}\hlstd{)}
\hlstd{toy.wb}
\end{alltt}
\begin{verbatim}
## TOY 
## low (nm) 400 
## high (nm) 700 
## weighted SWF 
## normalized at 550 nm
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad, toy.wb))}
\end{alltt}
\begin{verbatim}
##   TOY 
## 241.7
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, toy.wb))}
\end{alltt}
\begin{verbatim}
##      TOY 
## 0.001111
\end{verbatim}
\end{kframe}
\end{knitrout}


%%%%
\section{Introduction}\label{sec:wt:intro}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}



\chapter{Transmission and reflection}

\begin{abstract}
In this chapter we explain how to do calculations related to the description of absortion and reflection of UV and VIS radiation.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:}

\section{Task: absorbance and transmittance}

Transmittance is defined as:
\begin{equation}
\tau(\lambda) = \frac{I}{I_0} = \frac{\sirr}{\sirr[0]} = \frac{\spfd}{\spfd[0]}
\end{equation}

Given this simple relation $\tau(\lambda)$ can be calculated as a division between two "source.spct" objects. This gives the correct answer, but as an object of class "source.scpt".

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tau} \hlkwb{<-} \hlstd{spc_above} \hlopt{/} \hlstd{spc_below}
\end{alltt}
\end{kframe}
\end{knitrout}

Absorptance is just $1 - \tau(\lambda)$, but should be distinguished from absorbance ($A(\lambda)$) which is measured on a logarithmic scale:

\begin{equation}
A(\lambda) = -{\log}_{10} \frac{I}{I_0}
\end{equation}

In chemistry 10 is always used as the base of the logarithm, but in other contexts sometimes $\mathrm{e}$ is used as base.

Given the simple equation, $A(\lambda)$ can be also easily calculated using the operators for spectra. This gives the correct answer, but in an object of class "source.scpt".

The conversion between $\tau(\lambda)$ and $A(\lambda)$ is:

\begin{equation}
A(\lambda) = -{\log}_{10} \tau(\lambda)
\end{equation}

which in S language is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_T2A} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}\hlopt{-}\hlkwd{log10}\hlstd{(x)\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The conversion between  $A(\lambda)$ and $\tau(\lambda)$ is:

\begin{equation}
\tau(\lambda) = 10^{-A(\lambda)}
\end{equation}

which in S language is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_A2T} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}\hlnum{10}\hlopt{^-}\hlstd{x\}}
\end{alltt}
\end{kframe}
\end{knitrout}

Instead of these functions, the package defines generic functions and specialized functions, that can be used on vectors and on \code{filter.spc} objects. Then functions defined above could be directly applied to vectors but doing this on a column in a \code{filter.spc} is more cumbersome. As the spectra objects are data.tables, one can add a new column, say with transmittances to a copy of the filter data as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_gg400.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(gg400.spct)}
\hlstd{my_gg400.spct[ , A} \hlkwb{:=} \hlkwd{T2A}\hlstd{(Tfr)]}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr A
##   1:      200 1e-05 5
##   2:      210 1e-05 5
##   3:      220 1e-05 5
##   4:      230 1e-05 5
##   5:      240 1e-05 5
##  ---                 
## 176:     4950 1e-05 5
## 177:     5000 1e-05 5
## 178:     5050 1e-05 5
## 179:     5100 1e-05 5
## 180:     5150 1e-05 5
\end{verbatim}
\begin{alltt}
\hlstd{my_gg400.spct}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr A
##   1:      200 1e-05 5
##   2:      210 1e-05 5
##   3:      220 1e-05 5
##   4:      230 1e-05 5
##   5:      240 1e-05 5
##  ---                 
## 176:     4950 1e-05 5
## 177:     5000 1e-05 5
## 178:     5050 1e-05 5
## 179:     5100 1e-05 5
## 180:     5150 1e-05 5
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: spectral absorbance from spectral transmittance}

Using \code{filter.spct} objects, the calculations become very simple.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{T2A}\hlstd{(gg400.spct)}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr A
##   1:      200 1e-05 5
##   2:      210 1e-05 5
##   3:      220 1e-05 5
##   4:      230 1e-05 5
##   5:      240 1e-05 5
##  ---                 
## 176:     4950 1e-05 5
## 177:     5000 1e-05 5
## 178:     5050 1e-05 5
## 179:     5100 1e-05 5
## 180:     5150 1e-05 5
\end{verbatim}
\begin{alltt}
\hlstd{a.gg400.spct} \hlkwb{<-} \hlkwd{T2A}\hlstd{(gg400.spct,} \hlkwc{action}\hlstd{=}\hlstr{"replace"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: spectral transmittance from spectral absorbance}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{A2T}\hlstd{(a.gg400.spct)}
\end{alltt}
\begin{verbatim}
##      w.length A   Tfr
##   1:      200 5 1e-05
##   2:      210 5 1e-05
##   3:      220 5 1e-05
##   4:      230 5 1e-05
##   5:      240 5 1e-05
##  ---                 
## 176:     4950 5 1e-05
## 177:     5000 5 1e-05
## 178:     5050 5 1e-05
## 179:     5100 5 1e-05
## 180:     5150 5 1e-05
\end{verbatim}
\begin{alltt}
\hlkwd{A2T}\hlstd{(a.gg400.spct,} \hlkwc{action}\hlstd{=}\hlstr{"replace"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr
##   1:      200 1e-05
##   2:      210 1e-05
##   3:      220 1e-05
##   4:      230 1e-05
##   5:      240 1e-05
##  ---               
## 176:     4950 1e-05
## 177:     5000 1e-05
## 178:     5050 1e-05
## 179:     5100 1e-05
## 180:     5150 1e-05
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: reflected or transmitted spectrum from spectral reflectance and spectral irradiance}

When we multiply a \code{source.spct} by a \code{filter.spct} or by a \code{reflector.spct} we obtain as a result a new \code{source.spct}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(gg400.spct)}
\end{alltt}
\begin{verbatim}
## [1] "filter.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct}
\hlkwd{class}\hlstd{(filtered_sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlstd{filtered_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad
##   1:      293 2.610e-11
##   2:      294 6.142e-11
##   3:      295 2.176e-10
##   4:      296 6.780e-10
##   5:      297 1.533e-09
##  ---                   
## 504:      796 3.958e-01
## 505:      797 4.017e-01
## 506:      798 4.109e-01
## 507:      799 4.060e-01
## 508:      800 3.947e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

The result of the calculation can be directly used as an argument, for example, when calulating irradiance.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UV.ISO 
##  85.48 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct} \hlopt{*} \hlstd{gg400.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UV.ISO 
##  3.153 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct} \hlopt{*} \hlstd{ug1.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UV.ISO 
##  55.19 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct} \hlopt{*} \hlstd{gg400.spct)} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.293.800 
##          1136 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct} \hlopt{*} \hlstd{gg400.spct,} \hlkwd{new_waveband}\hlstd{(}\hlkwd{min}\hlstd{(sun.spct),} \hlkwd{max}\hlstd{(sun.spct)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.293.800 
##          1134 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

Remember, thet if we want to predict the output of a light source composed of different lamps or LEDs we can add the individual spectral irradiance, but using data measured from the target positions of each individaul light source. If we want then to add the effect of a filter we must multiply by the filter transmittance.

\begin{framed}
In the current version of package \code{photobiology} the operator is ``chosen'' based on the first operand. For this reason, when including a numeric operand, it should always be the second operand of binary operators for spectra.
\end{framed}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not working}
\hlstd{my_luminaire} \hlkwb{<-} \hlstd{(}\hlnum{0.5} \hlopt{*} \hlstd{Norlux_B.spct} \hlopt{+} \hlstd{Norlux_R.spct)} \hlopt{*} \hlstd{PLX0A000_XT.spct}
\hlstd{my_luminaire}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlcom{# works fine}
\hlstd{my_luminaire} \hlkwb{<-} \hlstd{(Norlux_B.spct} \hlopt{*} \hlnum{0.5} \hlopt{+} \hlstd{Norlux_R.spct)} \hlopt{*} \hlstd{PLX0A000_XT.spct}
\hlstd{my_luminaire}
\end{alltt}
\begin{verbatim}
##       w.length s.e.irrad
##    1:    200.0         0
##    2:    200.5         0
##    3:    200.9         0
##    4:    201.0         0
##    5:    201.4         0
##   ---                   
## 2355:    936.0         0
## 2356:    936.5         0
## 2357:    936.9         0
## 2358:    937.0         0
## 2359:    937.3         0
\end{verbatim}
\begin{alltt}
\hlkwd{q_ratio_spct}\hlstd{(my_luminaire,} \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Blue}\hlstd{(),} \hlkwd{Green}\hlstd{()),} \hlkwd{PAR}\hlstd{())}
\end{alltt}
\begin{verbatim}
##   Red.ISO:PAR(q:q)  Blue.ISO:PAR(q:q) 
##           0.816196           0.146122 
## Green.ISO:PAR(q:q) 
##           0.003909 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_luminaire,} \hlkwd{list}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlkwd{Red}\hlstd{(),} \hlkwd{Blue}\hlstd{(),} \hlkwd{Green}\hlstd{()))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##       PAR   Red.ISO  Blue.ISO Green.ISO 
## 0.0159131 0.0129882 0.0023253 0.0000622 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: total spectral transmittance from internal spectral transmittance and spectral reflectance}\label{sec:}

%%%%
\section{Task: combined spectral transmittance of two or more filters}\label{sec:}

\subsection{Ignoring reflectance}


\subsection{Considering reflectance}

%%%%
\section{Task: light scattering media (natural waters, plant and animal tissues)}\label{sec:}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyLEDs)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}



\chapter{Colour}

\begin{abstract}
  In this chapter we explain how to use colours according to visual sensitivity. For example calculating red-green-blue (RGB) values for humans.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Introduction}

The calculation of equivalent colours and colour spaces is based on the number of photoreceptors and their spectral sensitivities. For humans it is normally accepted that there are three photoreceptors in the eyes, with maximum sensitivities in the red, green, and blue regions of the spectrum.

When calculating colours we can take either only the colour or both colour and apparent luminance. In our functions, in the first case one needs to provide as input `chromaticity coordinates' (CC) and in the second case `colour matching functions' (CMF). The suite includes data for humans, but the current implementation of the functions should be able to handle also calculations for other organisms with tri-chromic vision.

The functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelengths, based on the assumption of a flat energy irradiance across this range.

By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition. The range of wavelengths used in the calculations is that in the chromaticity data.

One use of these functions is to generate realistic colour for `key' on plots of spectral data. Other uses are also possible, like simulating how different, different objects would look to a certain organism.

\begin{framed}
This package is very `young' so may be to some extent buggy, and/or have rough edges.
We plan to add at least visual data for honey bees.
\end{framed}

%%%%
\section{Task: calculating an RGB colour from a single wavelength}\label{sec:color:wl}

Function \code{w\_length2rgb} must be used in this case. If a vector of wavelengths is supplied as argument, then a vector of \code{color}s, of the same length, is returned. Here are some examples of calculation of R color definitions for monochromatic light:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{550}\hlstd{)} \hlcom{# green}
\end{alltt}
\begin{verbatim}
## wl.550.nm 
## "#00FF00"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{630}\hlstd{)} \hlcom{# red}
\end{alltt}
\begin{verbatim}
## wl.630.nm 
## "#FF0000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{380}\hlstd{)} \hlcom{# UVA}
\end{alltt}
\begin{verbatim}
## wl.380.nm 
## "#000000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{750}\hlstd{)} \hlcom{# far red}
\end{alltt}
\begin{verbatim}
## wl.750.nm 
## "#000000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{550}\hlstd{,} \hlnum{630}\hlstd{,} \hlnum{380}\hlstd{,} \hlnum{750}\hlstd{))} \hlcom{# vectorized}
\end{alltt}
\begin{verbatim}
## wl.550.nm wl.630.nm wl.380.nm wl.750.nm 
## "#00FF00" "#FF0000" "#000000" "#000000"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating an RGB colour for a range of wavelengths}\label{sec:color:range}

Function \code{w\_length\_range2rgb} must be used in this case. This function expects as input a vector of two number, as returned by the function \code{range}. If a longer vector is supplied as argument, its range is used, with a warning. If a vector of lengths one is given as argument, then the same output as from function \code{w\_length2rgb} is returned. This function assumes a flat energy spectral irradiance curve within the range. Some examples:
Examples for wavelength ranges:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{700}\hlstd{))}
\end{alltt}
\begin{verbatim}
## 400-700 nm 
##  "#735B57"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlnum{400}\hlopt{:}\hlnum{700}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Using only extreme wavelength values.}}\begin{verbatim}
## 400-700 nm 
##  "#735B57"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(sun.data}\hlopt{$}\hlstd{w.length)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Using only extreme wavelength values.}}\begin{verbatim}
## 293-800 nm 
##  "#554340"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlnum{550}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Calculating RGB values for monochromatic light.}}\begin{verbatim}
## wl.550.nm 
## "#00FF00"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating an RGB colour for spectrum}\label{sec:color:spc}

Function \code{s\_e\_irrad2rgb} in contrast to those described above, when calculating the color takes into account the spectral irradiance.

Examples for spectra, in this case the solar spectrum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## [1] "#544F4B"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCMF2.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#544F4B"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCMF10.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#59534F"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCC2.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#B63C37"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCC10.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#BD3C33"
\end{verbatim}
\end{kframe}
\end{knitrout}

Except for the first example, we specificity the visual sensitivity data to use.

\section{A sample of colours}

Here we plot the RGB colours for the range covered by the CIE 2006 proposed standard calculated at each 1 nm step:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wl} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{390}\hlstd{,} \hlnum{829}\hlstd{)}

\hlstd{my.colors} \hlkwb{<-} \hlkwd{w_length2rgb}\hlstd{(wl[}\hlnum{1}\hlstd{]}\hlopt{:}\hlstd{wl[}\hlnum{2}\hlstd{])}

\hlstd{colCount} \hlkwb{<-} \hlnum{40} \hlcom{# number per row}
\hlstd{rowCount} \hlkwb{<-} \hlkwd{trunc}\hlstd{(}\hlkwd{length}\hlstd{(my.colors)} \hlopt{/} \hlstd{colCount)}

\hlkwd{plot}\hlstd{(} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,colCount),} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,rowCount),} \hlkwc{type}\hlstd{=}\hlstr{"n"}\hlstd{,}
      \hlkwc{ylab}\hlstd{=}\hlstr{""}\hlstd{,} \hlkwc{xlab}\hlstd{=}\hlstr{""}\hlstd{,}
      \hlkwc{axes}\hlstd{=}\hlnum{FALSE}\hlstd{,} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(rowCount,}\hlnum{0}\hlstd{))}
\hlkwd{title}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"RGB colours for"}\hlstd{,}
            \hlkwd{as.character}\hlstd{(wl[}\hlnum{1}\hlstd{]),} \hlstr{"to"}\hlstd{,}
            \hlkwd{as.character}\hlstd{(wl[}\hlnum{2}\hlstd{]),} \hlstr{"nm"}\hlstd{))}

\hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{0}\hlopt{:}\hlstd{(rowCount}\hlopt{-}\hlnum{1}\hlstd{))}
\hlstd{\{}
  \hlstd{base} \hlkwb{<-} \hlstd{j}\hlopt{*}\hlstd{colCount}
  \hlstd{remaining} \hlkwb{<-} \hlkwd{length}\hlstd{(my.colors)} \hlopt{-} \hlstd{base}
  \hlstd{RowSize} \hlkwb{<-}
    \hlkwd{ifelse}\hlstd{(remaining} \hlopt{<} \hlstd{colCount, remaining, colCount)}
  \hlkwd{rect}\hlstd{((}\hlnum{1}\hlopt{:}\hlstd{RowSize)}\hlopt{-}\hlnum{0.5}\hlstd{, j}\hlopt{-}\hlnum{0.5}\hlstd{, (}\hlnum{1}\hlopt{:}\hlstd{RowSize)}\hlopt{+}\hlnum{0.5}\hlstd{, j}\hlopt{+}\hlnum{0.5}\hlstd{,}
       \hlkwc{border}\hlstd{=}\hlstr{"black"}\hlstd{,}
       \hlkwc{col}\hlstd{=my.colors[base} \hlopt{+} \hlstd{(}\hlnum{1}\hlopt{:}\hlstd{RowSize)])}
\hlstd{\}}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-120} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Photoreceptors}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Radiation sources}\label{chap:sources}

\begin{abstract}
  In this chapter we explain how to use the spectral data for light sources.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologySun)}
\hlkwd{library}\hlstd{(photobiologyLamps)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggtern)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:sources:intro}

%%%%
\section{Task: using the data}\label{sec:}

%%%%
\section{Task: extraterrestrial solar radiation spectra}\label{sec:}

%%%%
\section{Task: terrestrial  solar radiation spectra}\label{sec:}

%%%%
\section{Task: incandescent lamps}\label{sec:}

%%%%
\section{Task: discharge lamps}\label{sec:}

%%%%
\section{Task: LEDs}\label{sec:}


\chapter{Filters}\label{chap:filters}

\begin{abstract}
  In this chapter we explain how to use spectral data for filters and how to convolute it spectral data for light sources.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologySun)}
\hlkwd{library}\hlstd{(photobiologyLamps)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggtern)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:filters:intro}

%%%%
\section{Task: using the data}\label{sec:filters:using}

%%%%
\section{Task: spectral transmittance for optical glass filters}\label{sec:filters:glass}

%%%%
\section{Task: spectral transmittance for plastic films}\label{sec:filters:films}

%%%%
\section{Task: spectral transmittance for plastic sheets}\label{sec:filters:sheets}




\chapter{Plotting spectra and colours}

\begin{abstract}
  In this chapter we explain how to plot spectra and colours, using packages \code{ggplot2}, \code{ggtern}, and the functions in our package \code{photobiologygg}. Both \code{ggtern} for ternary plots and \code{photobiologygg} for annotating spectra build new functionality on top of the \code{ggplot2} package.
\end{abstract}


\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggtern)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# \\\#\# Attaching package: 'ggtern'\\\#\# \\\#\# The following objects are masked from 'package:ggplot2':\\\#\# \\\#\#\ \ \ \  \%+\%, \%+replace\%, aes, calc\_element,\\\#\#\ \ \ \  geom\_density2d, geom\_segment,\\\#\#\ \ \ \  geom\_smooth, ggplot\_build,\\\#\#\ \ \ \  ggplot\_gtable, ggsave, opts,\\\#\#\ \ \ \  stat\_density2d, stat\_smooth, theme,\\\#\#\ \ \ \  theme\_bw, theme\_classic, theme\_get,\\\#\#\ \ \ \  theme\_gray, theme\_grey, theme\_minimal,\\\#\#\ \ \ \  theme\_set, theme\_update}}\begin{alltt}
\hlkwd{library}\hlstd{(gridExtra)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: grid}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction to plotting spectra}\label{sec:plot:intro}

We show in this chapter examples of how one can plot spectra. All the examples
are done with package \code{ggplot2}, sometimes using in addition other packages.
\code{ggplot2} provides the most recent type plotting functionality in R, and is
what we use here for most examples. Both \code{base} graphic functions, part of
R itself and `trellis' graphics provided by package \code{lattice} are other popular
alternatives. Several of the functions used in this chapter are extensions to
package \code{ggplot2}\footnote{\code{ggplot2} is feature-frozen. Consequently
it is a good basis for adding application specific functionality through separate
packages. \code{ggplot2} uses the \emph{grammar
of graphics} for describing the plots. This grammar, because it is consistent,
tends to be easier to understand, and makes it easier to design new functionality
that uses extensions based on the same `language grammar' as used by the original package.}

If you are not familiar with \code{ggplot2} plotting, please read Appendix
\ref{chap:R:plotting} on page \pageref{chap:R:plotting} before reading the
present chapter.

%%%%
\section{Task: plotting spectra with \code{ggplot2}}\label{sec:plot:spc}

We create a simple line plot, assign it a variable called \code{fig\_sun.e} and then on the next line \code{print} it. We use \code{labs} to set nice axis labels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.e}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-sun-e-0} 

}



\end{knitrout}

As we are going to re-use the same axis-labels, it is handy to save their defintion to a variable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ylab_watt} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}))}
\hlstd{ylab_watt_atop} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(}\hlkwd{atop}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance,}
                  \hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\hlstd{ylab_umol} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{photon}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(mu}\hlopt{*}\hlstd{mol}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}))}
\hlstd{ylab_umol_atop} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(}\hlkwd{atop}\hlstd{(Spectral}\hlopt{~~}\hlstd{photon}\hlopt{~~}\hlstd{irradiance,}
                  \hlstd{(mu}\hlopt{*}\hlstd{mol}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\end{alltt}
\end{kframe}
\end{knitrout}


%%%%
\section{Task: using a log scale}\label{sec:plot:log}

Here without need to recreate the figure, we add a logarithmic scale for the y-axis and print on the fly the result. In this case we override the automatic limits of the scale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+} \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{1e-3}\hlstd{,} \hlnum{1e0}\hlstd{))}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 7 rows containing missing values (geom\_path).}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-fig-sun-e-1} 

}



\end{knitrout}

%%%%

\section{Task: compare energy and photon spectral units}\label{sec:plot:phot:energy}

We can use function \code{grid.arrange} to make a single plot from two separate ggplots, and put them side by or on top of each other.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{theme_stack_opts} \hlkwb{<-}
  \hlkwd{list}\hlstd{(}\hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.ticks} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.title.x} \hlstd{=} \hlkwd{element_blank}\hlstd{()))}
\hlstd{num_one_dec} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{)}
  \hlkwd{format}\hlstd{(x,} \hlkwc{nsmall}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{trim}\hlstd{=}\hlnum{FALSE}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{4}\hlstd{, ...)}
\hlstd{fig_sun.q} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{labels} \hlstd{= num_one_dec)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_umol_atop)} \hlopt{+}
  \hlstd{theme_stack_opts}
\hlstd{fig_sun.e1} \hlkwb{<-} \hlstd{fig_sun.e} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_watt_atop,}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlkwd{grid.arrange}\hlstd{(fig_sun.q, fig_sun.e1,} \hlkwc{nrow}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-theme-stack} 

}



\end{knitrout}

To make sure that the widths of booth plots are the same, we need to make sure that the tick labels in both plots have the same format. For this we define a formatting function \code{num\_one\_dec} and then use it a the scale definition. We also add \code{atop} to the expression to set the spectral irradiance units on a second line in the axis label.



\section{Task: finding peaks and valleys in spectra}\label{sec:get:pk:vly}

We first show the use of function \code{get\_peaks} that returns the wavelengths at which peaks are located. The parameter \code{span} determines the number of values used to find a local maximum (the higher the value used, the fewer maxima are detected), and the parameter \code{ignore\_threshold} the fraction of the total span along the irradiance that is taken into account (a value of 0.75, requests only peaks in the upper 25\% of the $y$-range to be returned; a value of -0.75 works similarly but for the lower half of the $y$-range)\footnote{In the current example setting \code{ignore\_threshold} equal to 0.75 given that the range of the spectral irradiance data goes from 0.00~\umolnm to 0.82~\umolnm, causes any peaks having a spectral irradiance of less than 0.62 \umolnm to be ignored.}.  It is good to mention that \code{head} returns the first six rows of its argument, and we use it here just to reduce the length of the output, if you run these examples yourself, you can remove \code{head} from the code. In the output, $x$ corresponds to wavelength, and $y$ to spectral irradiance, while \code{label} is a character string with the wavelngth, possibly formatted.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 378 0.4970   378
## 2 416 0.6762   416
## 3 451 0.8205   451
## 4 478 0.7870   478
## 5 495 0.7900   495
## 6 531 0.7603   531
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{,}
                    \hlkwc{ignore_threshold}\hlstd{=}\hlnum{0.75}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 416 0.6762   416
## 2 451 0.8205   451
## 3 478 0.7870   478
## 4 495 0.7900   495
## 5 531 0.7603   531
## 6 582 0.6854   582
\end{verbatim}
\end{kframe}
\end{knitrout}

The parameter span, indicates the size in number of observations (e.g.\ number of discrete wavelength values) included in the window used to find local maxima (peaks) or minima (valleys). By providing different values for this argument
we can `adjust' how \emph{fine} or \emph{coarse} is the structure described by the peaks returned by the function. The window is always defined using an odd number of observations, if an even number is provided as argument, it is increased by one, with a warning.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{21}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 354 0.3759   354
## 2 366 0.4492   366
## 3 378 0.4970   378
## 4 416 0.6762   416
## 5 436 0.7337   436
## 6 451 0.8205   451
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 451 0.8205   451
## 2 495 0.7900   495
## 3 747 0.5026   747
\end{verbatim}
\end{kframe}
\end{knitrout}

The equivalent function for finding valleys is \code{get\_valleys} taking the same parameters as \code{get\_peaks} but returning the wavelengths at which the valleys are located.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_valleys}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 358 0.2545   358
## 2 393 0.2422   393
## 3 431 0.4137   431
## 4 487 0.6512   487
## 5 517 0.6177   517
## 6 589 0.5659   589
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.data,}
          \hlkwd{get_valleys}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{,}
                      \hlkwc{ignore_threshold}\hlstd{=}\hlnum{0.5}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x      y label
## 1 431 0.4137   431
## 2 487 0.6512   487
## 3 517 0.6177   517
## 4 589 0.5659   589
## 5 656 0.4983   656
\end{verbatim}
\end{kframe}
\end{knitrout}

In the next section, we plot spectra and annotate them with peaks and valleys. If you find the meaning of the
parameters \code{span} and \code{ignore\_threshold} difficult to grasp from the explanation given above, please, study the code and plots in section \ref{sec:stat:pk:vly}.

%%%%
\section{Task: annotating peaks and valleys in spectra}\label{sec:stat:pk:vly}

Here we show an example of the use the new \code{ggplot} `statistics' \code{stat\_peaks}
from our package \code{photobiologygg}. It uses the same parameter names and take the
same arguments as the \code{get\_peaks} function described in section \ref{sec:get:pk:vly}.
We reuse once more \code{fig\_sun.e} saved in section \ref{sec:plot:spc}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+} \hlkwd{stat_peaks}\hlstd{(}\hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-sun-e-2} 

}



\end{knitrout}

\sloppy
Now we play with \texttt{ggplot2} to show different ways of plotting the peaks and valleys.
It behaves as a \code{ggplot2} \code{stat\_xxxx} function accepting a \code{geom} argument
and all the aesthetics valid for the chosen geom. By default \code{geom\_text} is used.

We can change aesthetics, for example the colour:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+} \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
            \hlkwd{stat_valleys}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-sun-e-3} 

}



\end{knitrout}

We can also use a different geom, in this case \code{geom\_point}, however, be aware that the \code{geom} parameter takes as argument a character string giving the name of the geom, in this case \code{"point"}.
We change a few additional aesthetics of the points: we set \code{shape} to a character, and set its size to 6.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
             \hlkwc{shape}\hlstd{=}\hlstr{"|"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{6}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-sun-e-4} 

}



\end{knitrout}

We can add the same \code{stat} two or more times to a ggplot, in this example, each time with a different \code{geom}. First we add points to mark the peaks, and afterwards add labels showing the wavelengths at which they are located using geom \code{"text"}. For the \code{shape}, or type of symbol, we use one that supports `fill', and set the \code{fill} to \code{"white"} but keep the border of the symbol \code{"red"} by setting \code{colour}, we also change the \code{size}. With the labels we use \code{vjust} to `justify' the text moving the labels vertically, so that they do not overlap the line depicting the spectrum\footnote{The default position of labels is to have them centred on the coordinates of the peak or valley. Unless we rotate the label, \code{vjust} can be used to shift the label along the $y$-axis, however, justification is a property of the text, not the plot, so the vertical direction is referenced to the position of the text of the label. A value of 0.5 indicates centering, a negative value `up' and a positive value `down'. For example a value of -1 puts the $x, y$ coordinates of the peak or valley at the lower edge of the `bounding box' of the text. For \code{hjust} values of -1 and 1 right and left justify the label with respect to the $x, y$ coordinates supplied. Values other than -1, 0.5, and 1, are valid input, but are rather tricky to use for \code{hjust} as the displacement is computed relative to the width of the bounding box of the label, the displacement being different for the same numerical value depending on the length of the label text.}
In addition we expand the $y$-axis scale so that all labels fall within the plotting area.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlnum{23}\hlstd{,}
             \hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{vjust}\hlstd{=}\hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y}\hlstd{=}\hlnum{0.9}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-sun-e-5} 

}



\end{knitrout}

Finally an example with rotated labels, using different colours for peaks and valleys. Be aware that the `justification' direction, as discussed in the footnote, is referenced to the position of the text, and for this reason to move the rotated labels upwards we need to use \code{hjust} as the desired displacement is horizontal with respect to the orientation of the text of the label. As we put peak labels above the spectrum and valleys bellow it, we need to use \code{hjust} values of opposite sign, but the exact values used were simply adjusted by trial and error until the figure looked as desired.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.5}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{stat_valleys}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{color}\hlstd{=}\hlstr{"blue"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y}\hlstd{=}\hlnum{1.0}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-sun-e-6} 

}



\end{knitrout}

See section \ref{?} in chapter \ref{chap:sources} for an example these stats together with facets.

%%%%
\section{Task: annotating wavebands}\label{sec:plot:wdband}

The function \code{annotate\_waveband} can be used to highlight a waveband in a plot of spectral data. Its first argument should be a \code{waveband} object, and the second argument a \code{geom} as a character string. The positions on the x-axis are calculated automatically by default, but they can be overridden by explicit arguments. The vertical positions have no default, except for \code{ymin} which is equal to zero by default. The colour has a default value calculated from waveband definition, in addition x is by default set to the midpoint of the waveband along the wavelength limits. The default value of the labels is the `name' of the waveband as returned by \code{labels.waveband}.

Here is an example for \PAR using defaults, and with arguments supplied only for parameters with no defaults. The example does the annotation using two different `geoms', \code{"rect"} for marking the region, and \code{"text"} for the labels.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl} \hlkwb{<-} \hlstd{fig_sun.e} \hlopt{+} \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
                     \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)}
\hlstd{figvl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-figvl-1} 

}



\end{knitrout}

This example annotates a narrow waveband.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl} \hlkwb{<-} \hlstd{fig_sun.e} \hlopt{+} \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Yellow}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
                     \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Yellow}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)}
\hlstd{figvl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-figvl-2} 

}



\end{knitrout}

Now an example that is more complex, and demonstrates the flexibility of plots produced with \code{ggplot2}. We add annotations for eight different wavebands, some of them overlapping. For each one we use two `geoms' and some labels are rotated and justified. We can also see in this example that the annotations look nicier on a white background, which can be obtained with \code{theme\_bw}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figv2} \hlkwb{<-} \hlstd{fig_sun.e} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVC}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVC}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Blue}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Blue}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.5}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Green}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Green}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.50}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)}
\hlstd{figv2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-figv2} 

}



\end{knitrout}

A simple example using \code{geom\_vline}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl3} \hlkwb{<-} \hlstd{fig_sun.q} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept}\hlstd{=}\hlkwd{range}\hlstd{(}\hlkwd{PAR}\hlstd{()))}
\hlstd{figvl3}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-figvl-3} 

}



\end{knitrout}

And one where we change some of the aesthetics, and add a label:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl4} \hlkwb{<-} \hlstd{fig_sun.q} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept}\hlstd{=}\hlkwd{range}\hlstd{(}\hlkwd{PAR}\hlstd{()),} \hlkwc{linetype}\hlstd{=}\hlstr{"dashed"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{1.4}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\hlstd{figvl4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-figvl-4} 

}



\end{knitrout}

Now including calculated values in the labels. Because of using expressions to obtain superscripts we need to add \code{parse=TRUE} to the call.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,}
                  \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_watt,}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{uvb} \hlkwb{<-} \hlkwd{e_irrad_spct}\hlstd{(sun.spct,} \hlkwd{UVB}\hlstd{())}
\hlstd{uva} \hlkwb{<-} \hlkwd{e_irrad_spct}\hlstd{(sun.spct,} \hlkwd{UVA}\hlstd{())}
\hlstd{par} \hlkwb{<-} \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{())} \hlopt{*} \hlnum{1e6}
\hlstd{fig_sun2} \hlkwb{<-} \hlstd{fig_sun} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"UVB:~"}\hlstd{,} \hlkwd{signif}\hlstd{(uvb,} \hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{"*~W~m^\{-2\}~nm^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{0.2}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,}
                    \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"UVA:~"}\hlstd{,} \hlkwd{signif}\hlstd{(uva,} \hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{"*~W~m^\{-2\}~nm^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"PAR:~"}\hlstd{,} \hlkwd{signif}\hlstd{(par,}\hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{"*~mu*mol~m^\{-2\}~s^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\hlstd{fig_sun2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-sun-0} 

}



\end{knitrout}

This also works for effective exposures or doses, in this case as we position the annotations manually, we can use ggplot2's `normal' \code{annotate}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_dsun} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{polythene.new.spct,}
                   \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad} \hlopt{*} \hlnum{1e-3}\hlstd{))} \hlopt{+} \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{polyester.new.spct,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{PC.spct,} \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{exposure}\hlopt{~~}\hlstd{(kJ}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{d}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)} \hlopt{+} \hlkwd{xlim}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{425}\hlstd{)} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{25}\hlstd{)}
\hlstd{cie.pe} \hlkwb{<-} \hlkwd{e_irrad_spct}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{polythene.new.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{cie.ps} \hlkwb{<-} \hlkwd{e_irrad_spct}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{polyester.new.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{cie.pc} \hlkwb{<-} \hlkwd{e_irrad_spct}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{PC.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{y.pos} \hlkwb{=} \hlnum{22.5}
\hlstd{fig_dsun2} \hlkwb{<-} \hlstd{fig_dsun} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,}
           \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polythene~~filter~~CIE:~"}\hlstd{,}
                       \hlkwd{signif}\hlstd{(cie.pe,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                       \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=y.pos}\hlopt{+}\hlnum{2}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polyester~~filter~~CIE:~"}\hlstd{,}
                               \hlkwd{signif}\hlstd{(cie.ps,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                               \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=y.pos,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,}  \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,}  \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polycarbonate~~filter~~CIE:~"}\hlstd{,}
                               \hlkwd{signif}\hlstd{(cie.pc,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                               \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=y.pos}\hlopt{-}\hlnum{2}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,}  \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\hlstd{fig_dsun2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-fig-dsun} 

}



\end{knitrout}

% \section{Task: automating plotting}
%
% <<>>=
% fig_sun.z <-
%   ggplot(data=sun.spct, aes(x=w.length, y=s.e.irrad)) +
%   geom_line()  +
%   labs(
%     y = expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
%     x = "Wavelength (nm)")
% fig_sun.z
% @

\section{Task: using colour as data in plots}

First some new scales.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{scale_colour_tgspct} \hlkwb{<-}
  \hlkwa{function}\hlstd{(}\hlkwc{...}\hlstd{,}
           \hlkwc{tg.spct}\hlstd{,}
           \hlkwc{labels} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{guide} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{) \{}
    \hlstd{spct.tags} \hlkwb{<-} \hlkwd{attr}\hlstd{(tg.spct,} \hlstr{"spct.tags"}\hlstd{,} \hlkwc{exact}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(guide))\{}
      \hlkwa{if} \hlstd{(spct.tags}\hlopt{$}\hlstd{wb.num} \hlopt{>} \hlnum{12}\hlstd{) \{}
        \hlstd{guide} \hlkwb{=} \hlstr{"none"}
      \hlstd{\}} \hlkwa{else} \hlstd{\{}
        \hlstd{guide} \hlkwb{=} \hlkwd{guide_legend}\hlstd{(}\hlkwc{title}\hlstd{=}\hlkwa{NULL}\hlstd{)}
      \hlstd{\}}
    \hlstd{\}}
    \hlstd{values} \hlkwb{<-} \hlkwd{as.character}\hlstd{(spct.tags}\hlopt{$}\hlstd{wb.colors)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(labels)) \{}
      \hlstd{labels} \hlkwb{<-} \hlstd{spct.tags}\hlopt{$}\hlstd{wb.names}
    \hlstd{\}}
    \hlstd{ggplot2:::}\hlkwd{manual_scale}\hlstd{(}\hlstr{"colour"}\hlstd{,}
                           \hlkwc{values} \hlstd{= values,}
                           \hlkwc{labels} \hlstd{= labels,}
                           \hlkwc{guide} \hlstd{= guide,}
                           \hlkwc{na.value} \hlstd{= na.value,}
                           \hlstd{...)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{scale_fill_tgspct} \hlkwb{<-}
  \hlkwa{function}\hlstd{(}\hlkwc{...}\hlstd{,}
           \hlkwc{tg.spct}\hlstd{,}
           \hlkwc{labels} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{guide} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{) \{}
    \hlstd{spct.tags} \hlkwb{<-} \hlkwd{attr}\hlstd{(tg.spct,} \hlstr{"spct.tags"}\hlstd{,} \hlkwc{exact}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(guide))\{}
      \hlkwa{if} \hlstd{(spct.tags}\hlopt{$}\hlstd{wb.num} \hlopt{>} \hlnum{12}\hlstd{) \{}
        \hlstd{guide} \hlkwb{=} \hlstr{"none"}
      \hlstd{\}} \hlkwa{else} \hlstd{\{}
        \hlstd{guide} \hlkwb{=} \hlkwd{guide_legend}\hlstd{(}\hlkwc{title}\hlstd{=}\hlkwa{NULL}\hlstd{)}
      \hlstd{\}}
    \hlstd{\}}
    \hlstd{values} \hlkwb{<-} \hlkwd{as.character}\hlstd{(spct.tags}\hlopt{$}\hlstd{wb.colors)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(labels)) \{}
      \hlstd{labels} \hlkwb{<-} \hlstd{spct.tags}\hlopt{$}\hlstd{wb.names}
    \hlstd{\}}

    \hlstd{ggplot2:::}\hlkwd{manual_scale}\hlstd{(}\hlstr{"fill"}\hlstd{,}
                           \hlkwc{values} \hlstd{= values,}
                           \hlkwc{labels} \hlstd{= labels,}
                           \hlkwc{guide} \hlstd{= guide,}
                           \hlkwc{na.value} \hlstd{= na.value,}
                           \hlstd{...)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

We add wavelength-dependent colour and waveband information to the spectral data object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(par.sun.spct,} \hlkwd{PAR}\hlstd{())}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color wb.f
##   1:      293 2.610e-06 6.392e-12  #000000   NA
##   2:      294 6.142e-06 1.510e-11  #000000   NA
##   3:      295 2.176e-05 5.366e-11  #000000   NA
##   4:      296 6.780e-05 1.678e-10  #000000   NA
##   5:      297 1.533e-04 3.807e-10  #000000   NA
##  ---                                           
## 506:      796 4.081e-01 2.715e-06  #000000   NA
## 507:      797 4.141e-01 2.759e-06  #000000   NA
## 508:      798 4.236e-01 2.826e-06  #000000   NA
## 509:      799 4.186e-01 2.796e-06  #000000   NA
## 510:      800 4.069e-01 2.721e-06  #000000   NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we use the \code{wb.f} factor that was added as part of the tagging, whcih results in a palette unrelated to the real colour of the different wavelengths.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.z} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=par.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{color}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.z}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tag-par-2} 

}



\end{knitrout}

As part of the tagging colour information was also added to the spectral data object (we may want to increase the number of `observations' in the spectrum by interpolation if there are too few observations for smooth colour gradient. You can play with \code{length.out} and the \code{size} of points until you get the result you like. We tag each observation in the solar spectrum with human vision colours as defined by CIE.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tg.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(tg.sun.spct,} \hlkwd{VIS_bands}\hlstd{())}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color wb.f
##   1:      293 2.610e-06 6.392e-12  #000000   NA
##   2:      294 6.142e-06 1.510e-11  #000000   NA
##   3:      295 2.176e-05 5.366e-11  #000000   NA
##   4:      296 6.780e-05 1.678e-10  #000000   NA
##   5:      297 1.533e-04 3.807e-10  #000000   NA
##  ---                                           
## 511:      796 4.081e-01 2.715e-06  #000000   NA
## 512:      797 4.141e-01 2.759e-06  #000000   NA
## 513:      798 4.236e-01 2.826e-06  #000000   NA
## 514:      799 4.186e-01 2.796e-06  #000000   NA
## 515:      800 4.069e-01 2.721e-06  #000000   NA
\end{verbatim}
\end{kframe}
\end{knitrout}

We first plot using colours by waveband---using the colour definitions by CIE---, with symbols filled with colours. The colour data outside the wavebands is set to \code{NA} so those points are not filled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.z} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=tg.sun.spct)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{)}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.z}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tag-vis-2} 

}



\end{knitrout}

Using \code{geom\_area} we can fill the area under the curve according to the colour of different wavebands, we set the fill only for this geom, so that the \code{NA}s do not affect other ploting. To get a single black curve for the spectrum we use \code{geom\_line}. This approach works as long as not two wavebands share the same value for the color, which means that it is not suitable either wwhen more than one band is outside the visible range, or when using many narrow wavebands.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.zz} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(tg.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=tg.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.5}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.zz} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tag-vis-3} 

}



\end{knitrout}

We can instead tag the solar spectrum with colours using the definitions of plant sensory `colours'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pl.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(pl.sun.spct,} \hlkwd{Plant_bands}\hlstd{())}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color wb.f
##   1:      293 2.610e-06 6.392e-12  #000000  UVB
##   2:      294 6.142e-06 1.510e-11  #000000  UVB
##   3:      295 2.176e-05 5.366e-11  #000000  UVB
##   4:      296 6.780e-05 1.678e-10  #000000  UVB
##   5:      297 1.533e-04 3.807e-10  #000000  UVB
##  ---                                           
## 514:      796 4.081e-01 2.715e-06  #000000   NA
## 515:      797 4.141e-01 2.759e-06  #000000   NA
## 516:      798 4.236e-01 2.826e-06  #000000   NA
## 517:      799 4.186e-01 2.796e-06  #000000   NA
## 518:      800 4.069e-01 2.721e-06  #000000   NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we plot using colours by waveband using the definitions of plant sensory `colours'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.pl} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(pl.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=pl.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.pl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tag-plants-2} 

}



\end{knitrout}

We can also use the factor \code{wb.f} which has value \code{NA} outside the wavebands, changing the colour used for \code{NA} to \code{NA} which renders it invisible. We can change the labels in the scale, or when tagging the spectrum.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.pl} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(pl.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{name}\hlstd{=}\hlstr{""}\hlstd{,}
                  \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"UVB"}\hlstd{,} \hlstr{"UVA"}\hlstd{,} \hlstr{"Blue"}\hlstd{,} \hlstr{"Green"}\hlstd{,} \hlstr{"Red"}\hlstd{,} \hlstr{"Far red"}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.pl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tag-plants-3} 

}



\end{knitrout}

When using a factor we can play with the scale definitions and represent the wavebands in any way we may want. For example we can use \code{split\_bands} into many smaller bands and get an almost conitnuous gradient, but get around the problem of repeated colours by using the factor and redefining the scale.


Then we tag the VIS region of the spectrum with 150 narrow wavebands. As `hinges' are inserted there is no gap, and usually there is no need to increase the length of the spectrum by intepolation. If needed one could try something
like.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwc{length.out}\hlstd{=}\hlnum{800}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We just use the example spectrum as is, and this time tag the VIS region of the spectrum.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{splt.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(splt.sun.spct,} \hlkwd{split_bands}\hlstd{(}\hlkwd{VIS}\hlstd{(),} \hlkwc{length.out}\hlstd{=}\hlnum{150}\hlstd{))}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color wb.f
##   1:      293 2.610e-06 6.392e-12  #000000   NA
##   2:      294 6.142e-06 1.510e-11  #000000   NA
##   3:      295 2.176e-05 5.366e-11  #000000   NA
##   4:      296 6.780e-05 1.678e-10  #000000   NA
##   5:      297 1.533e-04 3.807e-10  #000000   NA
##  ---                                           
## 804:      796 4.081e-01 2.715e-06  #000000   NA
## 805:      797 4.141e-01 2.759e-06  #000000   NA
## 806:      798 4.236e-01 2.826e-06  #000000   NA
## 807:      799 4.186e-01 2.796e-06  #000000   NA
## 808:      800 4.069e-01 2.721e-06  #000000   NA
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(splt.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt.sun.spct)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.67}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.splt} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-VIS-2} 

}



\end{knitrout}

In this other example we tag the whole spectrum, dividing it into 200 wavebands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{splt1.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlcom{# splt1.sun.spct <- interpolate_spct(splt1.sun.spct, length.out=1000)}
\hlkwd{tag}\hlstd{(splt1.sun.spct,} \hlkwd{split_bands}\hlstd{(sun.spct,} \hlkwc{length.out}\hlstd{=}\hlnum{200}\hlstd{))}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color  wb.f
##   1:    293.0 2.610e-06 6.392e-12  #000000   wb1
##   2:    294.0 6.142e-06 1.510e-11  #000000   wb1
##   3:    295.0 2.176e-05 5.366e-11  #000000   wb1
##   4:    295.5 4.639e-05 1.147e-10  #000000   wb1
##   5:    295.5 4.639e-05 1.147e-10  #000000   wb2
##  ---                                            
## 902:    797.5 4.185e-01 2.790e-06  #000000 wb199
## 903:    797.5 4.185e-01 2.790e-06  #000000 wb200
## 904:    798.0 4.236e-01 2.826e-06  #000000 wb200
## 905:    799.0 4.186e-01 2.796e-06  #000000 wb200
## 906:    800.0 4.069e-01 2.721e-06  #000000 wb200
\end{verbatim}
\end{kframe}
\end{knitrout}

We use \code{geom\_area} and \code{fill}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt1} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(splt1.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt1.sun.spct)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.splt1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-all-2} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt1} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(splt1.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt1.sun.spct)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.5}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.splt1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-all-3} 

}



\end{knitrout}


This example uses \code{geom\_point} and \code{colour}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt1} \hlkwb{<-}
\hlkwd{ggplot}\hlstd{(splt1.sun.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_colour_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt1.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{colour}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.splt1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-all-4} 

}



\end{knitrout}

When ploting points, rather than an area we may instead want to plot the colour calculated for each individual wavelength value, which \code{tag} adds to the spectrum, whether a waveband definition is supplied or not. In
this case we need to use \code{scale\_color\_identity}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.y} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_color_identity}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{color}\hlstd{=wl.color))}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\hlstd{fig_sun.y}  \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-all-5} 

}



\end{knitrout}


%%%%
\section{Task: plotting colours in Maxwell's triangle}\label{sec:max:tri}

\subsection{Human vision: RGB}
Given a color definition, we can convert it to RGB values by means of R's function \code{col2rgb}. We can obtain a color definition for monochromatic light from its wavelength with function \code{w\_length2rgb} (see section \ref{}), from a waveband with function \code{color} (see section \ref{}), for a wavelength range with \code{w\_length\_range2rgb} (see section \ref{}), and from a spectrum with function \code{s\_e\_irrad2rgb}  (see section \ref{}). The RGB values can be used to locate the position of any colour on Maxwell's triangle, given a set of chromaticity coordinates defining the triangle. In the first example we use some of R's predefined colors. We use the function \code{ggtern} from the package of the same name. It is based on \code{ggplot} and to produce a ternary diagram we need to use \code{ggtern} instead of \code{ggplot}. Geoms, aesthetics, stats and faceting function normally in most cases. Of course, being a ternary plot, the aesthetics \code{x}, \code{y}, and \code{z} should be all assigned to variables in the data.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{colours} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"green"}\hlstd{,} \hlstr{"yellow"}\hlstd{,} \hlstr{"white"}\hlstd{,}
             \hlstr{"orange"}\hlstd{,} \hlstr{"purple"}\hlstd{,} \hlstr{"seagreen"}\hlstd{,} \hlstr{"pink"}\hlstd{)}
\hlstd{rgb.values} \hlkwb{<-} \hlkwd{col2rgb}\hlstd{(colours)}
\hlstd{test.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{colour}\hlstd{=colours,}
                        \hlkwc{R}\hlstd{=rgb.values[}\hlnum{1}\hlstd{, ],}
                        \hlkwc{G}\hlstd{=rgb.values[}\hlnum{2}\hlstd{, ],}
                        \hlkwc{B}\hlstd{=rgb.values[}\hlnum{3}\hlstd{, ])}
\hlstd{maxwell.tern} \hlkwb{<-} \hlkwd{ggtern}\hlstd{(}\hlkwc{data}\hlstd{=test.data,}
                       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=R,} \hlkwc{y}\hlstd{=G,} \hlkwc{z}\hlstd{=B,} \hlkwc{label}\hlstd{=colour,} \hlkwc{fill}\hlstd{=colour))} \hlopt{+}
                       \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{23}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.2}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"R"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlstr{"G"}\hlstd{,} \hlkwc{z}\hlstd{=}\hlstr{"B"}\hlstd{)} \hlopt{+} \hlkwd{scale_fill_identity}\hlstd{()}
\hlstd{maxwell.tern}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-tern-1} 

}



\end{knitrout}

\section{Honey-bee vision: GBU}

In this case we start with the spectral responsiveness of the photoreceptors present in the eyes of honey bees. Bees, as humans have three photoreceptors, but instead of red, green and blue (RGB), bees see green, blue and UV-A (GBU). To plot colours seen by bees one can still use a ternary plot, but the axes represent different photoreceptors than for humans, and the colour space is shifted towards shorter wavelengths.

The calculations we will demonstrate here, in addition are geared to compare a background to a foreground object (foliage vs.\ flower). We have followed xxxxx \cite{chitka?} in this example, but be aware that calculations presented in this reference do not match the equations presented. In the original published example, the calculations have been simplified by leaving out $\delta \lambda$. Although not affecting the final result for their example, intermediate results are different (wrong?). We have further generalized the calculations and equations to make the calculations also valid for spectra measured using $\delta \lambda$ that itself varies along the wavelength axis. This is the usual situation with array spectrometers, nowadays frequently used when measuring reflectance.

The assessment of the perceived `colour difference' between background and foreground objects requires taking into consideration several spectra: the incident `light' spectrum, the reflectance spectra of the two objects, and the sensitivity spectra of three photoreceptors in the case of trichromic vision. In addition to these data, we need to take into consideration the shape of the dose response of the photoreceptors.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologygg)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggtern)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{gridExtra)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}




\chapter{Calibration}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Simulation}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Measurement}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}


\chapter{Optimizing performance}

\begin{abstract}
  In this chapter we explain how to make your photobiology calculations execute as fast as possible. The code has been profiled and the performance bottlenecks removed in most cases the implementing some functions in C++. Furthermore copying of spectra is minimized by using package \code{data.table} as the base class of all objects where spectral data is stored. However, it is possible to improve performance even more by changing some defaults and writing efficient user code. This is what is discussed in the present chapter, and should not be of concern unless several thousands of spectra need to be processed.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(microbenchmark)}
\end{alltt}
\end{kframe}
\end{knitrout}

Although not a recommended practice, just to keep the examples shorter, we \code{attach} a data set for the solar spectrum:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attach}\hlstd{(sun.data)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# The following objects are masked \_by\_ .GlobalEnv:\\\#\# \\\#\#\ \ \ \  s.e.irrad, s.q.irrad}}\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:perf:intro}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, as in one of our experiments, we need to process several hundreds of thousands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

There is also a lot you can achieve by carefully writing the code in your own scripts. The packages themselves are fairly well optimized for speed. In your own code try to avoid unnecessary copying of big objects. The \textsf{r4photobiology} suite makes extensive use of the \code{data.table} package, using it also in your own code could help. Try to avoid use of explicit loops by replacing them with vectorized operations, and when sequentially building vectors in a loop, preallocate an object big enough before entering the loop.

Being R an interpreted language, there is rather little automatic code optimization taking place, so you may find that even simple things like moving invariant calculations out of loops, and avoiding repeated calculations of the same value by storing the value in a variable can improve performance.

This type of `good style' optimizations have been done throughout the suite's code, and more specific problem identified by profiling and and dealt with case by case. Of course, to achieve maximum overall performance, to should follow the same approach with your own code.

%%%%
\section{Task: avoiding repeated validation}\label{sec:perf:check}

In the case of doing calculations repeatedly on the same spectrum, a small improvement in performance can be achieved by setting the parameter \code{check.spectrum=FALSE} for all but the first call to \code{irradiance()}, or \code{photon\_irradiance()}, or \code{energy\_irradiance()}, or the equivalent functions for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by explicitly calling \code{check\_spectrum()}.

%%%%
\section{Task: caching of multipliers}\label{sec:perf:caching}

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \code{use.cached.mult=TRUE}, as this reuses the multipliers calculated during successive calls based on the same waveband. However, to achieve this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached values discarded and recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

%%%%
\section{Task: benchmarking}\label{sec:perf:benchmark}

You can use the package \code{microbenchmark} to time the code and find the parts that slow it down. I have used it, and also
I have used profiling to optimize the code for speed. The examples below show how choosing different values from the defaults
can speed up calculations when the same calculations are done repeatedly on spectra measured at exactly the same wavelengths, something which is usual when analyzing spectra measured with the same instrument. The choice of defaults is based on what is
best when processing a moderate number of spectra, say less than a few hundreds, as opposed to many thousands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(microbenchmark)}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Convenience functions}

The convenience functions are slightly slower than the generic \code{irradiance} function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{unit.out}\hlstd{=}\hlstr{"photon"}\hlstd{,}
             \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Using the generic reduces the median execution time from 0.11 ms to  0.104 ms, by 5\% if using the cache.

\subsection{Using cached multipliers}

Using the cache when repeatedly applying the same waveband has a large impact on the execution time.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using an unweighted waveband the cache reduces the median execution time from 0.173 ms to  0.108 ms, by 37\%.

When using BSWFs the speed up by use of the cache is more important, and dependent on the complexity of the equation used in the calculation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{()),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

When using a weighted waveband, in this example, \code{CIE()}, the cache reduces the median execution time from 0.308 ms to  0.117 ms, by 62\%.

\subsection{Disabling checks}

Disabling the checking of the spectrum halves once again the execution time for unweighted wavebands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using an unweighted waveband, in this example, \code{PAR()}, the disabling the data validation checking reduces the median execution time from 0.108 ms to  0.0791 ms, by 27\%.

\subsection{Using stored wavebands}

Saving a waveband object and reusing it, can give an additional speed up when all other optimizations are also used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myPAR} \hlkwb{<-} \hlkwd{PAR}\hlstd{()}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, myPAR,} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using an unweighted waveband, in this example, \code{PAR()}, using a saved waveband object reduces the median execution time from 0.0802 ms to  0.0682 ms, by 15\%.

Saving a waveband object that uses weighting and reusing it, gives an additional speed up when all other optimizations are also used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myCIE} \hlkwb{<-} \hlkwd{CIE}\hlstd{()}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, myCIE,} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using a weighted waveband, in this example, \code{CIE()}, using a saved waveband object reduces the median execution time from 0.0874 ms to  0.0701 ms, by 20\%.



\subsection{Inserting hinges}

Inserting `hinges' to reduce integration errors slows down the computations considerably. If the spectral data is measured with a small wavelength step, the errors are rather small. By default the use of `hinges' is automatically decided based on the average wavelength step in the spectral data. The `cost' of using hinges depends on the waveband definition, as BSWFs with discontinuities in the slope require several hinges, while unweighted one requires at most two, one at each boundary.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using an uweighted waveband, in this example, \code{PAR()}, enabling use of hinges increases the median execution time from 0.11 ms to  0.414 ms, by a  factor of 3.747.

Inserting `hinges' to reduce integration errors slows down the computations a lot. If the spectral data is measured with a
small wavelength step, the errors are rather small. By default the use of `hinges' is automatically decided based on the
average wavelength step in the spectral data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using an weighted waveband, in this example, \code{CIE()}, enabling use of hinges increases the median execution time from 0.116 ms to  0.426 ms, by a  factor of 3.6705.

\section{Overall speed-up achievable}

\subsection{\code{GEN.G}}

If we consider a slow computation, using a BSWF with a complex equation like \code{GEN.G}, we can check the best case improvement in throughput that can be ---on a given hardware and software system.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# slowest}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{(),}
                    \hlkwc{use.cache}\hlstd{=}\hlnum{FALSE}\hlstd{,}
                    \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{TRUE}\hlstd{),}
                      \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlcom{# default}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{()),}
                       \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}

\hlcom{# fastest}
\hlstd{gen.g} \hlkwb{<-} \hlkwd{GEN.G}\hlstd{()}
\hlstd{res3} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{irradiance}\hlstd{(w.length, s.e.irrad, gen.g,}
             \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
             \hlkwc{use.hinges}\hlstd{=}\hlnum{FALSE}\hlstd{,}
             \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{,}
             \hlkwc{unit.out}\hlstd{=}\hlstr{"photon"}\hlstd{),}
                       \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using a weighted waveband, in this example, \code{GEN.G()}, enabling all checks and optimizations for precision, and disabling all optimizations for speed yields a median execution time of 0.59 ms, accepting all defaults yields a median execution time 0.281 ms, and disabling all checks, optimizations for precision and enabling all optimizations for speed yields a median execution time of 0.0658, in relation to the slowest one, execution times are 100, 48, and 11\%.

Finally we compare the returned values for the irradiance, to see the impact on them of optimizing for speed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# slowest}
\hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{(),}
                  \hlkwc{use.cache}\hlstd{=}\hlnum{FALSE}\hlstd{,}
                  \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                  \hlkwc{check.spectrum}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## 2.579e-07
\end{verbatim}
\begin{alltt}
\hlcom{# default}
\hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{())}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## 2.592e-07
\end{verbatim}
\begin{alltt}
\hlcom{# fastest}
\hlstd{gen.g} \hlkwb{<-} \hlkwd{GEN.G}\hlstd{()}
\hlkwd{irradiance}\hlstd{(w.length, s.e.irrad, gen.g,}
           \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
           \hlkwc{use.hinges}\hlstd{=}\hlnum{FALSE}\hlstd{,}
           \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{,}
           \hlkwc{unit.out}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## 2.592e-07
\end{verbatim}
\end{kframe}
\end{knitrout}

These results are based on spectral data at 1 nm interval, for more densely measured data the effect of not using hinges becomes even smaller. In contrast, with data measured at wider wavelength steps, the errors will be larger. They also depend on the specific BSWF being used.

\subsection{\code{CIE}}

If we consider a slow computation, using a BSWF with a complex equation like \code{CIE}, we can check the best case improvement in throughput that can be ---on a given hardware and software system.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# slowest}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),}
                    \hlkwc{use.cache}\hlstd{=}\hlnum{FALSE}\hlstd{,}
                    \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                    \hlkwc{check.spectrum}\hlstd{=}\hlnum{TRUE}\hlstd{),}
                      \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlcom{# default}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{()),}
                       \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}

\hlcom{# fastest}
\hlstd{cie} \hlkwb{<-} \hlkwd{CIE}\hlstd{()}
\hlstd{res3} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{irradiance}\hlstd{(w.length, s.e.irrad, cie,}
             \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
             \hlkwc{use.hinges}\hlstd{=}\hlnum{FALSE}\hlstd{,}
             \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{,}
             \hlkwc{unit.out}\hlstd{=}\hlstr{"photon"}\hlstd{),}
                       \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using a weighted waveband, in this example, \code{CIE()}, enabling all checks and optimizations for precision, and disabling all optimizations for speed yields a median execution time of 0.626 ms, accepting all defaults yields a median execution time 0.329 ms, and disabling all checks, optimizations for precision and enabling all optimizations for speed yields a median execution time of 0.0677, in relation to the slowest one, execution times are 100, 53, and 11\%.

Finally we compare the returned values for the irradiance, to see the impact on them of optimizing for speed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# slowest}
\hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{(),}
                  \hlkwc{use.cache}\hlstd{=}\hlnum{FALSE}\hlstd{,}
                  \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                  \hlkwc{check.spectrum}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.038e-07
\end{verbatim}
\begin{alltt}
\hlcom{# default}
\hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{CIE}\hlstd{())}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.037e-07
\end{verbatim}
\begin{alltt}
\hlcom{# fastest}
\hlstd{CIE} \hlkwb{<-} \hlkwd{CIE}\hlstd{()}
\hlkwd{irradiance}\hlstd{(w.length, s.e.irrad, CIE,}
           \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
           \hlkwc{use.hinges}\hlstd{=}\hlnum{FALSE}\hlstd{,}
           \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{,}
           \hlkwc{unit.out}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.037e-07
\end{verbatim}
\end{kframe}
\end{knitrout}

These results are based on spectral data at 1 nm interval, for more densely measured data the effect of not using hinges becomes even smaller. In contrast, with data measured at wider wavelength steps, the errors will be larger. They also depend on the specific BSWF being used.

\subsection{Using \code{split\_irradiance}}

Using the cache also helps with \code{split\_irradiance}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{)),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                          \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{split\_irradiance}, the cache reduces the median execution time from 0.591 ms to  0.406 ms, by 31\%.

Using hinges slows down calculations:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                          \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                          \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                          \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{split\_irradiance}, enabling use of hinges increases the median execution time from 0.391 ms to  0.742 ms,  by a factor of 1.898. There is less overhead than if calculating the same three wavebands separately, as all hinges are inserted in a single operation.

Disabling checking of the spectrum reduces the execution time, but proportionally not as much as for the \code{irradiance} functions, as the spectrum is checked only once independently of the number of bands into which it is split.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                          \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                          \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                          \hlkwc{use.cache}\hlstd{=}\hlnum{TRUE}\hlstd{,}
                          \hlkwc{check.spectrum}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{split\_irradiance}, disabling the data validation check reduces the median execution time from 0.398 ms to  0.368 ms, by 7.5\%.

As all the execution times are in milliseconds, all the optimizations discussed above are totally irrelevant unless you are planning to repeat similar calculations on thousands of spectra. They apply only to the machine, OS and version of R and packages used when building this typeset output.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(sun.data)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Preliminary tests of spectral objects}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{list}\hlstd{(}\hlkwd{UVC}\hlstd{(),} \hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{(),} \hlkwd{PAR}\hlstd{()),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{q\_irrad\_spct} with one waveband the time is 0.212 ms and it increases to 0.571 ms, by 2.7 times when with four wavebands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{q\_irrad\_spct} time  is 0.312 ms.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{q\_irrad\_spct} with cache enabled is 0.216 ms and it increases to 0.267 ms, by 1.23 times when with cacheing disabled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{FALSE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using \code{q\_irrad\_spct} with cache enabled is 0.227 ms and it increases to 0.418 ms, by 1.85 times when with cacheing disabled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{,} \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\code{q\_irrad\_spct} without hinges enabled (the default when the wavelength step $\Delta \lambda < 1.1 \Unit{nm}$) takes 0.22 ms but the execution time increases to 2.39 ms, by 9.83 times with use of hinges enabled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.037e-07 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.037e-07 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{CIE}\hlstd{(),} \hlkwc{use.cached.mult}\hlstd{=}\hlnum{TRUE}\hlstd{,} \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## 2.038e-07 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

The differnce in the returned value is rather small.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cp_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{res1} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlstd{sun_out.spct} \hlkwb{<-} \hlstd{cp_sun.spct} \hlopt{*} \hlnum{2} \hlopt{+} \hlstd{cp_sun.spct,}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res2} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlstd{sun_out.spct} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data, s.e.irrad} \hlopt{*} \hlnum{2} \hlopt{+} \hlstd{s.e.irrad),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res3} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlstd{sun_out.spct} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.dt, s.e.irrad} \hlopt{*} \hlnum{2} \hlopt{+} \hlstd{s.e.irrad),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res4} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlstd{sun_out.spct} \hlkwb{<-} \hlkwd{with}\hlstd{(cp_sun.spct, s.e.irrad} \hlopt{*} \hlnum{2} \hlopt{+} \hlstd{s.e.irrad),}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\hlstd{res5} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
  \hlstd{sun_out.spct} \hlkwb{<-} \hlstd{cp_sun.spct[ , s.e.irrad} \hlkwb{:=} \hlstd{s.e.irrad} \hlopt{*} \hlnum{2} \hlopt{+} \hlstd{s.e.irrad],}
  \hlkwc{times}\hlstd{=}\hlnum{100L}\hlstd{,} \hlkwc{control}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{warmup} \hlstd{=} \hlnum{10L}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
When using operators with spectral objects execution time is 3.62 ms and it decreases to 0.011 ms, to 0.305 \% when using operators on vectors in a data frame, to 0.0122 ms, to 0.336 \% when using operators on vectors in a data table, to 0.0122 ms, to 0.336 \% when using operators on vectors in a \texttt{source.spct}, and to 0.487 ms, to 13.4 \% when using data table syntax in a \texttt{source.spct}.

%%%%
\section{Profiling}\label{sec:perf:profiling}

Profiling is basically fine-grained benchmarking. It provides information about in which part of your code the program spends most time when executing. Once you know this, you can try to just make those critical sections execute faster. Speed-ups can be obtained either by rewriting these parts in a compiled language like C or C++, or by use of a more efficient calculation algorithm. A detailed discussion is outside the scope of this handbook, so only a brief example will be shown here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(profr)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{profr.df} \hlkwb{<-} \hlkwd{profr}\hlstd{(\{}\hlkwd{q_irrad_spct}\hlstd{(sun.spct)\},}
                  \hlkwc{interval} \hlstd{=} \hlnum{0.0005}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(profr.df)}
\hlkwd{ggplot}\hlstd{(profr.df)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{profr.df} \hlkwb{<-} \hlkwd{profr}\hlstd{(\{}\hlkwd{q_irrad_spct}\hlstd{(sun.spct, my_PAR,} \hlkwc{use.hinges}\hlstd{=}\hlnum{TRUE}\hlstd{)\},}
                  \hlkwc{interval} \hlstd{=} \hlnum{0.0001}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(profr.df)}
\hlkwd{ggplot}\hlstd{(profr.df)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{profr.df} \hlkwb{<-} \hlkwd{profr}\hlstd{(\{}\hlkwd{q_irrad_spct}\hlstd{(sun.spct, my_PAR,} \hlkwc{use.hinges}\hlstd{=}\hlnum{FALSE}\hlstd{)\},}
                  \hlkwc{interval} \hlstd{=} \hlnum{0.0001}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(profr.df)}
\hlkwd{ggplot}\hlstd{(profr.df)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{profr.df} \hlkwb{<-} \hlkwd{profr}\hlstd{(\{}\hlkwd{tag}\hlstd{(my_sun.spct)\},}
                  \hlkwc{interval} \hlstd{=} \hlnum{0.005}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(profr.df)}
\end{alltt}
\begin{verbatim}
##    level g_id t_id                f start   end n
## 36     1    1    1              tag  0.00 0.225 1
## 37     2    1    1  tag.source.spct  0.00 0.225 1
## 38     3    1    1 tag.generic.spct  0.00 0.225 1
## 39     4    1    1     w_length2rgb  0.00 0.220 1
## 40     4    2    1                [  0.22 0.225 1
## 41     5    1    1    s_e_irrad2rgb  0.00 0.085 1
##     leaf  time       source
## 36 FALSE 0.225 photobiology
## 37 FALSE 0.225 photobiology
## 38 FALSE 0.225 photobiology
## 39 FALSE 0.220 photobiology
## 40 FALSE 0.005         base
## 41 FALSE 0.085 photobiology
\end{verbatim}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(profr.df)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-161} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{Rprof}\hlstd{(}\hlstr{"profile1.out"}\hlstd{,} \hlkwc{line.profiling}\hlstd{=}\hlnum{TRUE}\hlstd{,} \hlkwc{interval} \hlstd{=} \hlnum{0.002}\hlstd{)}
\hlkwd{tag}\hlstd{(my_sun.spct)}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad s.q.irrad wl.color wb.f
##   1:      293 2.610e-06 6.392e-12  #000000   NA
##   2:      294 6.142e-06 1.510e-11  #000000   NA
##   3:      295 2.176e-05 5.366e-11  #000000   NA
##   4:      296 6.780e-05 1.678e-10  #000000   NA
##   5:      297 1.533e-04 3.807e-10  #000000   NA
##  ---                                           
## 504:      796 4.081e-01 2.715e-06  #000000   NA
## 505:      797 4.141e-01 2.759e-06  #000000   NA
## 506:      798 4.236e-01 2.826e-06  #000000   NA
## 507:      799 4.186e-01 2.796e-06  #000000   NA
## 508:      800 4.069e-01 2.721e-06  #000000   NA
\end{verbatim}
\begin{alltt}
\hlkwd{Rprof}\hlstd{(}\hlkwa{NULL}\hlstd{)}
\hlkwd{summaryRprof}\hlstd{(}\hlstr{"profile1.out"}\hlstd{,} \hlkwc{lines} \hlstd{=} \hlstr{"show"}\hlstd{)[[}\hlstr{"by.line"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
##                    self.time self.pct total.time
## <no location>          0.006     2.59      0.006
## s.e.irrad2rgb.r#36     0.020     8.62      0.020
## tag.spct.r#8           0.000     0.00      0.226
## tag.spct.r#155         0.206    88.79      0.226
##                    total.pct
## <no location>           2.59
## s.e.irrad2rgb.r#36      8.62
## tag.spct.r#8           97.41
## tag.spct.r#155         97.41
\end{verbatim}
\begin{alltt}
\hlcom{# profr.df <- parse_rprof("profile1.out")}
\hlcom{# head(profr.df)}
\hlcom{# ggplot(profr.df)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{profr)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{microbenchmark)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\end{alltt}
\end{kframe}
\end{knitrout}

\appendix
\part{Appendixes}



\chapter{R as a powerful calculator}\label{chap:R:as:calc}

\section{Working in the R console}

I assume that you are already familiar with RStudio. These examples use only the console window, and results a printed to the console. The values stored in the different variables are also visible in the Environment tab in RStudio.

In the console can type commands at the \texttt{>} prompt.
When you end a line by pressing the return key, if the line can be interpreted as an R command, the result will be printed in the console, followed by a new \texttt{>} prompt.
If the command is incomplete a \texttt{+} continuation prompt will be shown, and you will be able to type-in the rest of the command. For example if the whole calculation that you would like to do is $1 + 2 + 4$, if you enter in the console \texttt{1 + 2 +} in one line, you will get a continuation prompt where you will be able to type \texttt{3}. However, if you type \texttt{1 + 2}, the result will be calculated, and printed.

When working at the command prompt, results are printed by default, but other cases you may need to use the function \texttt{print} explicitly. The examples here rely on the automatic printing.

The idea with these examples is that you learn by working out how different commands work based on the results of the example calculations listed. The examples are designed so that they allow the rules, and also a few quirks, to be found by `detective work'. This should hopefully lead to better understanding than just studying rules.

\section{Examples with numbers}

When working with arithmetic expression the normal precedence rules are followed and parentheses can be used to alter this order. In addition parentheses can be nested.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{2} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlnum{2} \hlopt{+} \hlnum{10} \hlopt{/} \hlnum{5}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlstd{(}\hlnum{2} \hlopt{+} \hlnum{10}\hlstd{)} \hlopt{/} \hlnum{5}
\end{alltt}
\begin{verbatim}
## [1] 2.4
\end{verbatim}
\begin{alltt}
\hlnum{10}\hlopt{^}\hlnum{2} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 101
\end{verbatim}
\begin{alltt}
\hlkwd{sqrt}\hlstd{(}\hlnum{9}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlstd{pi} \hlcom{# whole precision not shown when printing}
\end{alltt}
\begin{verbatim}
## [1] 3.142
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(pi,} \hlkwc{digits}\hlstd{=}\hlnum{22}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3.141592653589793115998
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)} \hlcom{# oops! Read on for explanation.}
\end{alltt}
\begin{verbatim}
## [1] 1.225e-16
\end{verbatim}
\begin{alltt}
\hlkwd{log}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 4.605
\end{verbatim}
\begin{alltt}
\hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{log2}\hlstd{(}\hlnum{8}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{exp}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2.718
\end{verbatim}
\end{kframe}
\end{knitrout}

One can use variables to store values. Variable names and all other names in R are case sensitive. Variables \texttt{a} and \texttt{A} are two different variables. Variable names can be quite long, but usually it is not a good idea to use very long names. Here I am using very short names, that is usually a very bad idea. However, in cases like these examples where the stored values have no real connection to the real world and are used just once or twice, these names emphasize the abstract nature.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlstd{a} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{10}
\hlstd{b} \hlkwb{<-} \hlstd{a} \hlopt{+} \hlstd{b}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\begin{alltt}
\hlnum{3e-2} \hlopt{*} \hlnum{2.0}
\end{alltt}
\begin{verbatim}
## [1] 0.06
\end{verbatim}
\end{kframe}
\end{knitrout}

There are some syntactically legal statements that are not very frequently used, but you should be aware that they are valid, as they will not trigger error messages, and may surprise you. The important thing is that you write commands consistently. \texttt{1 -> a} is valid but almost never used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstd{b} \hlkwb{<-} \hlstd{c} \hlkwb{<-} \hlnum{0.0}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlkwb{->} \hlstd{a}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{=} \hlnum{3}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

Numeric variables can contain more than one value. Even single numbers are vectors of length one. We will later see why this is important. As you have seen above the results of calculations were printed preceded with \texttt{[1]}. This is the index or position in the vector of the first number (or other value) displayed at the head of the line.

One can use \texttt{c} `concatenate' to create a vector of numbers from individual numbers.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{,}\hlnum{2}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,}\hlnum{5}\hlstd{,}\hlnum{0}\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0
\end{verbatim}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b)}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2 4 5 0
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{c}\hlstd{(b, a)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

One can also create sequences, or repeat values:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlopt{-}\hlnum{1}\hlopt{:}\hlnum{5}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] -1  0  1  2  3  4  5
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{5}\hlopt{:-}\hlnum{1}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  5  4  3  2  1  0 -1
\end{verbatim}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{to} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{by} \hlstd{=} \hlnum{0.1}\hlstd{)}
\hlstd{c}
\end{alltt}
\begin{verbatim}
##  [1] -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 -0.4 -0.3 -0.2
## [10] -0.1  0.0  0.1  0.2  0.3  0.4  0.5  0.6  0.7
## [19]  0.8  0.9  1.0
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{-}\hlnum{5}\hlstd{,} \hlnum{4}\hlstd{)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] -5 -5 -5 -5
\end{verbatim}
\end{kframe}
\end{knitrout}

Now something that makes R different from most other programming languages: vectorized arithmetic.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1} \hlcom{# we add one to vector a defined above}
\end{alltt}
\begin{verbatim}
## [1] 0 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{(a} \hlopt{+} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1]  0  2  4  6  8 10 12
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 4 4 4 4 4 4 4
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{-} \hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 0 0 0 0 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

It can be seen in first line above, another peculiarity of R, that frequently called recycling: as vector \texttt{a} is of length 6, but the constant 1 is a vector of length 1, this 1 is extended by recycling into a vector of the same length as the longest vector in the statement.

Make sure you understand what calculations are taking place in the chunk above, and also the one below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1 1 1 1 1 1
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 2 3 2 3 2 3
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{3}
\end{alltt}
\begin{verbatim}
## [1] 2 3 4 2 3 4
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{4}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: longer object length is not a multiple of shorter object length}}\begin{verbatim}
## [1] 2 3 4 5 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}


A couple on useful things to know: a vector can have length zero. One can remove variables from the workspace with \texttt{rm}. One can use \texttt{ls()} to list all objects in the environment, or by supplying a \code{pattern} argument, only the objects with names matching the \code{pattern}. The pattern is given as a regular expression, with \verb|[]| enclosing alternative matching characters, \verb|^| and \verb|$| indicating the extremes of the name. For example \verb|"^z$"| matches only the single character `z' while \verb|"^z"| matches any name starting with `z'. In contrast \verb|"^[zy]$"| matches both `z' and `y' but neither `zy' nor `yz', and \verb|"^[a-z]"| matches any name starting with a lower case ASCII letter. If you are using RStudio, all objects are listed in the Environment pane, and the search box of the panel can be used to find a given object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)}
\hlstd{z}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\begin{alltt}
\hlkwd{ls}\hlstd{(}\hlkwc{pattern}\hlstd{=}\hlstr{"^z$"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "z"
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(z)}
\hlstd{z}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: object 'z' not found}}\begin{alltt}
\hlkwd{ls}\hlstd{(}\hlkwc{pattern}\hlstd{=}\hlstr{"^z$"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

There are some special values available for numbers. \texttt{NA} meaning `not available' is used for missing values. Calculations can yield also the following values \texttt{NaN} `not a number', \texttt{Inf} and \texttt{-Inf} for $\infty$ and $-\infty$. As you will see below, calculations yielding these values do \textbf{not} trigger errors or warnings, as they are arithmetically valid.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{NA}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlopt{-}\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] -Inf
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{/} \hlnum{Inf}
\end{alltt}
\begin{verbatim}
## [1] NaN
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{+} \hlnum{4}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\end{kframe}
\end{knitrout}

One thing to be aware of, and which we will discuss again later, is that numbers in computers are almost always stored with finite precision. This means that they not always behave as Real numbers as defined in mathematics. In R the usual numbers are stored as \textt{double-precision floats}, which means that there are limits to the largest and smallest numbers that can be represented (approx. $-1 \cdot 10^{308}$ and $1 \cdot 10^{308})$, and the number of significant digits that can be stored (usually described as $\epsilon$ (epsilon, abbreviated \texttt{eps}, defined as the largest number for which $ 1 + \epsilon = 1$)). This can be sometimes important, and can generate unexpected results in some cases, especially when testing for equality. In the example below, the result of the subtraction is still exactly 1. \label{par:float}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

It is usually safer not to test for equality to zero when working with numeric values. One alternative is comparing against a suitably small number, which will depend on the situation, although \code{eps} is usualy a safe bet, unless the expected range of values is known to be small.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{abs}\hlstd{(x)} \hlopt{<} \hlstd{eps}
\hlkwd{abs}\hlstd{(x)} \hlopt{<} \hlnum{1e-100}
\end{alltt}
\end{kframe}
\end{knitrout}

The same applies to tests for equality, so whenever possible according to the logic of the calculations, it is best to test for inequalities, for example using \verb|x <= 1.0| instead of \verb|x == 1.0|. If this is not possible, then the tests should be treated as above, for example replacing \verb|x == 1.0| with \verb|abs(x - 1.0) < eps|.

When comparing integer values these problems do not exist, as integer arithmetic is not afected by loss of precision in  calculations restricted to integers (the \code{L} comes from `long' a name sometimes used for a machine represenation of intergers):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1L} \hlopt{+} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{*} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{%/%} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{/} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0.3333
\end{verbatim}
\end{kframe}
\end{knitrout}

The last example above, using the `usual' division operator yields a floating-point \code{numeric} result, while the integer division operator \verb|%/%| yields an integer result.

\section{Examples with logical values}

What in maths are usually called Boolean values, are called \texttt{logical} values in R. They can have only two values \texttt{TRUE} and \texttt{FALSE}, in addition to \texttt{NA}. They are vectors. There are also logical operators that allow boolean algebra (and some support for set operations that we will not describe here).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{TRUE}
\hlstd{b} \hlkwb{<-} \hlnum{FALSE}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlopt{!}\hlstd{a} \hlcom{# negation}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&&} \hlstd{b} \hlcom{# logical AND}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{||} \hlstd{b} \hlcom{# logical OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Again vectorization is possible. I present this here, and will come back again to this, because this is one of the most troublesome aspects of the R language. The two types of `equivalent' logical operators behave very differently, but use very similar syntax! The vectorized operators have single-character names \verb|&| and \verb:|:, while the non vectorized ones have two double-character names \verb|&&| and \verb:||:. There is only one version of the negation operator \verb|!| that is vectorized.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{FALSE}\hlstd{)}
\hlstd{b} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlcom{# vectorized AND}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{|} \hlstd{b} \hlcom{# vectorized OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&&} \hlstd{b} \hlcom{# not vectorized}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{||} \hlstd{b} \hlcom{# not vectorized}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions \code{any} and \code{all} take a logical vector as argument, and return a single logical value `summarizing' the logical values in the vector. \code{all} returns \code{TRUE} only if every value in the argument is \code{TRUE}, and \code{any} returns \code{TRUE} unless every value in the argument is \code{FALSE}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{any}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(a} \hlopt{&} \hlstd{b)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a} \hlopt{&} \hlstd{b)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Another important thing to know about logical operators is that they `short-cut' evaluation. If the result is known from the first part of the statement, the rest of the statement is not evaluated. Try to understand what happens when you enter the following commands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{TRUE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

When using the vectorized operators on vectors of length greater than one, `short-cut' evaluation still applies for the result obtained.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlopt{&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{|} \hlstd{b} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Comparison operators}

Comparison operators yield as a result logical values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1.2} \hlopt{>} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{>=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{==} \hlnum{1.0} \hlcom{# be aware that here we use two = symbols}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{!=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{20}
\hlstd{a} \hlopt{<} \hlnum{100} \hlopt{&&} \hlstd{a} \hlopt{>} \hlnum{10}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Again these operators can be used on vectors of any length, the result is a logical vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{a} \hlopt{>} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{<} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{==} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlstd{a} \hlopt{>} \hlnum{5}
\hlstd{b}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Be once more aware of `short-cut evaluation'. If the result would not be affected by the missing value then the result is returned. If the presence of the NA makes the end result unknown, then NA is returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlstd{c} \hlopt{>} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE    NA
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{is.na}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.na}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(}\hlkwd{is.na}\hlstd{(c))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(}\hlkwd{is.na}\hlstd{(c))}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

This behaviour can be changed by using the optional argument \texttt{na.rm} which removes NA values \textbf{before} the function is applied. (Many functions in R have this optional parameter.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

You may skip this on first read, see page \pageref{par:float}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1e20} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{0} \hlopt{==} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

In many situations, when writing programs one should avoid testing for equality of floating point numbers (`floats'). Here we show how to handle gracefully rounding errors.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{==} \hlnum{0.0} \hlcom{# may not always work}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(a)} \hlopt{<} \hlnum{1e-15} \hlcom{# is safer}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)} \hlopt{==} \hlnum{0.0} \hlcom{# angle in radians, not degrees!}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)} \hlopt{==} \hlnum{0.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)}
\end{alltt}
\begin{verbatim}
## [1] 1.225e-16
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)}
\end{alltt}
\begin{verbatim}
## [1] -2.449e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.eps} \hlcom{# see help for .Machine for explanation}
\end{alltt}
\begin{verbatim}
## [1] 2.22e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.neg.eps}
\end{alltt}
\begin{verbatim}
## [1] 1.11e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Character values}

Character variables can be used to store any character. Character constants are written by enclosing characters in quotes. There are three types of quotes in the ASCII character set, double quotes \texttt{"}, single quotes \texttt{'}, and back ticks \texttt{`}. The first two types of quotes can be used for delimiting characters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstr{"A"}
\hlstd{b} \hlkwb{<-} \hlstd{letters[}\hlnum{2}\hlstd{]}
\hlstd{c} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlstd{]}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] "b"
\end{verbatim}
\begin{alltt}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] "a"
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b, c)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] "A" "b" "a"
\end{verbatim}
\begin{alltt}
\hlstd{e} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b,} \hlstr{"c"}\hlstd{)}
\hlstd{e}
\end{alltt}
\begin{verbatim}
## [1] "A" "b" "c"
\end{verbatim}
\begin{alltt}
\hlstd{h} \hlkwb{<-} \hlstr{"1"}
\hlstd{h} \hlopt{+} \hlnum{2}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: non-numeric argument to binary operator}}\end{kframe}
\end{knitrout}

Vectors of characters are not the same as character strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{f} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"1"}\hlstd{,} \hlstr{"2"}\hlstd{,} \hlstr{"3"}\hlstd{)}
\hlstd{g} \hlkwb{<-} \hlstr{"123"}
\hlstd{f} \hlopt{==} \hlstd{g}
\end{alltt}
\begin{verbatim}
## [1] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{f}
\end{alltt}
\begin{verbatim}
## [1] "1" "2" "3"
\end{verbatim}
\begin{alltt}
\hlstd{g}
\end{alltt}
\begin{verbatim}
## [1] "123"
\end{verbatim}
\end{kframe}
\end{knitrout}

One can use the `other' type of quotes as delimiter when one want to include quotes in a string. Pretty-printing is changing what I typed into how the string is stored in R: I typed \texttt{b <- 'He said "hello" when he came in'}, try it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstr{"He said 'hello' when he came in"}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] "He said 'hello' when he came in"
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlstr{'He said "hello" when he came in'}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] "He said \"hello\" when he came in"
\end{verbatim}
\end{kframe}
\end{knitrout}

The outer quotes are not part of the string, they are `delimiters' used to mark the boundaries. As you can see when \texttt{b} is printed special characters can be represented using `escape sequences'. There are several of them, and here we will show just a few.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlstr{"abc\textbackslash{}ndef\textbackslash{}txyz"}
\hlkwd{print}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
## [1] "abc\ndef\txyz"
\end{verbatim}
\begin{alltt}
\hlkwd{cat}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
## abc
## def	xyz
\end{verbatim}
\end{kframe}
\end{knitrout}

Above, you will not see any effect of these escapes when using \code{print}: \verb|\n| represents `new line' and \verb|\t| means `tab' (tabulator). The \textit{scape codes} work only in some contexts, as when using \code{cat} to generate the output. They also are very useful when one wants to split an axis-label, title or label in a plot into two or more lines.


\section{Type conversions}

The least intuitive ones are those related to logical values. All others are as one would expect.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "1"
\end{verbatim}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{3.0e10}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "3e+10"
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"1"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"5E+5"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 5e+05
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"A"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: NAs introduced by coercion}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{+} \hlnum{TRUE}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{+} \hlnum{FALSE}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"T"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"t"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"TRUE"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"true"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{f} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"1"}\hlstd{,} \hlstr{"2"}\hlstd{,} \hlstr{"3"}\hlstd{)}
\hlstd{g} \hlkwb{<-} \hlstr{"123"}
\hlkwd{as.numeric}\hlstd{(f)}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(g)}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

Some tricks useful when dealing with results. Be aware that the printing is being done by default, these functions return numerical values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.01246
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.0125
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1789
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1790
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{0.12345}
\hlstd{b} \hlkwb{<-} \hlkwd{round}\hlstd{(a,} \hlnum{2}\hlstd{)}
\hlstd{a} \hlopt{==} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{-} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.00345
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.12
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Vectors}

You already know how to create a vector. Now we are going to see how to get individual numbers out of a vector. They are accessed using an index. The index indicates the position in the vector, starting from one, following the usual mathematical tradition. What in maths would be $x_i$ for a vector $x$, in R is represented as \texttt{x[i]}. (In R indexes (or subscripts) always start from one, while in some other programming languages indexes start from zero.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{a}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "b"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "c" "b"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "j" "i" "h" "g" "f" "e" "d" "c" "b" "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

The examples below demonstrate what is the result of using a longer vector of indexes than the indexed vector. The length of the indexing vector has no restriction, but the acceptable range of values for the indexes is given by the length of the indexed vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "c" "c" "c" "c"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##  [1] "j" "i" "h" "g" "f" "e" "d" "c" "b" "a" "a"
## [12] "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

Negative indexes have a special meaning, they indicate the positions at which values should be excluded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlopt{-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlopt{-}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

Results from indexing with out-of-range values may be surprising.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlnum{11}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{1}\hlopt{:}\hlnum{11}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Results from indexing with special values may be surprising.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[ ]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{NA}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] NA NA NA NA NA NA NA NA NA NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{NA}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlkwa{NULL}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

Another way of indexing, which is very handy, but not available in most other programming languages, is indexing with a vector of logical values. In practice, the vector of logical values used for `indexing' is in most cases of the same length as the vector from which elements are going to be selected. However, this is not a requirement, and if the logical vector is shorter it is `recycled' as discussed above in relation to operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlnum{TRUE}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{FALSE}\hlstd{]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "e" "g" "i"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "b" "d" "f" "h" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{>} \hlstr{"c"}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a[a} \hlopt{>} \hlstr{"c"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{selector} \hlkwb{<-} \hlstd{a} \hlopt{>} \hlstr{"c"}
\hlstd{a[selector]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlkwd{which}\hlstd{(a} \hlopt{>} \hlstr{"c"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{indexes} \hlkwb{<-} \hlkwd{which}\hlstd{(a} \hlopt{>} \hlstr{"c"}\hlstd{)}
\hlstd{a[indexes]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{b[selector]}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{b[indexes]}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Simple built-in statistical functions}

Being R's main focus in statistics, it provides functions for both simple and complex calculations, going from means and variances to fitting very complex models. we will start with the simple ones.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{20}
\hlkwd{mean}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 10.5
\end{verbatim}
\begin{alltt}
\hlkwd{var}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 35
\end{verbatim}
\begin{alltt}
\hlkwd{median}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 10.5
\end{verbatim}
\begin{alltt}
\hlkwd{mad}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 7.413
\end{verbatim}
\begin{alltt}
\hlkwd{sd}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 5.916
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1]  1 20
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 20
\end{verbatim}
\begin{alltt}
\hlkwd{min}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 20
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Functions and execution flow control}

Although functions can be defined and used at the command prompt, we will discuss them when looking at scripts. We will do the same in the case of flow-control statements (e.g. repetition and conditional execution).





\chapter{R Scripts and Programming}\label{chap:R:scripts}

\section{What is a script?}

We call \textit{script} to a text file that contains the same commands that you would type at the console prompt. A true script is not for example an MS-Word file where you have pasted or typed some R commands. A script file has the following characteristics.
\begin{itemize}
  \item The script is a text file (ASCII or some other encoding e.g. UTF-8 that R uses in your set-up).
  \item The file contains valid R statements (including comments) and nothing else.
  \item Comments start at a \texttt{\#} and end at the end of the line. (True end-of line as coded in file, the editor may wrap it or not at the edge of the screen).
  \item The R statements are in the file in the order that they must be executed.
  \item R scripts have file names ending in \texttt{.r}
\end{itemize}

It is good practice to write scripts so that they will run in a new R session, which means that the script should include library commands to load all the required packages.



\section{How do we use a scrip?}

A script can be sourced.

If we have a text file called \texttt{my.first.script.r}
\begin{verbatim}
# this is my first R script
print(3+4)
\end{verbatim}

And then source this file:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{source}\hlstd{(}\hlstr{"my.first.script.r"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\end{kframe}
\end{knitrout}

The results of executing the statements contained in the file will appear in the console. The commands themselves are not shown (the sourced file is not echoed) and the results will not be printed unless you include an explicit \texttt{print} command. This also applies in many cases also to plots. A fig created with \texttt{ggplot} needs to be printed if we want to see it when the script is run.

From within RStudio, if you have an R script open in the editor, there will a ``source'' drop box ($\neq$ DropBox) visible from where you can choose ``source'' as described above, or ``source with echo'' for the currently open file.

When a script is sourced, the output can be saved to a text file instead of being shown in the console. It is also easy to call R with the script file as argument directly at the command prompt of the operating system.

\begin{verbatim}
RScript my.first.script.r
\end{verbatim}

You can open a `shell' from the Tools menu in RStudio, to run this command. The output will be printed to the shell console. If you would like to save the output to a file, use redirection.

\begin{verbatim}
RScript my.first.script.r > my.output.txt
\end{verbatim}

Sourcing is very useful when the script is ready, however, while developing a script, or sometimes when testing things, one usually wants to run ($=$ execute) one or a few statements at a time. This can be done using the ``run'' button after either locating the cursor in the line to be executed, or selecting the text that one would like to run (the selected text can be part of a line, a whole line, or a group of lines, as long as it is syntactically valid).

\section{How to write a script?}

The approach used, or mix of approaches will depend on your preferences, and on how confident you are that the statements will work as expected.
\begin{description}
\item[If one is very familiar with similar problems] One would just create a new text file and write the whole thing in the editor, and then test it. This is rather unusual.
\item[If one if moderately familiar with the problem] One would write the script as above, but testing it, part by part as one is writing it. This is usually what I do.
\item[If ones mostly playing around] Then if one is using RStudio, one type statements at the console prompt. As you should know by now, everything you run at the console is saved to the ``History''. In RStudio the History is displayed in its own pane, and in this pane one can select any previous statement and by pressing a single having copy and pasted to either the console prompt, or the cursor position in the file visible in the editor. In this way one can build a script by copying and pasting from the history to your script file the bits that have worked as you wanted.
\end{description}

\section{The need to be understandable to people}

When you write a script, it is either because you want to document what you have done or you want re-use it at a later time. In either case, the script itself although still meaningful for the computer could become very obscure to you, and even more to someone seeing it for the first time.

How does one achieve an understandable script or program?
\begin{itemize}
  \item Avoid the unusual. People using a certain programming language tend to use some implicit or explicit rules of style. As a minimum try to be consistent with yourself.
  \item Use meaningful names for variables, and any other object. What is meaningful depends on the context. Depending on common use a single letter may be more meaningful than a long word. However self explaining names are better: e.g. using \texttt{n.rows} and \texttt{n.cols} is much clearer than using \texttt{n1} and \texttt{n2} when dealing with a matrix of data. Probably \texttt{number.of.rows} and \texttt{number.of.columns} would just increase the length of the lines in the script, and one would spend more time typing without getting much in return.
  \item How to make the words visible in names: traditionally in R one would use dots to separate the words and use only lower case. Some years ago, it became possible to use underscores. The use of underscores is quite common nowadays because in some contexts is ``safer'' as in special situations a dot may have a special meaning. What we call ``camel case'' is very rarely used in R programming but is common in other languages like Pascal. An example of camel case is \texttt{NumCols}. In some cases it can become a bit confusing as in \texttt{UVMean} or \texttt{UvMean}.
\end{itemize}

\section{Exercises}

By now you should be familiar enough with R to be able to write your own script.
\begin{enumerate}
  \item Create a new R script (in RStudio, from `File' menu, ``+'' button, or by typing ``Ctrl + Shift + N'').
  \item Save the file as ``my.second.script.r''.
  \item Use the editor pane in RStudio to type some R commands and comments.
  \item \textbf{Run} individual commands.
  \item \textbf{Source} the whole file.
\end{enumerate}

\section{Functions}

When writing scripts, or any program, one should avoid repeating code (groups of statements). The reasons for this are: 1) if the code needs to be changed, you have to make changes in more than one place in the file, or in more than one file. Sooner or later, some copies will remain unchanged by mistake. 2) it makes the script file longer, and this makes debugging, commenting, etc. more tedious, and error prone.

How do we avoid repeating bits of code? We write a function containing the statements that we would need to repeat, and then \texttt{call} the function in their place.

Functions are defined by means of \textbf{function}, and saved like any other object in R by assignment a variable. \texttt{x} is a parameter, the name used within the function for an object that will be supplied as ``argument'' when the function is called. One can think of parameter names as place-holders.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.prod} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{y}\hlstd{)\{x} \hlopt{*} \hlstd{y\}}
\hlkwd{my.prod}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 12
\end{verbatim}
\end{kframe}
\end{knitrout}

First some basic knowledge. In R, arguments are passed by copy. This is something very important to remember. Whatever you do within a function to the passed argument, its value outside the function will remain unchanged.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.change} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{x} \hlkwb{<-} \hlnum{NA}\hlstd{\}}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlkwd{my.change}\hlstd{(a)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

Any result that needs to be made available outside the function must be returned by the function. If the function \texttt{return} is not explicitly used, the value returned by the last statement within the body of the function will be returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{print.x.1} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.1}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.2} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{print}\hlstd{(x);} \hlkwd{return}\hlstd{(x)\}}
\hlkwd{print.x.2}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.3} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{(x);} \hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.3}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.4} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{();} \hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.4}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

We can assign to a variable defined outside a function with operator \texttt{<<-} but the usual recommendation is to avoid its use. This type of effects of calling a function are frequently called `side-effects'.

Now we will define a useful function: a function for calculating the standard error of the mean from a numeric vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x)}\hlopt{/}\hlkwd{length}\hlstd{(x))\}}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{5}\hlstd{)}
\hlstd{a.na} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

For example in \texttt{SEM(a)} we are calling function \texttt{SEM} with \texttt{a} as argument.

The function we defined above may sometimes give a wrong answer because NAs will be counted by \texttt{length}, so we need to remove NAs before calling \texttt{length}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)} \hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}\hlopt{/}\hlkwd{length}\hlstd{(}\hlkwd{na.omit}\hlstd{(x)))}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{5}\hlstd{)}
\hlstd{a.na} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\end{kframe}
\end{knitrout}

R does not have a function for standard error, so the function above would be generally useful. If we would like to make this function both safe, and consistent with other R functions, one could define it as follows, allowing the user to provide a second argument which is passed as an argument to \texttt{var}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{FALSE}\hlstd{)\{}\hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x,} \hlkwc{na.rm}\hlstd{=na.rm)}\hlopt{/}\hlkwd{length}\hlstd{(}\hlkwd{na.omit}\hlstd{(x)))\}}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na,} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a.na,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlnum{TRUE}\hlstd{, a.na)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: the condition has length > 1 and only the first element will be used}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{,} \hlkwc{x}\hlstd{=a.na)}
\end{alltt}
\begin{verbatim}
## [1] 1.797
\end{verbatim}
\end{kframe}
\end{knitrout}

In this example you can see that functions can have more than one parameter, and that parameters can have default values to be used if no argument is supplied. In addition if the name of the parameter is indicated, then arguments can be supplied in any order, but if parameter names are not supplied, then arguments are assigned to parameters based on their position. Once one parameter name is given, all later arguments need also to be explicitly matched to parameters. Obviously if given by position, then arguments should be supplied explicitly for all parameters at `intermediate' positions.

\section{R built-in functions}

\subsection{Plotting}

The built-in generic function \texttt{plot} can be used to plot data. It is a generic function, that has suitable methods for different kinds of objects.

Before we can plot anything, we need some data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(cars)}
\hlkwd{names}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
## [1] "speed" "dist"
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
## 3     7    4
## 4     7   22
## 5     8   16
## 6     9   10
\end{verbatim}
\begin{alltt}
\hlkwd{tail}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
##    speed dist
## 45    23   54
## 46    24   70
## 47    24   92
## 48    24   93
## 49    24  120
## 50    25   85
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{cars} is an example data set that is included in R. It is stored as a dataframe. Data frames are used for storing data, they consist in columns of equal length. The different columns can be different types (e.g. numeric and character). With \texttt{data} we load it; with \texttt{names} we obtain the names of the variables or columns. With head with can see the top several lines, and with tail the lines at the end.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data}\hlstd{=cars)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-2} 

}



\end{knitrout}

\subsection{Fitting linear models}

\subsubsection{Regression}

The R function \texttt{lm} is used next to fit a linear regression.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm1} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm1)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm1)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed, data = cars)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -29.07  -9.53  -2.27   9.21  43.20 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)
## (Intercept)  -17.579      6.758   -2.60    0.012
## speed          3.932      0.416    9.46  1.5e-12
##                
## (Intercept) *  
## speed       ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 15.4 on 48 degrees of freedom
## Multiple R-squared:  0.651,	Adjusted R-squared:  0.644 
## F-statistic: 89.6 on 1 and 48 DF,  p-value: 1.49e-12
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm1)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##           Df Sum Sq Mean Sq F value  Pr(>F)    
## speed      1  21185   21185    89.6 1.5e-12 ***
## Residuals 48  11354     237                    
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-11} 
\includegraphics[width=.95\textwidth]{figure/pos-models-12} 
\includegraphics[width=.95\textwidth]{figure/pos-models-13} 
\includegraphics[width=.95\textwidth]{figure/pos-models-14} 

}



\end{knitrout}

Let's look at each step separately: \texttt{dist ~ speed} is the specification of the model to be fitted. The intercept is always implicitly included. To `remove' this implicit intercept from the earlier model we can use \texttt{dist ~ speed - 1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm2} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm2)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm2)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed - 1, data = cars)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -26.18 -12.64  -5.46   4.59  50.18 
## 
## Coefficients:
##       Estimate Std. Error t value Pr(>|t|)    
## speed    2.909      0.141    20.6   <2e-16 ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 16.3 on 49 degrees of freedom
## Multiple R-squared:  0.896,	Adjusted R-squared:  0.894 
## F-statistic:  423 on 1 and 49 DF,  p-value: <2e-16
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##           Df Sum Sq Mean Sq F value Pr(>F)    
## speed      1 111949  111949     423 <2e-16 ***
## Residuals 49  12954     264                   
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-21} 
\includegraphics[width=.95\textwidth]{figure/pos-models-22} 
\includegraphics[width=.95\textwidth]{figure/pos-models-23} 
\includegraphics[width=.95\textwidth]{figure/pos-models-24} 

}



\end{knitrout}

We now we fit a second degree polynomial.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{),} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm3)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm3)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed + I(speed^2), data = cars)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -28.72  -9.18  -3.19   4.63  45.15 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)
## (Intercept)    2.470     14.817    0.17     0.87
## speed          0.913      2.034    0.45     0.66
## I(speed^2)     0.100      0.066    1.52     0.14
## 
## Residual standard error: 15.2 on 47 degrees of freedom
## Multiple R-squared:  0.667,	Adjusted R-squared:  0.653 
## F-statistic: 47.1 on 2 and 47 DF,  p-value: 5.85e-12
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm3)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##            Df Sum Sq Mean Sq F value  Pr(>F)    
## speed       1  21185   21185    92.0 1.2e-12 ***
## I(speed^2)  1    529     529     2.3    0.14    
## Residuals  47  10825     230                    
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-31} 
\includegraphics[width=.95\textwidth]{figure/pos-models-32} 
\includegraphics[width=.95\textwidth]{figure/pos-models-33} 
\includegraphics[width=.95\textwidth]{figure/pos-models-34} 

}



\end{knitrout}

We can also compare the two models.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm1)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: dist ~ speed - 1
## Model 2: dist ~ speed
##   Res.Df   RSS Df Sum of Sq    F Pr(>F)  
## 1     49 12954                           
## 2     48 11354  1      1600 6.77  0.012 *
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

Or three or more models. But be careful, as the order of the arguments matters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm1, fm3)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: dist ~ speed - 1
## Model 2: dist ~ speed
## Model 3: dist ~ speed + I(speed^2)
##   Res.Df   RSS Df Sum of Sq    F Pr(>F)  
## 1     49 12954                           
## 2     48 11354  1      1600 6.95  0.011 *
## 3     47 10825  1       529 2.30  0.136  
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use different criteria to choose the best model: significance based on $P$-values or information criteria (AIC, BIC) that penalize the result based on the number of parameters in the fitted model. In the case of AIC and BIC, a smaller value is better, and values returned can be either positive or negative, in which case more negative is better.

\section{Control of execution flow}

\subsection{Conditional execution}

\subsubsection{Non-vectorized}

R has two types of ``if'' statements, non-vectorized and vectorized. We will start with the non-vectorized one, which is similar to what is available in most other computer programming languages.

Before this we need to explain compound statements. Individual statements can be grouped into compound statements by enclosed them in curly braces.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{\{}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"C"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "B"
## [1] "C"
\end{verbatim}
\end{kframe}
\end{knitrout}

The example above is pretty useless, but becomes useful when used together with `control' constructs. The \texttt{if} construct controls the execution of one statement, however, this statement can be a compound statement of almost any length or complexity. Play with the code below by changing the value assigned to \texttt{printing}, including NA, and logical(0).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{printing} \hlkwb{<-} \hlnum{TRUE}
\hlkwa{if} \hlstd{(printing) \{}
  \hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\end{kframe}
\end{knitrout}

The condition `(\ \ )' can be anything yielding a logical vector, however, as this is not vectorized, only the first element will be used. Play with this example by changing the value assigned to \texttt{a}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{10.0}
\hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0.0}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"'a' is negative"}\hlstd{)} \hlkwa{else} \hlkwd{print}\hlstd{(}\hlstr{"'a' is not negative"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"This is always printed"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "This is always printed"
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see above the statement immediately following \texttt{else} is executed if the condition is false. Later statements are executed independently of the condition.

Do you still remember the rules about continuation lines?



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# 1}
\hlkwd{if} (a < 0.0)
  \hlkwd{print}(\hlstr{"\hlstr{'a'} is negative"}) else
    \hlkwd{print}(\hlstr{"\hlstr{'a'} is not negative"})
\hlcom{# 2 (not evaluated here)}
\hlkwd{if} (a < 0.0) \hlkwd{print}(\hlstr{"\hlstr{'a'} is negative"})
else \hlkwd{print}(\hlstr{"\hlstr{'a'} is not negative"})
\end{alltt}
\end{kframe}
\end{knitrout}

Why does only the second example above trigger an error?

Play with the use conditional execution, with both simple and compound statements, and also think how to combine \texttt{if} and \texttt{else} to select among more than two options.

There is in R a \texttt{switch} statement, that we will not describe here, that can be used to select among ``cases'', or several alternative statements, based on an expression evaluating to a number or a character string.

\subsusbsection{Vectorized}

The vectorized conditional execution is coded by means of a \textbf{function} called \texttt{ifelse} (one word). This function takes three arguments: a logical vector, a result vector for TRUE, a result vector for FALSE. All three can be any construct giving the necessary argument as their result. In the case of result vectors, recycling will apply if they are not of the correct length. \textcolor{red}{The length of the result is determined by the length of the logical vector in the first argument!}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{,} \hlnum{1}\hlstd{,} \hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] -1 -1 -1 -1 -1  1  1  1  1  1
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1]  0  1  2  3  4  7  8  9 10 11
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{any}\hlstd{(a}\hlopt{>}\hlnum{5}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# tricky}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{logical}\hlstd{(}\hlnum{0}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# even more tricky}
\end{alltt}
\begin{verbatim}
## logical(0)
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlnum{NA}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# as expected}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Try to understand what is going on in the previous example. Create your own examples to test how \texttt{ifelse} works.

Exercise: write using \texttt{ifelse} a single statement to combine numbers from a and b into a result vector d, based on whether the corresponding value in c is the character "a" or "b".

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{b} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{+}\hlnum{1}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{5}\hlstd{))}
\hlcom{# your code}
\end{alltt}
\end{kframe}
\end{knitrout}

If you do not understand how the three vectors are built, or you cannot guess the values they contain by reading the code, print them, and play with the arguments, until you have clear what each parameter does.

\subsection{Why using vectorized functions and operators is important}

If you have written programs in other languages, it would feel to you natural to use loops (for, repeat while, repeat until) for many of the things for which we have been using vectorization. When using the R language it is best to use vectorization whenever possible, because it keeps the listing of scripts and programs shorter and easier to understand (at least for those with experience in R). However, there is another very important reason: execution speed. The reason behind this is that R is an interpreted language. In current versions of R it is possible to byte-compile functions, but this is rarely used for scripts, and even byte-compiled loops are much slower and vectorized functions.

However, there are cases were we need to repeatedly execute statements in a way that cannot be vectorized, or when we do not need to maximize execution speed. The R language does have loop constructs, and we will describe them next.

\subsection{Repetition}

The most frequently used type of loop is a \texttt{for} loop. These loops work in R are based on lists or vectors of values to act upon.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0}
\hlkwa{for} \hlstd{(a} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{) b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{sum}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{)} \hlcom{# built-in function}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\end{kframe}
\end{knitrout}

Here the statement \texttt{b <- b + a} is executed five times, with a sequentially taking each of the values in \texttt{1:5}. Instead of a simple statement used here, also a compound statement could have been used.

Here are a few examples that show some of the properties of \texttt{for} loops and functions, combined with the use of a function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{test.for} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlstd{x) \{}\hlkwd{print}\hlstd{(i)\}}
\hlstd{\}}
\hlkwd{test.for}\hlstd{(}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{))}
\hlkwd{test.for}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
## [1] 2
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{NA}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{list}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"z"}\hlstd{, letters[}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{]))}
\end{alltt}
\begin{verbatim}
## [1] "z"
## [1] "a"
## [1] "b"
## [1] "c"
## [1] "d"
\end{verbatim}
\end{kframe}
\end{knitrout}

In contrast to other languages, in R function arguments are not checked for `type' when the function is called. The only requirement is that the function code can handle the argument provided. In this example you can see that the same function works with numeric and character vectors, and with lists. We haven't seen lists before. As earlier discussed all elements in a vector should have the same type. This is not the case for lists. It is also interesting to note that a list or vector of length zero is a valid argument, that triggers no error, but that as one would expect, causes the statements in the loop body to be skipped.

Some examples of use of \texttt{for} loops --- and of how to avoid there use.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) x}\hlopt{*}\hlnum{2} \hlcom{# result is lost}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a)} \hlkwd{print}\hlstd{(x}\hlopt{*}\hlnum{2}\hlstd{)} \hlcom{# print is needed!}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 8
## [1] 6
## [1] 12
## [1] 16
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) x}\hlopt{*}\hlnum{2} \hlcom{# doesn't work as expected, but triggers no error}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) b} \hlkwb{<-} \hlstd{x}\hlopt{*}\hlnum{2} \hlcom{# a bit of a surprise, as b is not a vector!}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 16
\end{verbatim}
\begin{alltt}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 1
## [1]  1 16
## [1]  1 16  9
## [1]  1 16  9 36
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlcom{# is a vector!}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlcom{# a bit faster if we first allocate a vector of the required length}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a))}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 1 0 0 0 0
## [1]  1 16  0  0  0
## [1]  1 16  9  0  0
## [1]  1 16  9 36  0
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlcom{# is a vector!}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlcom{# vectorization is simplest and fastest}
\hlstd{b} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\end{kframe}
\end{knitrout}

Look at the results from the above examples, and try to understand where does the returned value come from in each case.

We sometimes may not be able to use vectorization, or may be easiest to not use it. However, whenever working with large data sets, or many similar datasets, we will need to take performance into account. As vectorization usually also makes code simpler, it is good style to use it whenever possible.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{)}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=b)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 3 0 0 0
## [1]  3 -1  0  0
## [1]  3 -1  3  0
## [1]  3 -1  3  2
\end{verbatim}
\begin{alltt}
\hlcom{# although in this case there were alternatives, there}
\hlcom{# are other cases when we need to use indexes explicitly}
\hlstd{b} \hlkwb{<-} \hlstd{a[}\hlnum{2}\hlopt{:}\hlkwd{length}\hlstd{(a)]} \hlopt{-} \hlstd{a[}\hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{]}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  3 -1  3  2
\end{verbatim}
\begin{alltt}
\hlcom{# or even better}
\hlstd{b} \hlkwb{<-} \hlkwd{diff}\hlstd{(a)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  3 -1  3  2
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{seq(along=b)} builds a new numeric vector with a sequence of the same length as the length as the vector given as argument for parameter `along'.

\texttt{while} loops are quite frequently also useful. Instead of a list or vector, they take a logical argument, which is usually an expression, but which can also be a variable. For example the previous calculation could be also done as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlstd{i} \hlkwb{<-} \hlnum{1}
\hlkwa{while} \hlstd{(i} \hlopt{<} \hlkwd{length}\hlstd{(a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
  \hlstd{i} \hlkwb{<-} \hlstd{i} \hlopt{+} \hlnum{1}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1]  1 -1  3  2
## [1]  1 16  3  2
## [1]  1 16  9  2
## [1]  1 16  9 36
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36
\end{verbatim}
\end{kframe}
\end{knitrout}

Here is another example. In this case we use the result of the previous iteration in the current one. In this example you can also see, that it is allowed to put more than one statement in a single line, in which case the statements should be separated by a semicolon (;).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{while} \hlstd{(a} \hlopt{<} \hlnum{50}\hlstd{) \{}\hlkwd{print}\hlstd{(a); a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

Make sure that you understand why the final value of \texttt{a} is larger than 50.

\texttt{repeat} is seldom used, but adds flexibility as \texttt{break} can be in the middle of the compound statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{repeat}\hlstd{\{}
  \hlkwd{print}\hlstd{(a)}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
  \hlkwa{if} \hlstd{(a} \hlopt{>} \hlnum{50}\hlstd{) \{}\hlkwd{print}\hlstd{(a);} \hlkwa{break}\hlstd{()\}}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
## [1] 256
\end{verbatim}
\begin{alltt}
\hlcom{# or more elegantly}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{repeat}\hlstd{\{}
  \hlkwd{print}\hlstd{(a)}
  \hlkwa{if} \hlstd{(a} \hlopt{>} \hlnum{50}\hlstd{)} \hlkwa{break}\hlstd{()}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

Please, make sure you understand what is happening in the previous examples.

\subsection{Nesting}

All the execution-flow control statements seen above can be nested. We will show an example with two \texttt{for} loops. We first need a matrix of data to work with:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlnum{10}\hlstd{,} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlcom{# argument names used for clarity}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\end{kframe}
\end{knitrout}

All the statements above are equivalent, but some are easier to read than others.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# slower as size needs to be expanded}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{nrow}\hlstd{(A))} \hlcom{# faster}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

Look at the output of these two examples to understand what is happening differently with \texttt{row.sum}.

The code above is very general, it will work with any size of two dimensional matrix, which is good programming practice. However, sometimes we need more specific calculations. \texttt{A[1, 2]} selects one cell in the matrix, the one on the first row of the second column. \texttt{A[1, ]} selects row one, and  \texttt{A[ , 2]} selects column two. In the example above the value of \texttt{i} changes for each iteration of the outer loop. The value of \texttt{j} changes for each iteration of the inner loop, and the inner loop is run in full for each iteration of the outer loop. The inner loop index \texttt{j} changes fastest.

Exercises: 1) modify the example above to add up only the first three columns of A, 2) modify the example above to add the last three columns of A.

Will the code you wrote continue working as expected if the number of rows in A changed? and what if the number of columns in A changed, and the required results still needed to be calculated for relative positions? What would happen if A had fewer than three columns? Try to think first what to expect based on the code you wrote. Then create matrices of different sizes and test your code. After that think how to improve the code, at least so that wrong results are not produced.

Vectorization can be achieved in this case easily for the inner loop.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{nrow}\hlstd{(A))} \hlcom{# faster}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlkwd{sum}\hlstd{(A[i, ])}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{A[i, ]} selects row \texttt{i} and all columns. In R, the row index always comes first, which is not the case in all programming languages.

Full vectorization can be achieved with \texttt{apply} functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{apply}\hlstd{(A,} \hlkwc{MARGIN} \hlstd{=} \hlnum{1}\hlstd{, sum)} \hlcom{# MARGIN=1 inidcates rows}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

How would you change this last example, so that only the last three columns are added up? (Think about use of subscripts to select a part of the matrix.)

There are many variants of \texttt{apply} functions, both in base R and in contributed packages.

\section{Packages}

In R speak `library' is the location where `packages' are installed. Packages are sets of functions, and data, specific for some particular purpose, that can be loaded into an R session to make them available so that they can be used in the same way as built-in R functions and data. The function \texttt{library} is used to load packages, already installed in the local R library, into the current session, while the function \texttt{install.packages} is used to install packages, either from a file, or directly from the internet into the library. When using RStudio it is easiest to use RStudio commands (which call \texttt{install.packages} and \texttt{update.packages}) to install and update packages.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(graphics)}
\end{alltt}
\end{kframe}
\end{knitrout}

Currently there are thousands of packages available. The most reliable source of packages is CRAN, as only packages that pass strict tests and are actively maintained are included. In some cases you may need or want to install less stable code, and this is also possible.

R packages can be installed either from source, or from already built `binaries'. Installing from sources, depending on the package, may require quite a lot of additional software to be available. Under MS-Windows, very rarely the needed shell, commands and compilers are already available. Installing then is not too difficult (you will need RTools, and MiKTeX). For this reason it is the norm to install packages from binary .zip files. Under Linux most tools will be available, or very easy to install, so it is not unusual to install from sources. For OS X (Mac) the situation is somewhere in-between. If the tools are available, packages can be very easily installed from source from within RStudio.

The development of packages is beyond the scope of the current course, but it is still interesting to know a few things about packages. Using RStudio it is relatively easy to develop your own packages. Packages can be of very different sizes. Packages use a relatively rigid structure of folder for storing the different types of files, and there is a built-in help system, that one needs to use, so that the package documentation gets linked to the R help system when the package is loaded. In addition to R code, packages can call C, C++, FORTRAN, Java, etc. functions and routines, but some kind of `glue' is needed, as data is stored differently. At least for C++, the recently developed Rcpp R package makes the gluing extremely easy.

In addition to some packages from CRAN, later in the course we will use a suite of packages for photobiology that I have developed during the last couple of years. Some of the functions in these packages are very simple, and others more complex. In one of the packages, I included some C++ functions to improve performance. Replacing some R for loops with C++ for loops and iterators, resulted in a huge speed increase. The reason for this is that R is an interpreted language and C++ is compiled into machine code. Recent versions of R allow byte-compilation which can give some speed improvement, without need to switch to another language.

The source code for the photobiology and many other packages is freely available, so if you are interested you can study it. For any function defined in R, typing at the command prompt the name of the function without the parentheses lists the code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{length}  \hlcom{# a function defined in C within R itself}
\end{alltt}
\begin{verbatim}
## function (x)  .Primitive("length")
\end{verbatim}
\begin{alltt}
\hlstd{SEM} \hlcom{# the function we defined earlier}
\end{alltt}
\begin{verbatim}
## function(x, na.rm=FALSE){sqrt(var(x, na.rm=na.rm)/length(na.omit(x)))}
\end{verbatim}
\end{kframe}
\end{knitrout}

One good way of learning how R works, is by experimenting with it, and whenever using a certain function looking at the help, to check what are all the available options.







\chapter{Making publication quality plots with R}\label{chap:R:plotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library, the last three packages seem to interfere with each other, in particular GGally does not function in ggtern is loaded, so the are loaded only in the sections where they are used:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(plyr)}
\hlkwd{library}\hlstd{(grid)}
\hlkwd{library}\hlstd{(Hmisc)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: lattice\\\#\# Loading required package: survival\\\#\# Loading required package: splines\\\#\# Loading required package: Formula\\\#\# \\\#\# Attaching package: 'Hmisc'\\\#\# \\\#\# The following objects are masked from 'package:plyr':\\\#\# \\\#\#\ \ \ \  is.discrete, summarize\\\#\# \\\#\# The following objects are masked from 'package:base':\\\#\# \\\#\#\ \ \ \  format.pval, round.POSIXt, trunc.POSIXt,\\\#\#\ \ \ \  units}}\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(scales)}
\hlcom{# library(rgdal)}
\hlcom{# library(ggtern)}
\hlcom{# library(ggmap)}
\hlcom{# library(GGally)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \code{Lattice} and \code{ggplot2}. There are packages that add extra functionality to these packages.

In the examples in this handbook we mainly use \code{ggplot}, \code{ggmap} and \code{ggtern}. In this appendix we give an introduction to the `grammar of graphics' and \code{ggplot2}. There is ample literature on the use of ggplot2, starting with very good reference documentation at \http{ggplot2.org}. The book `R Graphics Cookbook' \cite{Chang2013} is very useful and should be always near you, when using the package, as it contains many worked out examples. There is some overlap between this appendix and the documents mentioned above. There is little well-organized literature on packages extending ggplot2, and as we make use of several of them in this handbook, we have included some examples of their use in this appendix.

\section{Bases of plotting with \code{ggplot2}}

The grammar of graphics is based on aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geometry. In the examples that follow we will use the \code{mtcars} data set included in R.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-170} 

}



\end{knitrout}

Aesthetics can be `linked' to data variables, either continuous (numeric) or categorical (factor). Variable \code{cyl} is encoded in the \code{mtcars} dataframe as numeric values. Even though only three values are present, a continuous color scale is used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=cyl))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-171} 

}



\end{knitrout}

We can convert \code{cyl} in a factor `on-the-fly' to force the use of a discrete color scale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-172} 

}



\end{knitrout}

Data assigned to an aesthetic can be the `result of a calculation'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{y}\hlstd{=mpg} \hlopt{/} \hlstd{disp))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-173} 

}



\end{knitrout}

Within \code{aes} the aesthetics are interpreted as being a function of the values in the data. If given outside \code{aes} they are interpreted as constants, which apply to one geom if given within the call to \code{geom\_xxx} but outside \code{aes} or to the whole plot if given within \code{ggplot} but outside \code{aes}. The aesthetics and data given as \code{ggplot}'s arguments become the defaults for all the geoms, but geoms also take aesthetics and data as arguments, which then override the defaults.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{fill}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"grey10"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-174} 

}



\end{knitrout}

In the next example we override the \code{color} aesthetic in \code{geom\_smooth}\footnote{Smoothing and curve fitted is discussed in more detail in section \ref{sec:???}.}, causing all the data to be fitted together

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-175} 

}



\end{knitrout}

We can assign the same variable to more than one aesthetic, and the combined key will be produced automatically.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{shape}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-176} 

}



\end{knitrout}

We can change the labels for the different aesthetics, and give a title\footnote{\protect{\verb!\n1!} means `new line' and can be used to continua a label in the next line.}. In this case, if two aesthetic are linked to the same variable, the labels supplied should be identical, otherwise two separate keys will be produced.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{shape}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
    \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Engine displacement)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Gross horsepower"}\hlstd{,}
       \hlkwc{colour}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{shape}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{title}\hlstd{=}\hlstr{"Motor Trend Car Road Tests (1973-74 models)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-177} 

}



\end{knitrout}

We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{mylabs} \hlkwb{<-} \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Engine displacement)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Gross horsepower"}\hlstd{,}
       \hlkwc{colour}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{shape}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{title}\hlstd{=}\hlstr{"Motor Trend Car Road Tests (1973-74 models)"}\hlstd{)}
\hlstd{myplot}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1781} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1782} 

}



\end{knitrout}

And now we can assemble them into plots.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1791} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1792} 

}



\end{knitrout}

We can also save intermediate results.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mylogplot} \hlkwb{<-} \hlstd{myplot} \hlopt{+} \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,}\hlnum{20}\hlstd{,}\hlnum{40}\hlstd{),} \hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{8}\hlstd{,}\hlnum{45}\hlstd{))}
\hlstd{mylogplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-180} 

}



\end{knitrout}

The are a few predefined themes, even the default \code{theme\_grey} can come in handy because the first parameter to themes is the point size used as reference to calculate all other font sizes. You can see in the two examples bellow, that the size of all text elements changes proportionally.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_grey}\hlstd{(}\hlnum{10}\hlstd{)}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_grey}\hlstd{(}\hlnum{16}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1811} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-1812} 

}



\end{knitrout}

Be aware that the different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. We use the \code{alpha} aesthetic to make the confidence band less transparent so that the example is easier to see in print.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+} \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-182} 

}



\end{knitrout}

The plot looks different if the order of the geoms is swapped. The data points overlapping the confidence band are more clearly visible in this second example because they are above the shaded area instead of bellow it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
   \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-183} 

}



\end{knitrout}

\section{Adding fitted curves, including splines}

We will now show an example of use of \code{stat\_smooth} using the default spline smoothing.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-184} 

}



\end{knitrout}

Instead of using the default spline, we can use a linear model fit. In this example we use a linear model, fitted by lm, as smoother:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-185} 

}



\end{knitrout}

Instead of using the default linear regression as smoother, we can use a linear model fit. In this example we use a polynomial of order 2 fitted by lm.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{formula}\hlstd{=y}\hlopt{~}\hlkwd{poly}\hlstd{(x,}\hlnum{2}\hlstd{),} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-186} 

}



\end{knitrout}

If we do not use \code{colour="black"} then the colour aesthetics supplied to \code{ggplot} is used, and splits the data into three groups to which the model is fitted separately.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-187} 

}



\end{knitrout}

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use these more advanced models.

\section{Adding statistical ``summaries''}

It is also possible to summarize data on-the-fly when plotting, but before showing this we will generate some normally distributed artificial data:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{2}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{0.5}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{0.7}\hlstd{)),}
  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{20}\hlstd{)))}
  \hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Now we use these data to plot means and confidence intervals by group:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake.data,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlstd{fig2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-189} 

}



\end{knitrout}

We have saved the base figure in \code{fig2}, so now we can play with different summaries. We first add just the mean. In this case we need to add as argument to \code{stat\_summary} the geom to use, as the default one expects data for plotting error bars, in later examples, this is not needed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"mean"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlstr{"-"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-190} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"median"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlstr{"-"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-191} 

}



\end{knitrout}

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_boot"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-192} 

}



\end{knitrout}

We can instead add the means and $p = 0.90$ confidence intervals, by supplying a value to parameter \code{conf.int}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_boot"}\hlstd{,} \hlkwc{conf.int}\hlstd{=}\hlnum{0.90}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-193} 

}



\end{knitrout}

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-194} 

}



\end{knitrout}

In this case the multiplier \code{mult} is by default is calculated from the $t$ distribution according to degrees of freedom, but if we force the multiplier to 1, then we get error bars corresponding to $\pm$s.e. (standard errors).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,} \hlkwc{mult}\hlstd{=}\hlnum{1}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-195} 

}



\end{knitrout}

Finally we can plot error bars showing $\pm$s.d. (standard deviation). The default value for \code{mult} is 2, giving error bars $\pm 2$ s.d., we use 1 as multiplier instead.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_sdl"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-196} 

}



\end{knitrout}

We do not show it here, but instead of using these functions (from package \codet{Hmisc}) it is possible to define one's own functions.

Finally we plot the means in a bar plot, with the observations superimposed and $p = 0.95$ C.I. (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets they can be assigned to factors in the data set.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake.data,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"mean"}\hlstd{,} \hlkwc{geom} \hlstd{=} \hlstr{"bar"}\hlstd{,}
               \hlkwc{fill}\hlstd{=}\hlstr{"yellow"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
               \hlkwc{geom} \hlstd{=} \hlstr{"errorbar"}\hlstd{,}
               \hlkwc{width}\hlstd{=}\hlnum{0.1}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-197} 

}



\end{knitrout}

\section{Plotting functions}

We can also directly plot functions, without need to generate data beforehand:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=dnorm)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-198} 

}



\end{knitrout}

We can even pass additional arguments to a function:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= dnorm,} \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{.5}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-199} 

}



\end{knitrout}

Of course, user-defined functions (not shown), and anonymous functions can also be used:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlnum{0}\hlopt{:}\hlnum{1}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{a}\hlstd{,} \hlkwc{b}\hlstd{)\{a} \hlopt{+} \hlstd{b} \hlopt{*} \hlstd{x}\hlopt{^}\hlnum{2}\hlstd{\},}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{1.4}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-200} 

}



\end{knitrout}

Here is another example of a predefined function, but in this case the default scale is not the best:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-201} 

}



\end{knitrout}

In this case we need to change the x-axis scale to better suit the sin function and the use of radians as angular units\footnote{The use of \code{expression} is explained in detail in section \ref{sec:??}, an the use of \code{scales} in section \ref{sec:???}.}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}
    \hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,}
    \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"0"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{0.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(pi),}
             \hlkwd{expression}\hlstd{(}\hlnum{1.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(}\hlnum{2}\hlopt{~}\hlstd{pi)))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlstr{"sin(x)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-202} 

}



\end{knitrout}

\section{Plotting text}

One can use \code{geom\_text} to add text labels to observations. The aesthetic \code{label} gives text and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{colour} aesthetic can be also used for text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of zero for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the label left or down, and positive values right or up. A value of 1 or -1 sets the text so that its edge is at the supplied coordinate. Values outside the range $-1\ldots 1$ sift the text even further away.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y}\hlstd{=}\hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{],} \hlstr{" "}\hlstd{))}
\hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x,y,}\hlkwc{label}\hlstd{=label))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{45}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-203} 

}



\end{knitrout}

In this example we use \code{paste} (which uses recycling here) to add a space at the end of each label. Justification values outside the range $-1\ldots 1$ are allowed, but are relative to the with of the label. As the default font used in this case has variable with characters, the justification would be inconsistent (e.g. try the code above but using \code{hjust} set to 3 instead of to 1 without pasting a space character to the labels.)


\section{Scales}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted object, such as \code{colour}, \code{size}, position (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the x-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also assign the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different one, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Be aware that for example for colour, and `numbers' there are both discrete and continuous scales available.

Advanced scale manipulation requires the package \code{scales} to be loaded. Some simple examples follow.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake2.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{20}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{5}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{40}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{10}\hlstd{)),}
  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{20}\hlstd{))),}
  \hlkwc{z} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{40}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{12}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{6}\hlstd{)}
  \hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake2.data,}
         \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group,} \hlkwc{shape}\hlstd{=group,} \hlkwc{colour}\hlstd{=group,} \hlkwc{size}\hlstd{=z))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlstd{fig2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-206} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+}
  \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,}\hlnum{20}\hlstd{,}\hlnum{30}\hlstd{,}\hlnum{40}\hlstd{,}\hlnum{50}\hlstd{,}\hlnum{60}\hlstd{))} \hlopt{+}
       \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{1}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.}}\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-207} 

}



\end{knitrout}

\section{Adding annotations}

Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the ggplot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}
    \hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,}
    \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"0"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{0.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(pi),}
             \hlkwd{expression}\hlstd{(}\hlnum{1.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(}\hlnum{2}\hlopt{~}\hlstd{pi)))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlstr{"sin(x)"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{label}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"+"}\hlstd{,} \hlstr{"-"}\hlstd{),}
           \hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{1.5}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlopt{-}\hlnum{0.5}\hlstd{),}
           \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
           \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,}
           \hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,}
           \hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{,}
           \hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y}\hlstd{=}\hlnum{0}\hlstd{,}
           \hlkwc{size}\hlstd{=}\hlnum{6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-208} 

}



\end{knitrout}

\section{Using facets}

Sets of coordinated plots are a very useful tool for visualizing data. These became popular through the \code{trellis} graphs in S, and the \code{lattice} package in R. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \code{ggplot2} there are two possible types of facets: facets organized in a grid, and facets on along a single `axis' but wrapped into several rows. In the examples below we use \code{geom\_point} but faceting can be used with any geom, and even with maps and ternary plots.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(mpg, wt))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlcom{# With one variable}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-209} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(cyl} \hlopt{~} \hlstd{.)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-210} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl,} \hlkwc{scales} \hlstd{=} \hlstr{"free"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-211} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl,} \hlkwc{scales} \hlstd{=} \hlstr{"free"}\hlstd{,} \hlkwc{space} \hlstd{=} \hlstr{"free"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-212} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(vs} \hlopt{~} \hlstd{am)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-213} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(vs} \hlopt{~} \hlstd{am,} \hlkwc{margins}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-214} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-215} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-216} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{margins}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-217} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(cyl} \hlopt{~} \hlstd{vs,} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-218} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mtcars}\hlopt{$}\hlstd{cyl12} \hlkwb{<-} \hlkwd{factor}\hlstd{(mtcars}\hlopt{$}\hlstd{cyl,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"alpha"}\hlstd{,} \hlstr{"beta"}\hlstd{,} \hlstr{"sqrt(x, y)"}\hlstd{))}
\hlstd{p1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(mpg, wt))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlstd{p1} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl12,} \hlkwc{labeller} \hlstd{= label_parsed)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-219} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs,} \hlkwc{labeller} \hlstd{=} \hlkwd{label_bquote}\hlstd{(alpha} \hlopt{^} \hlkwd{.}\hlstd{(x)))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-220} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlopt{~} \hlstd{cyl)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-221} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-222} 

}



\end{knitrout}

At the current time, \code{facet\_wrap} does not accept labellers, so neither expressions nor including the name of the variable in the labels can be done automatically.

\section{Plot matrices}

In this type of plot a set of several variables are plotted against each other, forming all possible pairs.
There is a function \code{plotmatrix} in ggplot2, but it is deprecated. Function \code{ggpairs} from package GGally provides this type of plots as an extension to ggplot.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(GGally)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Use sample of the diamonds data}
\hlkwd{data}\hlstd{(diamonds,} \hlkwc{package}\hlstd{=}\hlstr{"ggplot2"}\hlstd{)}
\hlstd{diamonds.samp} \hlkwb{<-} \hlstd{diamonds[}\hlkwd{sample}\hlstd{(}\hlnum{1}\hlopt{:}\hlkwd{dim}\hlstd{(diamonds)[}\hlnum{1}\hlstd{],}\hlnum{200}\hlstd{),]}
\hlcom{# Custom Example}
\hlstd{pm} \hlkwb{<-} \hlkwd{ggpairs}\hlstd{(}
\hlstd{diamonds.samp[,}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],}
\hlkwc{upper} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{continuous} \hlstd{=} \hlstr{"density"}\hlstd{,} \hlkwc{combo} \hlstd{=} \hlstr{"box"}\hlstd{),}
\hlkwc{lower} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{continuous} \hlstd{=} \hlstr{"points"}\hlstd{,} \hlkwc{combo} \hlstd{=} \hlstr{"dot"}\hlstd{),}
\hlkwc{color} \hlstd{=} \hlstr{"cut"}\hlstd{,}
\hlkwc{title} \hlstd{=} \hlstr{"Diamonds"}
\hlstd{)}
\hlstd{pm}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-225} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{GGally)}
\end{alltt}
\end{kframe}
\end{knitrout}



\section{Circular plots}

A funny example stolen from the ggplot2 website at \url{http://docs.ggplot2.org/current/coord_polar.html}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Hadley's favourite pie chart}
\hlstd{df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{variable} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"resembles"}\hlstd{,} \hlstr{"does not resemble"}\hlstd{),}
  \hlkwc{value} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{80}\hlstd{,} \hlnum{20}\hlstd{)}
\hlstd{)}
\hlkwd{ggplot}\hlstd{(df,} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{""}\hlstd{,} \hlkwc{y} \hlstd{= value,} \hlkwc{fill} \hlstd{= variable))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat} \hlstd{=} \hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"yellow"}\hlstd{))} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{(}\hlstr{"y"}\hlstd{,} \hlkwc{start} \hlstd{= pi} \hlopt{/} \hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{"Pac man"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-228} 

}



\end{knitrout}

Something just a bit more useful, also stolen from the same page:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# A pie chart = stacked bar chart + polar coordinates}
\hlstd{pie} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlnum{1}\hlstd{),} \hlkwc{fill} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
 \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{)}
\hlstd{pie} \hlopt{+} \hlkwd{coord_polar}\hlstd{(}\hlkwc{theta} \hlstd{=} \hlstr{"y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-229} 

}



\end{knitrout}

\section{Pie charts vs.\ bar plots example}

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}). %The original figure was created with the following code (not run):



Here is my \code{ggplot2} version of the same figure, using much simpler code and obtaining almost the same result.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{example.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{17}\hlstd{,} \hlnum{18}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{22}\hlstd{,} \hlnum{23}\hlstd{,}
                        \hlnum{20}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{19}\hlstd{,} \hlnum{21}\hlstd{,} \hlnum{20}\hlstd{,}
                        \hlnum{23}\hlstd{,} \hlnum{22}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{18}\hlstd{,} \hlnum{17}\hlstd{),}
             \hlkwc{examples}\hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,}\hlnum{5}\hlstd{,}\hlnum{5}\hlstd{)),}
             \hlkwc{cols} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"blue"}\hlstd{,} \hlstr{"green"}\hlstd{,} \hlstr{"yellow"}\hlstd{,} \hlstr{"black"}\hlstd{),} \hlnum{3}\hlstd{)}
  \hlstd{)}

\hlkwd{ggplot}\hlstd{(example.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=cols,} \hlkwc{y}\hlstd{=values,} \hlkwc{fill}\hlstd{=cols))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(.}\hlopt{~}\hlstd{examples)} \hlopt{+}
  \hlkwd{scale_fill_identity}\hlstd{()}
\hlkwd{ggplot}\hlstd{(example.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{factor}\hlstd{(}\hlnum{1}\hlstd{),} \hlkwc{y}\hlstd{=values,} \hlkwc{fill}\hlstd{=cols))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(.}\hlopt{~}\hlstd{examples)} \hlopt{+}
  \hlkwd{scale_fill_identity}\hlstd{()} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{(}\hlkwc{theta}\hlstd{=}\hlstr{"y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-2311} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-2312} 

}



\end{knitrout}

\section{A classical example about regression}

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}. The original code (not run):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
 \hlkwd{svg}\hlstd{(}\hlstr{"anscombe.svg"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{10.5}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{7}\hlstd{)}
 \hlkwd{par}\hlstd{(}\hlkwc{las}\hlstd{=}\hlnum{1}\hlstd{)}

 \hlcom{##-- some "magic" to do the 4 regressions in a loop:}
 \hlstd{ff} \hlkwb{<-} \hlstd{y} \hlopt{~} \hlstd{x}
 \hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{4}\hlstd{) \{}
   \hlstd{ff[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{]} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"y"}\hlstd{,}\hlstr{"x"}\hlstd{), i,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), as.name)}
   \hlcom{## or   ff2 <- as.name(paste("y", i, sep=""))}
   \hlcom{##      ff3 <- as.name(paste("x", i, sep=""))}
   \hlkwd{assign}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"lm."}\hlstd{,i,}\hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), lmi} \hlkwb{<-} \hlkwd{lm}\hlstd{(ff,} \hlkwc{data}\hlstd{= anscombe))}
 \hlstd{\}}

 \hlcom{## Now, do what you should have done in the first place: PLOTS}
 \hlstd{op} \hlkwb{<-} \hlkwd{par}\hlstd{(}\hlkwc{mfrow}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{2}\hlstd{),} \hlkwc{mar}\hlstd{=}\hlnum{1.5}\hlopt{+}\hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,}\hlnum{3.5}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{1}\hlstd{),} \hlkwc{oma}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{),}
           \hlkwc{lab}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{6}\hlstd{,}\hlnum{6}\hlstd{,}\hlnum{7}\hlstd{),} \hlkwc{cex.lab}\hlstd{=}\hlnum{1.5}\hlstd{,} \hlkwc{cex.axis}\hlstd{=}\hlnum{1.3}\hlstd{,} \hlkwc{mgp}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{,}\hlnum{0}\hlstd{))}
 \hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{4}\hlstd{) \{}
   \hlstd{ff[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{]} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"y"}\hlstd{,}\hlstr{"x"}\hlstd{), i,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), as.name)}
   \hlkwd{plot}\hlstd{(ff,} \hlkwc{data} \hlstd{=anscombe,} \hlkwc{col}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{pch}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{bg} \hlstd{=} \hlstr{"orange"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{2.5}\hlstd{,}
        \hlkwc{xlim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{19}\hlstd{),} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{13}\hlstd{),}
        \hlkwc{xlab}\hlstd{=}\hlkwd{eval}\hlstd{(}\hlkwd{substitute}\hlstd{(}\hlkwd{expression}\hlstd{(x[i]),} \hlkwd{list}\hlstd{(}\hlkwc{i}\hlstd{=i))),}
        \hlkwc{ylab}\hlstd{=}\hlkwd{eval}\hlstd{(}\hlkwd{substitute}\hlstd{(}\hlkwd{expression}\hlstd{(y[i]),} \hlkwd{list}\hlstd{(}\hlkwc{i}\hlstd{=i))))}
   \hlkwd{abline}\hlstd{(}\hlkwd{get}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"lm."}\hlstd{,i,}\hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{)),} \hlkwc{col}\hlstd{=}\hlstr{"blue"}\hlstd{)}
 \hlstd{\}}

 \hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

My version using \code{ggplot2}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# we rearrange the data}
\hlstd{my.mat} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{as.matrix}\hlstd{(anscombe),} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\hlstd{my.anscombe} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{= my.mat[ ,} \hlnum{1}\hlstd{],} \hlkwc{y} \hlstd{= my.mat[ ,} \hlnum{2}\hlstd{],} \hlkwc{case}\hlstd{=}\hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{,} \hlkwd{rep}\hlstd{(}\hlnum{11}\hlstd{,}\hlnum{4}\hlstd{))))}
\hlcom{# we draw the figure}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-233} 

}



\end{knitrout}

It is not much more difficult to make it look similar to the original

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{se}\hlstd{=}\hlnum{FALSE}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-234} 

}



\end{knitrout}

Although I think that the confidence bands make the point of the example much clearer

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-235} 

}



\end{knitrout}

This classical example form Anscombe \cite{xxx} demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

\section{Ternary plots}



Being an extension to \code{ggplot2} the main difference is that a ternary plot can be created using \code{coord\_tern} and that the three aesthetics \code{x, y, z} are required. By default the values of the variables mapped to these aesthetics are re-expressed as percentages or fractions. We present here only a few examples, and we encourage the readers to check the package's web site at \url{http://www.ggtern.com}.

For the first example we first generate some random data values from the uniform distribution:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# create some artificial data}
\hlstd{my.trn1.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{),} \hlkwc{y}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{),} \hlkwc{z}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

A ternary plot is just a plot with a different system of coordinates, and can be obtained using \code{coord\_tern}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(my.trn1.data,} \hlkwd{aes}\hlstd{(x,y,z))} \hlopt{+}
  \hlkwd{coord_tern}\hlstd{(}\hlkwc{L}\hlstd{=}\hlstr{"x"}\hlstd{,}\hlkwc{T}\hlstd{=}\hlstr{"y"}\hlstd{,}\hlkwc{R}\hlstd{=}\hlstr{"z"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

One can achieve a similar result by using \code{ggtern} instead of \code{ggplot}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlkwb{<-} \hlkwd{ggtern}\hlstd{(my.trn1.data,} \hlkwd{aes}\hlstd{(x,y,z))}
\end{alltt}
\end{kframe}
\end{knitrout}

As with any other plot based on \code{ggplot2} one builds the plot by adding `layers'. Themes are also supported.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-2401} 
\includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-2402} 

}



\end{knitrout}

It is possible to also draw confidence regions:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_confidence}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-241} 

}



\end{knitrout}

Or density estimates. In this last version of the plot I adjust a few other aesthetics and refine the appearance of the plot:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{stat_density2d}\hlstd{(}\hlkwc{fullrange}\hlstd{=T,}\hlkwc{n}\hlstd{=}\hlnum{200}\hlstd{,}
                       \hlkwc{geom}\hlstd{=}\hlstr{"polygon"}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"grey10"}\hlstd{,}
                       \hlkwd{aes}\hlstd{(}\hlkwc{alpha} \hlstd{=..level..))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"x (%)"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlstr{"y (%)"}\hlstd{,} \hlkwc{z}\hlstd{=}\hlstr{"z (%)"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlstr{"Density"}\hlstd{)} \hlopt{+}
  \hlkwd{theme_rgbw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-242} 

}



\end{knitrout}



As a final example we reproduce an elaborate ternary plot from \url{http://www.ggtern.com/2014/01/15/usda-textural-soil-classification/}, the website of the package.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Load the Data. (Available in ggtern 1.0.3.0 next version)}
\hlkwd{data}\hlstd{(USDA)}

\hlcom{# Put tile labels at the midpoint of each tile.}
\hlstd{USDA.LAB} \hlkwb{=} \hlkwd{ddply}\hlstd{(USDA,} \hlstr{'Label'}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{df}\hlstd{) \{}
    \hlkwd{apply}\hlstd{(df[,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],} \hlnum{2}\hlstd{, mean)}
\hlstd{\})}

\hlcom{# Tweak}
\hlstd{USDA.LAB}\hlopt{$}\hlstd{Angle} \hlkwb{=} \hlnum{0}
\hlstd{USDA.LAB}\hlopt{$}\hlstd{Angle[}\hlkwd{which}\hlstd{(USDA.LAB}\hlopt{$}\hlstd{Label} \hlopt{==} \hlstr{'Loamy Sand'}\hlstd{)]} \hlkwb{=} \hlopt{-}\hlnum{35}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Construct the plot.}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= USDA,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=Clay,} \hlkwc{x}\hlstd{=Sand,} \hlkwc{z}\hlstd{=Silt,}
                        \hlkwc{color} \hlstd{= Label,}
                        \hlkwc{fill} \hlstd{= Label))} \hlopt{+}
  \hlkwd{coord_tern}\hlstd{(}\hlkwc{L}\hlstd{=}\hlstr{"x"}\hlstd{,}\hlkwc{T}\hlstd{=}\hlstr{"y"}\hlstd{,}\hlkwc{R}\hlstd{=}\hlstr{"z"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.75}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{color} \hlstd{=} \hlstr{'black'}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data} \hlstd{= USDA.LAB,}
            \hlkwd{aes}\hlstd{(}\hlkwc{label} \hlstd{= Label,} \hlkwc{angle} \hlstd{= Angle),}
            \hlkwc{color} \hlstd{=} \hlstr{'black'}\hlstd{,}
            \hlkwc{size} \hlstd{=} \hlnum{3.5}\hlstd{)} \hlopt{+}
  \hlkwd{theme_rgbw}\hlstd{()} \hlopt{+}
  \hlkwd{theme_showsecondary}\hlstd{()} \hlopt{+}
  \hlkwd{theme_showarrows}\hlstd{()} \hlopt{+}
  \hlkwd{custom_percent}\hlstd{(}\hlstr{"Percent"}\hlstd{)} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{legend.justification} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
        \hlkwc{legend.position}      \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
        \hlkwc{axis.tern.padding}    \hlstd{=} \hlkwd{unit}\hlstd{(}\hlnum{0.15}\hlstd{,} \hlstr{'npc'}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{'USDA Textural Classification Chart'}\hlstd{,}
       \hlkwc{fill}  \hlstd{=} \hlstr{'Textural Class'}\hlstd{,}
       \hlkwc{color} \hlstd{=} \hlstr{'Textural Class'}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-245} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggtern)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Plotting data onto maps}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggmap)}
\hlkwd{library}\hlstd{(rgdal)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: sp\\\#\# rgdal: version: 0.8-16, (SVN revision 498)\\\#\# Geospatial Data Abstraction Library extensions to R successfully loaded\\\#\# Loaded GDAL runtime: GDAL 1.11.0, released 2014/04/16\\\#\# Path to GDAL shared files: C:/Users/aphalo/Documents/R/win-library/3.1/rgdal/gdal\\\#\# GDAL does not use iconv for recoding strings.\\\#\# Loaded PROJ.4 runtime: Rel. 4.8.0, 6 March 2012, [PJ\_VERSION: 480]\\\#\# Path to PROJ.4 shared files: C:/Users/aphalo/Documents/R/win-library/3.1/rgdal/proj}}\end{kframe}
\end{knitrout}


Another extension to package \code{ggplot2} is package \code{ggmap}. Package \code{ggmap} makes it possible to plot data using normal \code{ggplot2} syntax on top of a map. Maps can be easily retrieved from the internet through different services. Some of these services require the user to register and obtain a key for access. As Google Maps do not require such a key for normal resolution maps, we use this service in the examples.

The first step is to fetch the desired map. One can fetch the maps base on any valid Google Maps search term, or by giving the coordinates at the center of the map. Although \code{zoom} defaults to "auto", frequently the best result is obtained by providing this argument. Valid values for \code{zoom} are integers in the range 1 to 20.


\begin{framed}

We will fetch maps from Google Maps. We have disabled the messages, to avoid repeated messages about Google's terms of use.

\begin{description}
\item[Google Maps API Terms of Service:] \url{http://developers.google.com/maps/terms}
\item[Information from URL:] \url{http://maps.googleapis.com/maps/api/geocode/json?address=Europe&sensor=false}
\item[Map from URL:] \url{http://maps.googleapis.com/maps/api/staticmap?center=Europe&zoom=3&size=%20640x640&scale=%202&maptype=terrain&sensor=false}
\end{description}

\end{framed}

We start by fetching and plotting a map of Europe of type  \code{satellite}. We use the default extent \code{panel}, and also the extent \code{device} and \code{normal}. The \code{normal} plot includes axes showing the coordinates, while \code{device} does not show them, while \code{panel} shows axes but the map fits tightly into the drawing area:



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Europe1} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe1)}

\hlkwd{ggmap}\hlstd{(Europe1,} \hlkwc{extent} \hlstd{=} \hlstr{"device"}\hlstd{)}

\hlkwd{ggmap}\hlstd{(Europe1,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.32\textwidth]{figure/pos-plot-maps-21} 
\includegraphics[width=.32\textwidth]{figure/pos-plot-maps-22} 
\includegraphics[width=.32\textwidth]{figure/pos-plot-maps-23} 

}



\end{knitrout}

To demonstrate the option to fetch a map in black and white instead of the default colour version, we use a map of Europe of type \code{terrain}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Europe2} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe2)}

\hlstd{Europe3} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{,}
                  \hlkwc{color}\hlstd{=}\hlstr{"bw"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe3)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-31} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-32} 

}



\end{knitrout}

To demonstrate the difference between type \code{roadmap} and the default type \code{terrain}, we use the map of Finland. Note that we search for ``Oulu'' instead of ``Finland'' as Google Maps takes the position of the label ``Finland'' as the center of the map, and clips the northern part. By means of \code{zoom} we override the default automatic zooming onto the city of Oulu.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Finland1} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Oulu"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Finland1)}

\hlstd{Finland2} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Oulu"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"roadmap"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Finland2)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-41} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-42} 

}



\end{knitrout}

We can even search for a street address, and in this case with high zoom value, we can see the building where one of us works:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{BIO3} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki"}\hlstd{,}
                \hlkwc{zoom}\hlstd{=}\hlnum{18}\hlstd{,}
                \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(BIO3)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-5} 

}



\end{knitrout}

We will now show a simple example of plotting data on a map, first by explicitly giving the coordinates, and in the second example we show how to fetch from Google Maps coordinate values that can be then plotted. We use function \code{geocode}. In one example we use \code{geom\_point} and \code{geom\_text}, while in the second example we use \code{annotate}, but either approach could have been used for both plots:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{viikki} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Viikki"}\hlstd{,}
                  \hlkwc{zoom}\hlstd{=}\hlnum{15}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}

\hlstd{our_location} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{lat}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{60.225}\hlstd{,} \hlnum{60.227}\hlstd{),}
                           \hlkwc{lon}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{25.017}\hlstd{,} \hlnum{25.018}\hlstd{),}
                           \hlkwc{label}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"BIO3"}\hlstd{,} \hlstr{"field"}\hlstd{))}
\hlkwd{ggmap}\hlstd{(viikki,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data}\hlstd{=our_location,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=lat,} \hlkwc{x}\hlstd{=lon),}
             \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=our_location,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=lat,} \hlkwc{x}\hlstd{=lon,} \hlkwc{label}\hlstd{=label),}
            \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.3}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)}

\hlstd{our_geocode} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(viikki,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
           \hlkwc{y}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lat"}\hlstd{],} \hlkwc{x}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lon"}\hlstd{],}
           \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{y}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lat"}\hlstd{],} \hlkwc{x}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lon"}\hlstd{],}
           \hlkwc{label}\hlstd{=}\hlstr{"BIO3"}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.3}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-61} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-62} 

}



\end{knitrout}

Using \code{get\_map} from package \code{ggmap} for drawing a world map is not possible at the time of writing. In addition a worked out example of how to plot shape files, and how to download them from a repository is suitable as our final example. We also show how to change the map projection. The example is adapted from a blog post at \url{http://rpsychologist.com/working-with-shapefiles-projections-and-world-maps-in-ggplot}.

We start by downloading the map data archive files from \url{http://www.naturalearthdata.com} which is available in different layers. We only use three of the available layers: `physical' which describes the coastlines and a grid and bounding box, and `cultural' which gives country borders. We save them in a folder with name `maps', which is expected to already exist. After downloading each file, we unzip it.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{oldwd} \hlkwb{<-} \hlkwd{setwd}\hlstd{(}\hlstr{"./maps"}\hlstd{)}

\hlstd{url_path} \hlkwb{<-}
\hlcom{#  "http://www.naturalearthdata.com/download/110m/"}
  \hlstr{"http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/"}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"physical/ne_110m_land.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_land.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_land.zip"}\hlstd{)}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"cultural/ne_110m_admin_0_countries.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_admin_0_countries.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_admin_0_countries.zip"}\hlstd{)}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"physical/ne_110m_graticules_all.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_graticules_all.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_graticules_all.zip"}\hlstd{)}

\hlkwd{setwd}\hlstd{(oldwd)}
\end{alltt}
\end{kframe}
\end{knitrout}

We list the layers that we have downloaded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ogrListLayers}\hlstd{(}\hlkwc{dsn}\hlstd{=}\hlstr{"./maps"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ne_110m_admin_0_countries" 
## [2] "ne_110m_graticules_1"      
## [3] "ne_110m_graticules_10"     
## [4] "ne_110m_graticules_15"     
## [5] "ne_110m_graticules_20"     
## [6] "ne_110m_graticules_30"     
## [7] "ne_110m_graticules_5"      
## [8] "ne_110m_land"              
## [9] "ne_110m_wgs84_bounding_box"
\end{verbatim}
\end{kframe}
\end{knitrout}

Next we read the layer for the coastline, and use \code{fortify} to convert it into a data frame. We also create a second version of the data using the Robinson projection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wmap} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlkwc{dsn}\hlstd{=}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_land"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_land"
## with 127 features and 2 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{wmap.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(wmap)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{wmap_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(wmap,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{wmap_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(wmap_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

We do the same for country borders,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{countries} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_admin_0_countries"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_admin_0_countries"
## with 177 features and 63 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{countries.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(countries)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{countries_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(countries,} \hlkwd{CRS}\hlstd{(}\hlstr{"+init=ESRI:54030"}\hlstd{))}
\hlstd{countries_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(countries_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

and for the graticule at $15^\circ$ intervals, and the bounding box.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{grat} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_graticules_15"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_graticules_15"
## with 35 features and 5 fields
## Feature type: wkbLineString with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{grat.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(grat)}
\hlstd{grat_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(grat,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{grat_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(grat_robin)}

\hlstd{bbox} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_wgs84_bounding_box"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_wgs84_bounding_box"
## with 1 features and 2 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{bbox.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(bbox)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{bbox_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(bbox,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{bbox_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(bbox_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

Now we plot the world map of the coastlines, on a longitude and latitude scale, as a \code{ggplot} using \code{geom\_polygon}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(wmap.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (longlat)"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-254} 

}



\end{knitrout}

There is one noticeable problem in the map shown above: the Caspian sea is missing. We need to use aesthetic \code{fill} and a manual scale to correct this.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(wmap.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=hole))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (longlat)"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"#262626"}\hlstd{,} \hlstr{"#e6e8ed"}\hlstd{),}
                    \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-255} 

}



\end{knitrout}




When plotting a map using a projection, many default elements of the \code{ggplot} theme need to be removed, as the data is no longer in units of degrees of latitude and longitude and axes and their labels are no longer meaningful.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{theme_map_opts} \hlkwb{<-}
  \hlkwd{list}\hlstd{(}\hlkwd{theme}\hlstd{(}\hlkwc{panel.grid.minor} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{panel.grid.major} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{panel.background} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{plot.background} \hlstd{=} \hlkwd{element_rect}\hlstd{(}\hlkwc{fill}\hlstd{=}\hlstr{"#e6e8ed"}\hlstd{),}
             \hlkwc{panel.border} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.line} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.text.y} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.ticks} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.title.x} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.title.y} \hlstd{=} \hlkwd{element_blank}\hlstd{()))}
\end{alltt}
\end{kframe}
\end{knitrout}

Finally we plot all the layers using the Robinson projection. This is still a \code{ggplot} and consequently one can plot data on top of the map, being aware of the transformation of the scale needed to make the data location match locations in a map using a certain projection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(bbox_robin.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{data}\hlstd{=countries_robin.data,}
               \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,}
                   \hlkwc{fill}\hlstd{=hole))} \hlopt{+}
  \hlkwd{geom_path}\hlstd{(}\hlkwc{data}\hlstd{=countries_robin.data,}
            \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=hole),}
            \hlkwc{color}\hlstd{=}\hlstr{"white"}\hlstd{,}
            \hlkwc{size}\hlstd{=}\hlnum{0.3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_path}\hlstd{(}\hlkwc{data}\hlstd{=grat_robin.data,}
            \hlkwd{aes}\hlstd{(long, lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=}\hlkwa{NULL}\hlstd{),}
            \hlkwc{linetype}\hlstd{=}\hlstr{"dashed"}\hlstd{,}
            \hlkwc{color}\hlstd{=}\hlstr{"grey50"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (Robinson)"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()} \hlopt{+}
  \hlstd{theme_map_opts} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"black"}\hlstd{,} \hlstr{"white"}\hlstd{),}
                    \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-258} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggmap)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{rgdal)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Advanced topics}

\section{Using \code{plotmath} expressions}

Expressions are very useful but rather tricky to use because the syntax is unusual. In \code{ggplot} one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined with \code{labs}) the expressions have to entered explicitly, or saved as such into a variable, and the variable supplied as argument. When plotting expressions using \code{geom\_text} expression arguments should be supplied as character strings and the optional argument \code{parse=TRUE} used to tell the geom to interpret the labels as expressions. We will go through a few useful examples.

We will revisit the example from the previous section, but now using subscripted Greek $\alpha$ for labels. In this example we use as subscripts numeric values from another variable in the same dataframe.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data}\hlopt{$}\hlstd{greek.label} \hlkwb{<-} \hlkwd{paste}\hlstd{(}\hlstr{"alpha["}\hlstd{, my.data}\hlopt{$}\hlstd{x,} \hlstr{"]"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{)}
\hlstd{(fig} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x,y,}\hlkwc{label}\hlstd{=greek.label))} \hlopt{+}
   \hlkwd{geom_text}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{45}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1.2}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{())}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-260} 

}



\end{knitrout}

Setting an axis label with superscripts. The easiest way to deal with spaces is to use `~' or `~~'. One can connect pieces that would otherwise cause errors using `*'. If we

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{expression}\hlstd{(alpha),} \hlkwc{y}\hlstd{=}\hlkwd{expression}\hlstd{(Speed}\hlopt{~~}\hlstd{(m}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-261} 

}



\end{knitrout}

It is possible to store expressions in variables.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.title} \hlkwb{<-} \hlkwd{expression}\hlstd{(}\hlkwd{sqrt}\hlstd{(alpha[}\hlnum{1}\hlstd{]} \hlopt{+} \hlkwd{frac}\hlstd{(beta, gamma)))}
\hlstd{fig} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=my.title)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-262} 

}



\end{knitrout}

Annotations are plotted ignoring the default aesthetics, but still make use of geoms, so labels for annotations also have to be supplied as character strings and parsed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlstr{"sqrt(alpha[1] + frac(beta, gamma))"}\hlstd{,}
           \hlkwc{y}\hlstd{=}\hlnum{2.5}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-263} 

}



\end{knitrout}

We discuss how to use expressions as facet labels in section \ref{sec:facet}.

\subsection{Inset plots using same data}

Example from \url{http://stackoverflow.com/questions/20708012/embedding-a-subplot-in-ggplot-ggsubplot}, authored by Baptiste Auguié \url{http://baptiste.github.io/}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{d} \hlkwb{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{sort}\hlstd{(}\hlkwd{rlnorm}\hlstd{(}\hlnum{300}\hlstd{)),}
               \hlkwc{y} \hlstd{=} \hlkwd{sort}\hlstd{(}\hlkwd{rlnorm}\hlstd{(}\hlnum{300}\hlstd{)),}
               \hlkwc{grp} \hlstd{=} \hlnum{1}\hlstd{)}

\hlstd{main} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(d,} \hlkwd{aes}\hlstd{(x, y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}

\hlstd{sub} \hlkwb{<-} \hlstd{main} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=d[}\hlnum{1}\hlstd{,],}
            \hlkwc{xmin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{ymin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{xmax}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{5}\hlstd{,}
            \hlkwc{fill}\hlstd{=}\hlstr{"grey50"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)}
\hlstd{sub}\hlopt{$}\hlstd{layers} \hlkwb{<-} \hlkwd{rev}\hlstd{(sub}\hlopt{$}\hlstd{layers)} \hlcom{# draw rect below}

\hlstd{main} \hlopt{+}
  \hlkwd{annotation_custom}\hlstd{(}\hlkwd{ggplotGrob}\hlstd{(sub),}
                    \hlkwc{xmin}\hlstd{=}\hlnum{2.5}\hlstd{,} \hlkwc{xmax}\hlstd{=}\hlnum{5}\hlstd{,}
                    \hlkwc{ymin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{2.5}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{))} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{4}\hlstd{))}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 25 rows containing missing values (geom\_point).}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-264} 

}



\end{knitrout}

\subsection{Adding elements using \code{grid}}

\code{ggplot2} creates the plots using package \code{grid}, consequently it is possible to manipulate \code{ggplot} objects using \code{grid} functions. Here we present a very simple example. For more information on using \code{grid} together with \code{ggplot2} please see \cite{Murriel2009}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{qplot}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{1}\hlstd{),} \hlkwc{vp}\hlstd{=}\hlkwd{viewport}\hlstd{(}\hlkwc{height}\hlstd{=}\hlnum{0.8}\hlstd{))}
\hlkwd{grid.text}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlkwd{unit}\hlstd{(}\hlnum{1}\hlstd{,}\hlstr{"npc"}\hlstd{)} \hlopt{-} \hlkwd{unit}\hlstd{(}\hlnum{1}\hlstd{,}\hlstr{"line"}\hlstd{),}
          \hlkwc{label}\hlstd{=}\hlstr{"I'm (slightly) out of here!"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-266} 

}



\end{knitrout}

\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=dnorm)}
\hlkwd{pdf}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.pdf"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

Encapsulated Postscript output (width and height in inches):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{postscript}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.eps"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tiff}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.tiff"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{800}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{scales)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{plyr)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{Hmisc)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{grid)}
\end{alltt}
\end{kframe}
\end{knitrout}


\chapter{Build information}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{Sys.info}\hlstd{()}
\end{alltt}
\begin{verbatim}
##                      sysname 
##                    "Windows" 
##                      release 
##                      "7 x64" 
##                      version 
## "build 7601, Service Pack 1" 
##                     nodename 
##                      "MUSTI" 
##                      machine 
##                     "x86-64" 
##                        login 
##                     "aphalo" 
##                         user 
##                     "aphalo" 
##               effective_user 
##                     "aphalo"
\end{verbatim}
\end{kframe}
\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\begin{verbatim}
## R version 3.1.1 Patched (2014-08-14 r66373)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## 
## locale:
## [1] LC_COLLATE=English_United Kingdom.1252 
## [2] LC_CTYPE=English_United Kingdom.1252   
## [3] LC_MONETARY=English_United Kingdom.1252
## [4] LC_NUMERIC=C                           
## [5] LC_TIME=English_United Kingdom.1252    
## 
## attached base packages:
## [1] splines   methods   tools     stats    
## [5] graphics  grDevices utils     datasets 
## [9] base     
## 
## other attached packages:
## [1] sp_1.0-15       Formula_1.1-2  
## [3] survival_2.37-7 lattice_0.20-29
## [5] lubridate_1.3.3 splus2R_1.2-0  
## [7] proto_0.3-10    stringr_0.6.2  
## [9] knitr_1.6      
## 
## loaded via a namespace (and not attached):
##  [1] cluster_1.15.2             
##  [2] colorspace_1.2-4           
##  [3] data.table_1.9.3           
##  [4] digest_0.6.4               
##  [5] evaluate_0.5.5             
##  [6] formatR_0.10               
##  [7] GGally_0.4.7               
##  [8] ggmap_2.3                  
##  [9] ggplot2_1.0.0              
## [10] ggtern_1.0.3.2             
## [11] grid_3.1.1                 
## [12] gridExtra_0.9.1            
## [13] gtable_0.1.2               
## [14] highr_0.3                  
## [15] Hmisc_3.14-4               
## [16] labeling_0.2               
## [17] latticeExtra_0.6-26        
## [18] mapproj_1.2-2              
## [19] maps_2.3-7                 
## [20] MASS_7.3-33                
## [21] memoise_0.2.1              
## [22] microbenchmark_1.3-0       
## [23] munsell_0.4.2              
## [24] photobiology_0.3.10        
## [25] photobiologyFilters_0.1.12 
## [26] photobiologygg_0.1.10      
## [27] photobiologyLEDs_0.1.2     
## [28] photobiologyWavebands_0.1.0
## [29] plyr_1.8.1                 
## [30] png_0.1-7                  
## [31] profr_0.3.1                
## [32] RColorBrewer_1.0-5         
## [33] Rcpp_0.11.2                
## [34] reshape_0.8.5              
## [35] reshape2_1.4               
## [36] rgdal_0.8-16               
## [37] RgoogleMaps_1.2.0.6        
## [38] rjson_0.2.14               
## [39] RJSONIO_1.3-0              
## [40] scales_0.2.4
\end{verbatim}
\end{kframe}
\end{knitrout}

\backmatter

\printbibliography

\end{document}
