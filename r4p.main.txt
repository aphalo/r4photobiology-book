\documentclass[a4paper,10pt]{memoir}\usepackage{knitr}

\usepackage[utf8]{inputenc}

% \title{R for Photobiology: a handbook}
% \author{Pedro J. Aphalo \and others}
% \pretitle{\begin{center}\LARGE}
% \posttitle{\par\end{center}\vskip 0.5em}

% using Lucida bright using now free package from PC TeX
\usepackage[lucidasmallscale,nofontinfo,seriftt=true,math-style=iso]{lucimatx}
% replace option altbullet
\renewcommand{\labelitemi}{%
 {\UseTextSymbol{OMS}\textbullet}}
% needed for Lucida
\linespread{1.04}

\usepackage[footinfo, missing={`none'}]{gitinfo} % remember to setup Git hooks

\usepackage{hologo}

\usepackage[british]{babel}
\usepackage{csquotes}

%\chapterstyle{ell}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.jpg,.pdf}

\usepackage{microtype}
\usepackage[style=authoryear-comp,firstinits,sortcites,maxcitenames=2,%
    mincitenames=1,maxbibnames=10,minbibnames=10,backref,uniquename=mininit,%
    uniquelist=minyear,sortfirstinits=true]{biblatex}%,refsection=chapter

\usepackage[hyperindex,bookmarks,pdfview=FitB,%backref,
            pdftitle={R for Photobiology},%
            pdfkeywords={photobiology, visible radiation, ultraviolet radiation, R, quantification, methods, calculations},%
            pdfsubject={Photobiology},%
            pdfauthor={Pedro J. Aphalo, Andreas Albert}%
            ]{hyperref}
%\chapterstyle{veelo}

\usepackage{color,calc,soul}%,graphicx,fourier
\definecolor{nicegreen}{rgb}{.129,.647,.149}
\definecolor{grey50}{rgb}{.5,.5,.5}
\makeatletter
\newlength\dlf@normtxtw
\setlength\dlf@normtxtw{\textwidth}
%\def\myhelvetfont{\def\sfdefault{mdput}}
\newsavebox{\feline@chapter}
\newcommand\feline@chapter@marker[1][4cm]{%
\sbox\feline@chapter{%
\resizebox{!}{#1}{\fboxsep=1pt%
\colorbox{nicegreen}{\color{white}\normalfont\bfseries\thechapter}%\sffamily
}}%
\rotatebox{90}{%
\resizebox{%
\heightof{\usebox{\feline@chapter}}+\depthof{\usebox{\feline@chapter}}}%
{!}{\scshape\so\@chapapp}}\quad%
\raisebox{\depthof{\usebox{\feline@chapter}}}{\usebox{\feline@chapter}}%
}
\newcommand\feline@chm[1][4cm]{%
\sbox\feline@chapter{\feline@chapter@marker[#1]}%
\makebox[0pt][l]{% aka \rlap
\makebox[1cm][r]{\usebox\feline@chapter}%
}}
\makechapterstyle{daleif1}{
\renewcommand\chapnamefont{\normalfont\Large\scshape\raggedleft\so}
\renewcommand\chaptitlefont{\normalfont\huge\bfseries\upshape\color{nicegreen}}%\sffamily
\renewcommand\chapternamenum{}
\renewcommand\printchaptername{}
\renewcommand\printchapternum{\null\hfill\feline@chm[2.5cm]\par}
\renewcommand\afterchapternum{\par\vskip\midchapskip}
\renewcommand\printchaptertitle[1]{\chaptitlefont\raggedleft ##1\par}
}
\makeatother
\chapterstyle{daleif1}

\newlength{\drop}
%% Some shades

\newcommand*{\titleLL}{\begingroup% Lost Languages
\drop=0.1\textheight
\fboxsep 0.5\baselineskip
\sffamily
\vspace*{\drop}
\centering
{\textcolor{nicegreen}{\HUGE R for Photobiology}}\par
\vspace{0.5\drop}
\colorbox{grey50}{\textcolor{yellow}{\normalfont\itshape\Large
A handbook}}\par
\vspace{\drop}
{\Large Pedro J. Aphalo\\ and\\ Andreas Albert}\par
\vfill
{\footnotesize Git: tag\gitVtagn , committed with hash \gitAbbrevHash\ on \gitAuthorIsoDate\\ by\ \gitAuthorName \\PDF created \today\\ \copyright\ 2013-2014 by the authors}\par
\vspace*{\drop}
\endgroup}

\maxsecnumdepth{subsection}
\maxtocdepth{section}

\usepackage{siunitx}
\usepackage{framed}
\renewenvironment{shaded}{%
  \def\FrameCommand{\fboxsep=\FrameSep \colorbox{shadecolor}}%
  \MakeFramed{\advance\hsize-\width \FrameRestore\FrameRestore}}%
 {\endMakeFramed}
\definecolor{shadecolor}{gray}{0.80}

\usepackage{abbrev}
\usepackage{r4photobiology}
%\usepackage{glossaries}
%\usepackage{imakeidx}

\addbibresource{rbooks.bib}
\addbibresource{handbook.bib}
\addbibresource{guidelines.bib}

%\makeindex
%\makeglossaries
%\loadglsentries{gp_glossary}


\newcommand{\gls}[1]{} % until start building the glossary.
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}

% knitr setup











\thispagestyle{empty}
\titleLL
\clearpage


\frontmatter
%\begin{titlingpage}
%  \maketitle
%\titleLL
%\end{titlingpage}

\tableofcontents

%\listoftables

%\listoffigures

\include{preface.tr}

\include{abbreviations.tr}

\mainmatter

\setsecnumdepth{subsection}

\part{Preliminaries}






\chapter{Introduction}

\begin{abstract}
  In this chapter we explain the physical basis of optics and photochemistry.
\end{abstract}

\section{Radiation and molecules}




\chapter{Optics}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}




\chapter{Photochemistry}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}




\chapter{Software}\label{chap:software}

\begin{abstract}
  In this chapter we describe the software we used to run the code examples and typeset this handbook, and how to install it.
\end{abstract}

%%%%
\section{Task: }\label{sec:}

%%%%
\section{Introduction}\label{sec:software:intro}
\sloppy
The software used for typesetting this handbook and developing the \textsf{r4photobiology} suite is free and open source. All of it is available for the most common operating systems (Unix including OS X, Linux and its variants, and Windows). It is also possible to run everything described here on a Linux server running the server version of RStudio, and access the server through a web browser.

For just running the examples in the handbook, you would need only to have R installed. That would be enough as long as you also have a text editor available. This is possible, but does not give a very smooth workflow for data analyses which are beyond the very simple. The next stage is to use a text editor which integrates to some extent with R, but still this is not ideal, specially for writing packages or long scrips. Currently the best option is to use the integrated development environment (IDE) called `RStudio'. This is an editor, but tightly integrated with R. Its advantages are especially noticeable in the case of errors and `debugging'. We also use a \hologo{LaTeX} for typesetting. Is what we used for the first handbook \autocite{Aphalo2012}, and what we routinely for reporting data analyses, and that PJA also uses for all `overhead' slides he writes for lectures. You, do not need to go this far to be able to profit from R and our suite, but the set up we will describe here, is what we currently use, it is by far the best one we have encountered in 18 years of using and teaching how to use R.

We will not give software installation instructions in this handbook, but will keep a web page with up-to-date instructions. In the following sections we briefly describe the different components of a full and comfortable working environment, but there many alternatives and the only piece that you cannot replace is R itself.

%%%%
\section{The different pieces}\label{sec:software:pieces}

\subsection{R}

You will not be able to profit from this handbook's `Cook Book' part, unless you have access to R. R (also called Gnu S) is both the name of a software system, and a dialect of the language S. The language S, although designed with data analysis and statistics in mind, is a computer language that is very powerful in its own way. It allows object oriented programming. Being based in a programming language, and being able to call and being called by programs and subroutine libraries written in several other programming languages, makes it easily extensible.

R has a well defined mechanism for ``add-ons'' called packages, that are kept in the computer where R is running, in disk folders that conform the library. There is a standard mechanism for installing packages, that works across operating systems (OSs) and computer architectures. There is also a Comprehensive R Archive Network (CRAN) where publicly released versions of packages are kept. Packages can be installed and updated from CRAN and similar repositories directly from within R.

If you are not familiar with R, please, go through the Appendixes \ref{chap:R:as:calc}, \ref{chap:R:scripts}, \ref{chap:R:scripts}, and \ref{chap:R:plotting},
and/or learn from some of the books listed in Appendix \ref{chap:R:reading}, before delving into our `Cook Book'.

\subsection{RStudio}

RStudio exists in two versions with identical user interface: a desktop version and a server version. The server version can be used remotely through a web browser. It can be for example run in the 'cloud', for example, as an AWS instance (Amazon Web Services) quite easily and cheaply, or on one's own server hardware.

\subsection{Version control: Git and Subversion}

Version control systems help with keeping track of the history of software development, data analysis, or even manuscript writing. They make it possible for several programmers, data analysts, authors and or editors to work on the same files in parallel and then merge their edits. They also allow easy transfer of whole `projects' between computers. Git is very popular, and Github and Bitbucket are popular hosts for repositories. Git itself is free software, and can be also run locally, or as one's own private server, either as an AWS instance or on other hosting service, or on your own hardware.

\subsection{C++ compiler}

Although R is an interpreted language, a few functions in our suite are written in C++ to achieve better performance. On OS X and Windows, the normal practice is to install binary packages, which are ready compiled. In other systems like Linux and Unix it is the normal practice to install source packages that are compiled at the time of installation.

\subsection{\LaTeX}

\hologo{LaTeX} is built on top of \hologo{TeX}. \hologo{TeX} code and features were `frozen' (only bugs are fixed) long ago. There are currently a few `improved' derivatives: \hologo{pdfTeX}, \hologo{XeTeX}, and \hologo{LuaTeX}. Currently the most popular \hologo{TeX} in western countries is pdftex which can directly output PDF files. \hologo{XeTeX} can handle text both written from left to right and right to left, even in the same document, and is the most popular \hologo{TeX} engine in China and other Asian countries.






\chapter{Photobiology R packages}

\begin{abstract}
  In this chapter we describe the suite of R packages for photobiological calculations `\textsf{r4photobiology}', and explain how to install them.
\end{abstract}

%%%%
\section{The design of the user interface}

The design of the `high level' interface is based on the idea of achieving simplicity of use by hiding the computational difficulties and exposing objects, functions and operators that map directly to physical concepts. Computations and plotting of spectral data centers on two types of objects: \emph{spectra} and \emph{wavebands}. Al spectra have in common that all observations are referenced to a wavelength value, there are different types spectral objects, e.g. for light sources and responses. Waveband objects include much more than information about a range of wavelengths, they can also include information about a transformation of the spectral data, like a biological spectral weighting function (BSWF). In addition to functions for calculating summary quantities like irradiance from spectral irradiance, the packages define operators for spectra and wavebands. The use of operators simplifies the syntax and makes the interface easier to use. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{e_irrad}\hlstd{(sun.spct} \hlopt{*} \hlstd{polyester.new.spc,} \hlkwd{CIE}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

Is all what is needed to obtain the CIE98-weigthed energy irradiance simulating the effect of a polyester filter on the example solar spectrum, which of course, can be substituted by other spectral data.

When we say that we hide the computational difficulties what we mean, is that in the example above, the data for the two spectra do not need to be available at the same wavelengths values, and the BSWF is defined as a function. Interpolation of the spectral data and calculation of weighting factors takes place automatically and invisibly. All functions and operators function without error with spectra with varying (even arbitrarily and randomly varying) wavelength steps. Integration is always used rather than summation for summarizing the spectral data.

There is lower layer of functions, used internally, but also exported, which allow improved performance at the expense of more complex scripts and commands. This user interface is not meant for the casual user, but for the user who has to analyse thousands of spectra and uses scripts for this. For such users performance is the main concern rather than easy of use and easy to remember syntax. Also these functions handle any wavelength mismatch by interpolation before applying operations or functions.

The suite also includes data for the users to try options and ideas, and helper functions for plotting spectra using other R packages available from CRAN, in particular \code{ggplot2}. There are some packages, not part of the suite itself, for data acquisition from Ocean Optics spectrometers, and application of special calibration and correction procedures to those data. A package will provide an interface to the TUV model to allow easy simulation of the solar spectrum. 

\section{The suite}

The suite consists in several packages. The main package is \code{photobiology} which contains all the generally useful functions, including many used in the other, more specialized, packages (Table \ref{tab:suite}).

\begin{table}
\newcommand{\gblt}{\textcolor{green}{$\bullet$}}
\newcommand{\yblt}{\textcolor{yellow}{$\bullet$}}
\newcommand{\rblt}{\textcolor{red}{$\bullet$}}
%\newcommand{\gblt}{{$\bullet$}}
%\newcommand{\yblt}{{$\bullet$}}
%\newcommand{\rblt}{{$\bullet$}}
\caption[Packages in the suite]{Packages in the \textsf{r4photobiology} suite. Packages not yet released are
highlighted with a red bullet \rblt, and those at `beta' stage with a yellow bullet \yblt, those relatively stable with a
green bullet \gblt.}\label{tab:suite}
\begin{small}
\begin{tabular}{clll}
\toprule
 & Package           &  Type        & Contents \\
\midrule
\gblt & photobiology      &  funs + classes & basic functions, class definitions,\\
      &                   &                 & class methods and example data \\
\midrule
\gblt & photobiologyWavebands   &  definitions & quantification of radiation \\
\midrule
\gblt & photobiologySun   &  data        & spectral data for solar radiation \\
\gblt & photobiologyLamps &  data        & spectral data for lamps \\
\gblt & photobiologyLEDs  &  data        & spectral data for LEDs \\
\gblt & photobiologyFilters  &  data     & transmittance data for filters \\
\yblt & photobiologySensors  &  data     & response data for broadband sensors \\
\midrule
\yblt & photobiologyPhy  & funs + data & phytochromes \\
\yblt & photobiologyCry  & funs + data & cryptochromes \\
\rblt & photobiologyPhot & funs + data & phototropins \\
\rblt & photobiologyUVR8 & funs + data & UVR8 \\
\midrule
\gblt & photobiologygg  & functions       & extensions to package \code{ggplot2} \\
\midrule
\rblt & rTUV             & funs + data & TUV model interface \\
\gblt & rOmniDriver      & functions   & control of Ocean Optics spectrometers \\
\bottomrule
\end{tabular}
\end{small}
\end{table}

Although by default functions expect spectral data on energy units, this is just a default that can be changed by setting the parameter \code{unit.in = "photon"}. Across all data sets and functions wavelength vectors have name \code{w.length}, spectral (energy) irradiance \code{s.e.irrad}, photon spectral irradiance \code{s.q.irrad}\footnote{\code{q} derives from `quantum'.}, absorbance ($\log_{10}$-based) \code{A}, transmittance (fraction of one) \code{Tfr}, transmittance (\%) \code{Tpc}, reflectance (fraction of one) \code{Rfr}, and reflectance (\%) \code{Rpc}.

Wavelengths should always be in nm, and when conversion between energy and photon based units takes place no scaling factor is used (an input in \wattnm yields an output in \molnm rather than \umolnm).

The suite is still under active development. Even those packages marked as `stable' are likely to acquire new functionality. By stability, we mean that we hope to be able to make most changes backwards compatible, in other words, we hope they will not break existing user code.

%%%%
\section{\lowercase{\code{r4photo}} repository}\label{sec:photoCRAN}
% \lowercase needed for page headers

I have created a small repository for the packages. This repository follows the CRAN folder structure, so now package installation can be done using just the normal R commands. This means that dependencies are installed automatically, and that automatic updates are possible. The build most suitable for the current system and R version is also picked automatically if available. It is normally recommended that you do installs and updates on a clean R session (just after starting R or RStudio).For easy installation and updates of packages, the r4photo repository can be added to the list of repositories that R knows about.

Whether you use RStudio or not it is possible to add the r4photo repository to the current session as follows, which will give you a menu of additional repositories to activate:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

If you know the indexes in the menu you can use this code, where ‘1’ and ‘6’ are the entries in the menu in the command above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{),}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Be careful not to issue this command more than once per R session, otherwise the list of repositories gets corrupted by having two repositories with the same name.

Easiest is to create a text file and name it `\code{.Rprofile}'. The commands above (and any others you would like to run at R start up) should be included, but with the addition that the package names for the functions need to be prepended. The minimum needed is.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{utils}\hlopt{::}\hlkwd{setRepositories}\hlstd{(}\hlkwc{graphics} \hlstd{=} \hlkwd{getOption}\hlstd{(}\hlstr{"menu.graphics"}\hlstd{),}
                \hlkwc{ind} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{),}
                \hlkwc{addURLs} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The \code{.Rprofile} file located in the current folder is sourced at R start up. It is also possible to have such a file affecting all of the user's R sessions, but its location is operating system dependent, it is in most cases the what the OS considers the current user's \textit{HOME} directory or folder (e.g. `My Documents' in recent versions of MS-Windows). If you are using RStudio, after setting up this file, installation and updating of the packages in the suite can take place exactly as for any other package archived at CRAN.

The commands and examples below can be used at the R prompt and in scripts whether RStudio is used or not.

After adding the repository to the session, it will appear in the menu when executing this command:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setRepositories}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
and can be enabled and disabled.

In RStudio, after adding the r4photo repository as shown above, the photobiology packages can be installed and uninstalled through the normal RStudio menus and dialogues, and will listed after typing the first few characters of their names. For example when you type ‘photob’ in the packages field, all the packages with names starting with ‘photob’ will be listed.

They can be also installed at the R command prompt with the following command:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"photobiologyAll"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}


and updated with:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}


The added repository will persist only during the current R session. Adding it permanently requires editing the R configuration file, as discussed above. Take into consideration that .Rprofile is read by R itself, and will take effect whether you use RStudio or not. It is possible to have a user wide .Rprofile file, and a different one on those folders needing different settings. There many options that can be modified by means of commands in the .Rprofile file.

\section{How to install the packages}

The examples given in this page assume that ‘r4photo’ is not in the list of repositories known to the current R session. See the section \ref{sec:photoCRAN} on the r4photo repository for a better alternative to the approach given here. We mention these other commands because they may be useful in cases when the user does not have write access to his/hers home directory, or just wants to try the packages.

To install the latest version of one package (photobiology used as example) you just need to indicate the repository. However this simple command will only install the dependencies between the different photobiology packages.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
                 \hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

To update what is already installed, this command is enough (even if the packages have been installed manually before):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{(}\hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


The best way to install the packages is to specify both the r4photo repository and a normal CRAN repository, then all dependencies will be automatically installed. The package photobiolgyAll just loads and imports all the packages in the suite, except for photobiolygg. Because of this dependency all the packages are installed unless already installed by issuing this command.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"photobiologyAll"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{),}
         \hlkwc{repos} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                     \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                   \hlkwc{CRAN} \hlstd{=}
                     \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

This example also shows how one can use an array of package names (in this example all currently available “photobiology” packages) in the call to the function install.packages, this is useful if you want to install only a subset of the files, or if you want to make sure that any older install of the packages is overwritten:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{photobiology_packages} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
    \hlstr{"photobiologyWavebands"}\hlstd{,}
    \hlstr{"photobiologyCry"}\hlstd{,} \hlstr{"photobiologyPhy"}\hlstd{,}
    \hlstr{"photobiologyLamps"}\hlstd{,} \hlstr{"photobiologyLEDs"}\hlstd{,}
    \hlstr{"photobiologySun"}\hlstd{,} \hlstr{"photobiologygg"}\hlstd{,}
    \hlstr{"photobiologyFilters"}\hlstd{,}  \hlstr{"photobiologySensors"}\hlstd{)}

\hlkwd{install.packages}\hlstd{(photobiology_packages,}
         \hlkwc{repos} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                     \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                   \hlkwc{CRAN} \hlstd{=}
                     \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The commands above install all packages in the suite and all their dependencies from CRAN if needed. The following command will update all the packages currently installed (if new versions are available) and install any new dependencies.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{(}\hlkwc{repos} \hlstd{=}
                  \hlkwd{c}\hlstd{(}\hlkwc{r4photo} \hlstd{=}
                      \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                    \hlkwc{CRAN} \hlstd{=}
                      \hlstr{"http://cran.rstudio.com"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The instructions above should work under Windows as long as you have a supported version of R (3.0.0 or later) because I have built suitable binaries, under other OSs you may need to add type="source" unless this is already the default. We will try to build OS X binaries for Mac so that installation is easier. Meanwhile if installation fails try adding type="source" to the commands given above. For example the first one would become:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"photobiology"}\hlstd{,}
                 \hlkwc{repos} \hlstd{=} \hlstr{"http://www.mv.helsinki.fi/aphalo/R"}\hlstd{,}
                 \hlkwc{type}\hlstd{=}\hlstr{"source"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


When using type=”source” you may need to install some dependencies like the splus2R package beforehand from CRAN if building it from sources fails.



\part{Cookbook of calculations}




\chapter{Radiation physics}\label{chap:physics}

\begin{abstract}
  In this chapter we explain how to code some optics and physics computations in R.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: photobiology\\\#\# Loading required package: lubridate\\\#\# Loading required package: data.table\\\#\# \\\#\# Attaching package: 'data.table'\\\#\# \\\#\# The following objects are masked from 'package:lubridate':\\\#\# \\\#\#\ \ \ \  hour, mday, month, quarter, wday, week,\\\#\#\ \ \ \  yday, year\\\#\# \\\#\# Loading required package: photobiologyWavebands\\\#\# Loading required package: proto\\\#\# Loading required package: splus2R\\\#\# Loading required package: plyr\\\#\# \\\#\# Attaching package: 'plyr'\\\#\# \\\#\# The following object is masked from 'package:lubridate':\\\#\# \\\#\#\ \ \ \  here}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\end{alltt}
\end{kframe}
\end{knitrout}



%%%%
\section{Introduction}\label{sec:physics:intro}

%%%%
\section{Task: black body emission}\label{sec:physics:intro}

The emitted spectral radiance (\radiance[s]) is described by Planck's law of black body radiation at temperature $T$, measured in degrees Kelvin (K):%\index{Planck's law of black body radiation}\index{black body spectral radiance}
%
\begin{equation}
%\radiance[s](\lambda,T) = \frac{2hc^2}{\lambda^5}\cdot\frac{1}{\exp\left\{hc/k_BT\lambda\right\}-1} \label{equ_planck}
\radiance[s](\lambda,T) = \frac{2hc^2}{\lambda^5}\cdot\frac{1}{\mathrm{e}^{(hc/k_\mathrm{B}T\lambda)}-1} \label{equ_planck}
\end{equation}
%
with Boltzmann's constant $k_\mathrm{B}=1.381\times 10^{-23}$ \Unit{J\,K^{-1}}, Planck's constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond.

We can easily define an R function based on the equation above, which returns \Unit{W\,sr^{-1}\,m^{-3}}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{h} \hlkwb{<-} \hlnum{6.626e-34} \hlcom{# J s-1}
\hlstd{c} \hlkwb{<-} \hlnum{2.998e8} \hlcom{# m s-1}
\hlstd{kB} \hlkwb{<-} \hlnum{1.381e-23} \hlcom{# J K-1}
\hlstd{black_body_spectrum} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{w.length}\hlstd{,} \hlkwc{Tabs}\hlstd{) \{}
  \hlstd{w.length} \hlkwb{<-} \hlstd{w.length} \hlopt{*} \hlnum{1e-9} \hlcom{# nm -> m}
  \hlstd{((}\hlnum{2} \hlopt{*} \hlstd{h} \hlopt{*} \hlstd{c}\hlopt{^}\hlnum{2}\hlstd{)} \hlopt{/} \hlstd{w.length}\hlopt{^}\hlnum{5}\hlstd{)} \hlopt{*}
    \hlnum{1} \hlopt{/} \hlstd{(}\hlkwd{exp}\hlstd{((h} \hlopt{*} \hlstd{c} \hlopt{/} \hlstd{(kB} \hlopt{*} \hlstd{Tabs} \hlopt{*} \hlstd{w.length)))} \hlopt{-} \hlnum{1}\hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

We can use the function for calculating black body emission spectra for different temperatures:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlnum{500}\hlstd{,} \hlnum{5000}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.212443e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

The function is vectorized:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{300}\hlstd{,}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{),} \hlnum{5000}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3.354907e+12 8.759028e+12 1.212443e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlnum{500}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{4500}\hlstd{,}\hlnum{5000}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 6.387979e+12 1.212443e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

We aware that if two vectors are supplied, then the elements in each one are matched and recycled\footnote{Exercise: calculate each of the four values individually to work out how the two vectors are being used.}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{black_body_spectrum}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{500}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{600}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{4500}\hlstd{,}\hlnum{5000}\hlstd{))} \hlcom{# tricky!}
\end{alltt}
\begin{verbatim}
## [1] 6.387979e+12 1.212443e+13 7.474587e+12
## [4] 1.277769e+13
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use the function defined above for plotting black body emission spectra for different temperatures. We use \code{ggplot2} and directly plot a function using \code{stat\_function}, using \code{args} to pass the additional argument giving the absolute temperature to be used. We plot three lines using three different temperatures (5600~K, 4500~K, and 3700~K):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{50}\hlstd{,}\hlnum{1500}\hlstd{)),} \hlkwd{aes}\hlstd{(x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{5600}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{4500}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"orange"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_spectrum,}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlnum{3700}\hlstd{),}
                \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{radiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{sr}\hlopt{^-}\hlnum{1}\hlopt{~}\hlstd{m}\hlopt{^-}\hlnum{3}\hlstd{)),}
       \hlkwc{x}\hlstd{=}\hlstr{"Wavelength (nm)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-36-1} 

}



\end{knitrout}


Wien's displacement law, gives the peak wavelength of the radiation emitted by a black body as a function of its absolute temperature.
%
\begin{equation}
\lambda_{max} \cdot T = 2.898 \times 10^6 \,\mathrm{nm\,K} \label{equ_wien}
\end{equation}
%
A function implementing this equation takes just a few lines of code:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{k.wein} \hlkwb{<-} \hlnum{2.8977721e6} \hlcom{# nm K}
\hlstd{black_body_peak_wl} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{Tabs}\hlstd{) \{}
  \hlstd{k.wein} \hlopt{/} \hlstd{Tabs}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

It can be used to plot the temperature dependence of the location of the wavelength at which radiance is at its maximum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=}\hlkwd{data.frame}\hlstd{(}\hlkwc{Tabs}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{2000}\hlstd{,}\hlnum{7000}\hlstd{)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=Tabs))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=black_body_peak_wl)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Temperature (K)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Wavelength at peak of emission (nm)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-38-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologygg))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2))}
\end{alltt}
\end{kframe}
\end{knitrout}




\chapter{Astronomy}\label{chap:astronomy}

\begin{abstract}
  In this chapter we explain how to code some astronomical computations in R.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(lubridate)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggmap)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:astro:intro}

This chapter deals with calculations that require times and/or dates as arguments. One could use R's built-in functions for POSIXct but package \code{lubridate} makes working with dates and times, much easier. Package \code{lubridate} defines functions for decoding dates represented as character strings, and for manipulating dates and doing calcualtions on dates. Each one of the different functions shown in the code chunk below can decode dates in different formats as long as the year, month and date order in the string agrees with the name of the function:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"20140320"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014-03-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"14-03-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014-3-20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2014/3/20"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{dmy}\hlstd{(}\hlstr{"20032014"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{mdy}\hlstd{(}\hlstr{"03202014"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2014-03-20 UTC"
\end{verbatim}
\end{kframe}
\end{knitrout}

For astronomical calculations we need as argument the geographical coordinates. It is, of course, possible to enter latitude and longitude values recorded with a GPS instrument or manually obtained from a map. However, when the location is searchable through Google Maps, it is also possible to obtain the coordinates by means of a query from within R using packages \code{RgoogleMaps}, or package \code{ggmap}, as done here. When inputing coordinate values manually, they should in degrees as numeric values (in other words the fractional part is given as part of floating point numberin degrees, and not as separate integers representing minutes and seconds of degree).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 24.94 60.17
\end{verbatim}
\begin{alltt}
\hlkwd{geocode}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki, Finland"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 25.02 60.23
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating the length of the photoperiod}\label{sec:astro:photoperiod}

In function \code{day\_night} from our \code{photobiology} package we use function \code{sun\_angles}, which is an edited version of function \code{sunAngle} from package \code{ode}, to calculate the altitude or elevation of the sun. We first find local solar noon by finding the maximal solar elevation, and then search for sunrise in the first half of the day and for sunset in the second half, defined based on the local solar noon. Sunset and sunrise are by default based on a solar elevation angle equal to zero. The argument \code{twilight} can be used to set the angle according to different conventions.

In the examples we use \code{geocode} to get the latitude and longitude of cities. \code{geocode} accepts any valid Google Maps search terms, including street addresses, and postal codes within cities. \code{day\_night} returns a list containing the times at sunrise, sunset and noon, and day- and night lengths. This first example is for Buenos Aires on two different dates, by use of the optional argument \code{tz} we request the results to be expressed in local time for Buenos Aires.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_BA} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Buenos Aires"}\hlstd{)}
\hlstd{geo_code_BA}
\end{alltt}
\begin{verbatim}
##      lon   lat
## 1 -58.38 -34.6
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-12-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_BA[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_BA[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"America/Argentina/Buenos_Aires"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-12-21 UTC"
## 
## $sunrise
## [1] "2013-12-21 05:42:00 ART"
## 
## $noon
## [1] "2013-12-21 12:51:46 ART"
## 
## $sunset
## [1] "2013-12-21 20:01:32 ART"
## 
## $daylength
## Time difference of 14.33 hours
## 
## $nightlength
## Time difference of 9.675 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-06-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_BA[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_BA[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"America/Argentina/Buenos_Aires"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-06-21 UTC"
## 
## $sunrise
## [1] "2013-06-21 08:04:57 ART"
## 
## $noon
## [1] "2013-06-21 12:55:32 ART"
## 
## $sunset
## [1] "2013-06-21 17:45:49 ART"
## 
## $daylength
## Time difference of 9.681 hours
## 
## $nightlength
## Time difference of 14.32 hours
\end{verbatim}
\end{kframe}
\end{knitrout}

We here repeat the same calculations for Munich on the same days ---note that the output for December is in "EET" time coordinates, and for June it is in "EEST", i.e.\ in `winter-' and `summer time' coordinates.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_Mu} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Munich"}\hlstd{)}
\hlstd{geo_code_Mu}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 11.58 48.14
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-12-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_Mu[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_Mu[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"Europe/Berlin"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-12-21 UTC"
## 
## $sunrise
## [1] "2013-12-21 08:07:27 CET"
## 
## $noon
## [1] "2013-12-21 12:11:49 CET"
## 
## $sunset
## [1] "2013-12-21 16:16:11 CET"
## 
## $daylength
## Time difference of 8.146 hours
## 
## $nightlength
## Time difference of 15.85 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-06-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_Mu[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_Mu[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{tz}\hlstd{=}\hlstr{"Europe/Berlin"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-06-21 UTC"
## 
## $sunrise
## [1] "2013-06-21 05:19:41 CEST"
## 
## $noon
## [1] "2013-06-21 13:15:29 CEST"
## 
## $sunset
## [1] "2013-06-21 21:11:16 CEST"
## 
## $daylength
## Time difference of 15.86 hours
## 
## $nightlength
## Time difference of 8.14 hours
\end{verbatim}
\end{kframe}
\end{knitrout}

As a final example, we calculate day length based on different definitions of twilight for Helsinki, at the equinox:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_He} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\hlstd{geo_code_He}
\end{alltt}
\begin{verbatim}
##     lon   lat
## 1 24.94 60.17
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 07:08:45 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 19:16:23 EEST"
## 
## $daylength
## Time difference of 12.13 hours
## 
## $nightlength
## Time difference of 11.87 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"civil"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 07:57:16 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 18:28:02 EEST"
## 
## $daylength
## Time difference of 10.51 hours
## 
## $nightlength
## Time difference of 13.49 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"nautical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 08:47:20 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 17:38:05 EEST"
## 
## $daylength
## Time difference of 8.846 hours
## 
## $nightlength
## Time difference of 15.15 hours
\end{verbatim}
\begin{alltt}
\hlkwd{day_night}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2013-09-21"}\hlstd{),}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
          \hlkwc{twilight}\hlstd{=}\hlstr{"astronomical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $day
## [1] "2013-09-21 UTC"
## 
## $sunrise
## [1] "2013-09-21 09:41:31 EEST"
## 
## $noon
## [1] "2013-09-21 13:12:49 EEST"
## 
## $sunset
## [1] "2013-09-21 16:44:00 EEST"
## 
## $daylength
## Time difference of 7.041 hours
## 
## $nightlength
## Time difference of 16.96 hours
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Task: calculating the position of the sun}\label{sec:astro:position}

\code{sun\_angles} not only returns solar elevation, but all the angles defining the position of the sun. The time argument to \code{sun\_angles} is internally converted to UTC (universal time coordinates, which is equal to GMT) time zone, so time defined for any time zone is valid input. The time zone used for the output is by default that currently in use in the computer on which R is running, but we can easily specify the time coordinates used for the output with parameter \code{tz}, using any string accepted by package \code{lubridate}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{geo_code_Jo} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Joensuu"}\hlstd{)}
\hlstd{geo_code_Jo}
\end{alltt}
\begin{verbatim}
##     lon  lat
## 1 29.76 62.6
\end{verbatim}
\begin{alltt}
\hlstd{my_time} \hlkwb{<-} \hlkwd{ymd_hms}\hlstd{(}\hlstr{"2014-05-29 18:00:00"}\hlstd{,} \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
\hlkwd{sun_angles}\hlstd{(my_time,}
         \hlkwc{lon} \hlstd{= geo_code_Jo[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_Jo[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $time
## [1] "2014-05-29 18:00:00 EEST"
## 
## $azimuth
## [1] 267.6
## 
## $elevation
## [1] 25.82
## 
## $diameter
## [1] 0.526
## 
## $distance
## [1] 1.014
\end{verbatim}
\end{kframe}
\end{knitrout}

We can calculate the current position of the sun, in this case giving the position of the sun in the sky of Joensuu when this .PDF file was generated.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sun_angles}\hlstd{(}\hlkwd{now}\hlstd{(),}
         \hlkwc{lon} \hlstd{= geo_code_Jo[[}\hlstr{"lon"}\hlstd{]],} \hlkwc{lat} \hlstd{= geo_code_Jo[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## $time
## [1] "2014-11-15 08:43:59 EET"
## 
## $azimuth
## [1] 137.5265
## 
## $elevation
## [1] 1.448004
## 
## $diameter
## [1] 0.5390345
## 
## $distance
## [1] 0.9891759
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Task: plotting sun elevation through a day}

Function \code{sun\_angles} described above is vectorized, so it is very easy to calculate the position of the sun throughout a day at a given location on Earth. The example here uses sun only elevation, plotted for Helsinki through the course of 23 June 2014. We first a vector of times, using \code{seq} which can not only be used with numbers, but also with dates. Note that \code{by} is specified as a string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{opts_chunk}\hlopt{$}\hlkwd{set}\hlstd{(opts_fig_wide)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hours} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-06-23"}\hlstd{,} \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{),}
             \hlkwc{by}\hlstd{=}\hlstr{"10 min"}\hlstd{,}
             \hlkwc{length}\hlstd{=}\hlnum{24} \hlopt{*} \hlnum{6}\hlstd{)}
\hlstd{elevations} \hlkwb{<-} \hlkwd{sun_angles}\hlstd{(hours,}
          \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
          \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}\hlopt{$}\hlstd{elevation}
\hlstd{sun_elev_hel} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{time_eet} \hlstd{= hours,}
                            \hlkwc{elevation} \hlstd{= elevations,}
                            \hlkwc{location} \hlstd{=} \hlstr{"Helsinki"}\hlstd{,}
                            \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
                           \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\end{alltt}
\end{kframe}
\end{knitrout}

We also create a small data frame with data for plotting and labeling the different twilight conventions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{twilight} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlopt{-}\hlnum{6}\hlstd{,} \hlopt{-}\hlnum{12}\hlstd{,} \hlopt{-}\hlnum{18}\hlstd{),}
             \hlkwc{label} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Horizon"}\hlstd{,} \hlstr{"Civil twilight"}\hlstd{,}
                       \hlstr{"Nautical twilight"}\hlstd{,}
                       \hlstr{"Astronomical twilight"}\hlstd{),}
             \hlkwc{time} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{ymd_hms}\hlstd{(}\hlstr{"2014-06-23 12:00:00"}\hlstd{,}
                                \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{),}
                        \hlnum{4}\hlstd{) )}
\end{alltt}
\end{kframe}
\end{knitrout}

We draw a plot using the data frames created above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(sun_elev_hel,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= time_eet,} \hlkwc{y} \hlstd{= elevation))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_hline}\hlstd{(}\hlkwc{data}\hlstd{=twilight,}
             \hlkwd{aes}\hlstd{(}\hlkwc{yintercept} \hlstd{= angle,} \hlkwc{linetype}\hlstd{=}\hlkwd{factor}\hlstd{(label)))} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{x}\hlstd{=twilight}\hlopt{$}\hlstd{time,} \hlkwc{y}\hlstd{=twilight}\hlopt{$}\hlstd{angle,}
           \hlkwc{label}\hlstd{=twilight}\hlopt{$}\hlstd{label,} \hlkwc{vjust}\hlstd{=}\hlopt{-}\hlnum{0.4}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=} \hlstr{"Solar elevation at Helsinki (degrees)"}\hlstd{,}
       \hlkwc{x} \hlstd{=} \hlstr{"Time EEST"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-astro-8-1} 

}



\end{knitrout}

\section{Task: plotting day length through the year}

For this we first need to generate a sequence of dates. We use \code{seq} as in the previous section, but instead of supplying a length as argument we supply an ending time. Instead of giving \code{by} in minutes as above, we now use days:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{days} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-01-01"}\hlstd{),} \hlkwc{to}\hlstd{=}\hlkwd{ymd}\hlstd{(}\hlstr{"2014-12-31"}\hlstd{),}
            \hlkwc{by}\hlstd{=}\hlstr{"3 day"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

To calculate the length of each day, we need to use an explicit loop as function \code{day\_night} is not vectorized. We repeat the calculations for three locations at different latitudes, then row bind the data frames into a single data frame. Each individual data frame contains information to identify the sites:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{len_days} \hlkwb{<-} \hlkwd{length}\hlstd{(days)}
\hlstd{photoperiods} \hlkwb{<-} \hlkwd{numeric}\hlstd{(len_days)}
\hlstd{geo_code_He} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Helsinki"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_hel} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Helsinki"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_He[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_He[[}\hlstr{"lat"}\hlstd{]])}
\hlstd{geo_code_Iv} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Ivalo"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_Iv[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_Iv[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_ivalo} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Ivalo"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_Iv[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_Iv[[}\hlstr{"lat"}\hlstd{]])}
\hlstd{geo_code_At} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Athens, Greece"}\hlstd{)}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{len_days) \{}
  \hlstd{day_night.ls} \hlkwb{<-} \hlkwd{day_night}\hlstd{(days[i],}
                            \hlkwc{lon} \hlstd{= geo_code_At[[}\hlstr{"lon"}\hlstd{]],}
                            \hlkwc{lat} \hlstd{= geo_code_At[[}\hlstr{"lat"}\hlstd{]],}
                            \hlkwc{tz}\hlstd{=}\hlstr{"EET"}\hlstd{)}
  \hlstd{photoperiods[i]} \hlkwb{<-}
    \hlkwd{as.numeric}\hlstd{(day_night.ls[[}\hlstr{"daylength"}\hlstd{]],}
               \hlkwc{units}\hlstd{=}\hlstr{"hours"}\hlstd{)}
\hlstd{\}}
\hlstd{daylengths_athens} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{day} \hlstd{= days,}
             \hlkwc{daylength} \hlstd{= photoperiods,}
             \hlkwc{location}\hlstd{=}\hlstr{"Athens"}\hlstd{,}
             \hlkwc{lon} \hlstd{= geo_code_At[[}\hlstr{"lon"}\hlstd{]],}
             \hlkwc{lat} \hlstd{= geo_code_At[[}\hlstr{"lat"}\hlstd{]])}

\hlstd{daylengths} \hlkwb{<-} \hlkwd{rbind}\hlstd{(daylengths_hel,}
                    \hlstd{daylengths_ivalo,}
                    \hlstd{daylengths_athens)}
\end{alltt}
\end{kframe}
\end{knitrout}

Once we have the data available, plotting is simple:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(daylengths,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= day,} \hlkwc{y} \hlstd{= daylength,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(location)))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{6}\hlstd{,}\hlnum{12}\hlstd{,}\hlnum{18}\hlstd{,}\hlnum{24}\hlstd{),} \hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{24}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Date"}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"Daylength (h)"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"Location"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-astro-11-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{lubridate))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggmap))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2))}
\end{alltt}
\end{kframe}
\end{knitrout}




\chapter{Basic operations on spectra}\label{chap:base}

\begin{abstract}
  In this chapter we describe the objects used to store data and functions and operators for basic operations. We also give some examples of operating on these objects and their components using normal R functions and operators.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}

The suite uses object-oriented programming for its higher level `user-friendly' syntax. Objects are implemented using ``S3'' classes. The two main distinct kinds of objects are different types of spectra, and wavebands. Spectral objects contain, as their name implies, spectral data. Wavebands contain the information needed to calculate irradiance, non-weighted or weighted (effective), and a name and a label to be used in output printing. Functions and operators are defined for operations on these objects, alone and in combination. We will first describe spectra, and then wavebands, in each case describing operators and functions. Towards the end of the chapter we describe  

\section{Spectra}\label{sec:spct:objects}

\subsection{How are spectra stored?}

For spectra the classes are a specialization of \code{data.table} which are in turn a specialization of \code{data.frame}. This means that they are compatible with functions that operate on these classes.

\sloppy
The suite defines a \code{generic.spct} class, from which two specialized classes, `\code{filter.spct}, \code{reflector.spct}, \code{source.spct}, \code{response.spct} and \code{chroma.spct} are derived. Having this class structure allows us to create special methods and operators, which use the same names than the generic ones defined by R itself, but take into account the special properties of spectra. Each spectrum object can hold only one spectrum.

Objects of class \code{generic.spct} one one mandatory component \code{w.length}, containing wavelength values in \Unit{nm}. 

Objects of class \code{source.spct} have two mandatory components \code{w.length}, and \code{s.e.irrad}, and an optional one, \code{s.q.irrad}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, \wattnm for \code{s.e.irrad}, and \molnm for \code{s.q.irrad}. Objects can have a ``comment'' attribute with a textual description. Additional columns are ignored, but not deleted, unless the operation applied could invalidate them.

Objects of class \code{filter.spct} have two mandatory components \code{w.length}, and \code{Tfr} and two optional components,\code{Tpc} and \code{A}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Tfr}, and \% for \code{Tpc}. Absorbance \code{A} values are expected to be expressed based on $\log_{10}$. Objects have a ``comment'' attribute with a textual description.

Objects of class \code{reflector.spct} have two mandatory components \code{w.length}, and \code{Rfr} and one optional components,\code{Rpc}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Rfr}, and \% for \code{Rpc}. Objects have a ``comment'' attribute with a textual description.

Objects of class \code{chroma.spct} have four mandatory components \code{w.length}, and \code{x, y, z} giving the chromaticity coordinates for trichromic vision.

Objects of class \code{response.spct} have two mandatory components \code{w.length}, and \code{response} giving the spectral response.

\subsection{How can the user create spectra from his own data}

If the data is already stored in a data frame or data table, or even a list, and if the components have one of the recognized ``standard'' names, specific \code{setGenericSpct}, \code{setSourceSpct}, \code{setFilterSpct}, \code{setReflectorSpct} commands can be used to change the class attribute and check that the object is valid. These functions have the same semantics as \code{setDT} and \code{setDF} from package \code{data.table}, they modify their argument directly---the argument is passed by \emph{reference} instead of by \emph{copy} as is usual in R. As \code{sun.data} is part of the package, we need to make a copy before modifying it, with one's own data frames or data tables this step is not need.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlstd{sun.data}
\hlkwd{setSourceSpct}\hlstd{(my_sun.spct)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can query the class of an object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(my_sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{is}\hlstd{(my_sun.spct,} \hlstr{"source.spct"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Table \ref{tab:obj:components} lists the different `names' understood by these functions, and the required and optional components of the different object classes.

\begin{table}
\caption{Names of spectral object components, and the additional names recognized during automatic spectral object creation, and the units of expression.}\label{tab:obj:components}
\begin{center}
\begin{tabular}{lllll}
\toprule
Class    & required & optional & recognized & units\\
\midrule
generic.spct & w.length & --- & wl, wavelength & nm\\
\midrule
source.spct & w.length & --- & wl, wavelength & nm\\
            & s.e.irrad & --- & irradiance & \wattnm\\
            & ---       & s.q.irrad & --- & \molnm\\
\midrule
filter.spct & w.length & --- & wl, wavelength & nm \\
            & Tfr      & --- & --- & $x/1$  \\
            & ---      & Tpc    & transmittance & \% \\
            & ---      & A      & absorbance & a.u. $\log_{10}$-based\\
\midrule
reflector.spct & w.length & --- & wl, wavelength \\
            & Rfr      & --- & --- & $x/1$  \\
            & ---      & Rpc    & reflectance & \% \\
\midrule
response.spct & w.length & --- & wl, wavelength & nm\\
            & response   & --- & response & arbitrary u.\\
%            & ---       & resp.actual & --- & absolute u.\\
\midrule
chroma.spct & w.length & --- & wl, wavelength & nm\\
            & x, y, z  & ---    & X, Y, Z & relative u.\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{What operators are available for operations between spectra?}

All operations with spectral objects affect only the required components listed in Table \ref{tab:obj:components}, all optional components are deleted, while unrecognized components are left alone. There will be seldom need to add numerical components, and the user should take into account that the paradigm of the suite is that each spectrum is stored as a separate object. However, it is allowed, and possibly useful to have factors as components with levels identifying different bands, or color vectors with RGB values. Ancilary information information useful for presentation and plotting might sometimes be useful.

Several operators are defined for spectral objects. Using operators is an easy and familiar way of doing calculations, but operators are rather inflexible (they can take at most two arguments, the operands) and performance is slower than with functions with additional parameters that allow optimizing the algorithm. The operators are defined so that an operation between two \code{filter.spct} objects yields another \code{filter.spct} object, an operation between two \code{reflector.spct} yields a \code{reflector.spct} object, and operations between a \code{filter.spct} object and a \code{source.spct}, between a \code{reflector.spct} and a \code{source.spct}, or between two \code{source.spct} objects yields a \code{source.spct} object. The object returned contains data only for the overlapping region of wavelengths. The objects do NOT need to have values at the same wavelengths, as interpolation is handled transparently. All four basic maths operations are supported with any combination of spectra, and the user is responsible for deciding which calculations make sense and which not. Operations can be concatenated and combined. The unary negation operator is also implemented.

\subsection{What operators are available for operations between spectra and numeric vectors?}

The same four basic math operators plus power (`\verb|^|') are defined for the case when the first term or factor is a spectrum and the second one a numeric vector, possibly of length one. Recycling rules apply. These operations do not alter \code{w.length}, just the other \textit{required} components such as spectral irradiance and transmittance. The optional components are deleted as they can be recalculated if needed. Unrecognized `user' components are left unchanged.

\subsection{What math functions are available for operations on spectra?}

Logarithms (\code{log, log10}), square root (\code{sqrt}) and exponentiation (\code{exp}) are defined for spectra. These functions are not applied on \code{w.length}, but instead to the other mandatory component \code{s.e.irrad}, \code{Rfr} or \code{Tfr}. Any optional numeric components are discarded. (Other user-supplied components should remain unchanged, but this needs further checking!)

\subsection{What `summary' functions are available for spectra?}

The R functions \code{summary, print} work using their \code{data.table} definitions, however, there are special versions of \code{range, min, max} that when applied to spectra return values corresponding to wavelengths, two other generic functions defined in the suite give additional summaries of spectra \code{spread, midpoint}.

\subsection{Examples}

Package \code{phobiologyFilters} makes available many different filter spectra, from which we choose Schott filter GG400. Package \code{photobiology} makes available one example solar spectrum. Using these data we will simulate the filtered solar spectrum.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct}
\hlstd{filtered_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad
##   1:      293 2.609665e-11
##   2:      294 6.142401e-11
##   3:      295 2.176175e-10
##   4:      296 6.780119e-10
##   5:      297 1.533491e-09
##  ---                      
## 504:      796 3.958198e-01
## 505:      797 4.016967e-01
## 506:      798 4.109192e-01
## 507:      799 4.060274e-01
## 508:      800 3.946984e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

The GG440 data is for internal transmittance, consequently the results above would be close to the truth only for filters treated with an anti-reflexion multicoating. Let's assume a filter with 9\% reflectance across all wavelengths (a coarse approximation for uncoated glass):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_uncoated_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct} \hlopt{*} \hlstd{(}\hlnum{100} \hlopt{-} \hlnum{9}\hlstd{)} \hlopt{/} \hlnum{100}
\hlstd{filtered_uncoated_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad
##   1:      293 2.374795e-11
##   2:      294 5.589585e-11
##   3:      295 1.980319e-10
##   4:      296 6.169908e-10
##   5:      297 1.395476e-09
##  ---                      
## 504:      796 3.601960e-01
## 505:      797 3.655440e-01
## 506:      798 3.739365e-01
## 507:      799 3.694849e-01
## 508:      800 3.591755e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

Calculations related to filters will be explained in detail in chapter \ref{chap:filters}. This is just an example of how the operators work, even when, as in this example, the wavelength values do not coincide bertween the two spectra.

%%%%
\subsection{Task: uniform scaling of a spectrum}\label{sec:base:scale}

As noted above operators are available for \code{generic.scpt}, \code{source.spct}, \code{filter.spct} and \code{reflector.spct} objects, and `recycling' takes places when needed:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{sun.spct} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad
##   1:      293 5.219330e-06
##   2:      294 1.228480e-05
##   3:      295 4.352350e-05
##   4:      296 1.356024e-04
##   5:      297 3.066981e-04
##  ---                      
## 504:      796 8.161233e-01
## 505:      797 8.282407e-01
## 506:      798 8.472561e-01
## 507:      799 8.371699e-01
## 508:      800 8.138111e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, but when operating between a spectrum an a numeric value the spectrum should be the first term or factor. If an operation on a ``source.spct'' would yield different values for data on energy and photon basis, only the value based on energy data is returned in \code{s.e.irrad} and \code{s.q.irrad} is set to NA.

%%%%
\subsection{Task: simple operations between two spectra}\label{sec:base:simple:opper}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{ug1.spct} \hlopt{*} \hlstd{sun.spct}
\hlstd{filtered_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad
##   1:      293 2.286067e-07
##   2:      294 6.191540e-07
##   3:      295 2.480839e-06
##   4:      296 8.624311e-06
##   5:      297 2.153021e-05
##  ---                      
## 504:      796 1.069122e-01
## 505:      797 1.072572e-01
## 506:      798 1.084488e-01
## 507:      799 1.059020e-01
## 508:      800 1.017264e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, and they can be combined into equations.

%%%%
\subsection{Task: arithmetic operations within one spectrum}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can simply use the built in R mat operators on vectors (e.g.\ when only individual vectors are available, or a data frame). These operators are vectorized, which means that an addition between two vectors adds the elements at each position. A non-nonsensical example follows using R syntax on a data frame, returning a vector.

Using data frame syntax on a data frame, data table or spectral object, returning a vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.spct, s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length)}
\end{alltt}
\end{kframe}
\end{knitrout}

Using data table syntax on a data table or spectral object, returning a vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlstd{sun.spct[ , s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length]}
\end{alltt}
\end{kframe}
\end{knitrout}

Using data table syntax, adding the result to the \code{data.table} object, or a \code{\_\_\_.spct} object:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# run}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_sun.spct[ , result} \hlkwb{:=} \hlstd{s.e.irrad}\hlopt{^}\hlnum{2} \hlopt{/} \hlstd{w.length]}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
##            result
##   1: 2.324352e-14
##   2: 1.283302e-13
##   3: 1.605335e-12
##   4: 1.553041e-11
##   5: 7.917823e-11
##  ---             
## 504: 2.091888e-04
## 505: 2.151765e-04
## 506: 2.248882e-04
## 507: 2.192908e-04
## 508: 2.069651e-04
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Task: other operations between two spectra}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can simply use the built in R math operators. These operators are vectorized, which means that an addition between two vectors adds the elements at the same index position in the two vectors with data, in this case for two different spectra. So, they do not differ from the examples in the previous section for normal R syntax. Data table syntax is no longer so convenient in this case.

In contrast to the previous case, operations using built-in R operators cannot be done if the wavelengths in two spectral data sets are not matched. In this situation is when functions and operators defined in package \code{photobiology} come to the rescue by transparently making the two operand spectra compatible by interpolation. The result they return includes all the individual wavelength values (the set union of the wavelengths from the two spectra in the region where they overlap). The functions are \code{sum\_spectra}, \code{subt\_spectra}, \code{prod\_spectra}, \code{div\_spectra}, and \code{oper\_spectra}. Here is a very simple hypothetical example:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlstd{out1.dt} \hlkwb{<-} \hlkwd{sum_spectra}\hlstd{(spc1}\hlopt{$}\hlstd{w.length, spc2}\hlopt{$}\hlstd{w.length,}
                       \hlstd{spc1}\hlopt{$}\hlstd{s.e.irrad, spc2}\hlopt{$}\hlstd{s.e.irrad)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can achieve the same result, with simpler syntax, using spectral objects and the corresponding operators. The actual computations are done in both cases by the same code, but the example below adds some ``syntactic sugar'' to make the script code more readable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{out2.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{+} \hlstd{sun.spct}
\hlstd{out3.spct} \hlkwb{<-} \hlkwd{e2q}\hlstd{(sun.spct} \hlopt{+} \hlstd{sun.spct)}
\hlstd{out3.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 5.219330e-06 1.278346e-11
##   2:      294 1.228480e-05 3.019128e-11
##   3:      295 4.352350e-05 1.073277e-10
##   4:      296 1.356024e-04 3.355251e-10
##   5:      297 3.066981e-04 7.614363e-10
##  ---                                   
## 504:      796 8.161233e-01 5.430438e-06
## 505:      797 8.282407e-01 5.517990e-06
## 506:      798 8.472561e-01 5.651759e-06
## 507:      799 8.371699e-01 5.591475e-06
## 508:      800 8.138111e-01 5.442264e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

In both cases only spectral energy irradiance is calculated during the summing operation, while in the second example, it is simple to convert the returned spectral energy irradiance values into spectral photon irradiance. \code{out1.data} is a "data.table", while the second will be a spectrum of a class dependent on the classes of \code{spc1} and \code{spc2}. Obviously, the second calculation will be slower, but in most cases unnoticeable so\footnote{The reason behind keeping \code{e2q} as a separately called function is that otherwise calculations would be slowed-down by doing the conversion when it is not needed, either at intermediate steps in the calculation, or when the user has no use for the result}.

The function \code{oper\_spectra} takes the operator to use as an argument, and this abstraction both simplifies the package code, and also makes it easy for users to add other operators if needed:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{out.data} \hlkwb{<-} \hlkwd{oper_spectra}\hlstd{(spc1}\hlopt{$}\hlstd{w.length, spc2}\hlopt{$}\hlstd{w.length,}
                         \hlstd{spc1}\hlopt{$}\hlstd{s.e.irrad, spc2}\hlopt{$}\hlstd{s.e.irrad,}
                         \hlkwc{bin.oper}\hlstd{=`^`)}
\end{alltt}
\end{kframe}
\end{knitrout}

and yields one spectrum to a power of a second one. Such additional functions are not predefined, as I cannot think of any use for them. \code{oper\_spectra} is used internally to define the functions for the four basic maths operators, and the corresponding operators.

\subsection{Task: trimming a spectrum}\label{sec:base:trim}

This is basically a subsetting operation, but our functions operate only based on wavelengths, while R \code{subset} is more general. On the other hand, our functions \code{trim\_spct} and \code{trim\_tails} add a few `bells and whistles'. The trimming is based on wavelengths and by default the cut points are inserted by interpolation, so that the spectrum returned includes the limits given as arguments. In addition, by default the trimming is done by deleting both spectral irradiance and wavelength values outside the range delimited by the limits (just like \code{subset} does), but through parameter \code{fill} the values outside the limits can be replaced by any value desired (most commonly \code{NA} or 0.) It is possible to supply only one, or both of \code{low.limit} and \code{high.limit}, depending on the desired trimming, or use a \code{waveband} definition. If the limits are outside the original data set, then the output spectrum is expanded and the tails filled with the value given as argument for \code{fill}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwd{UV}\hlstd{())}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in trim\_spct(my\_sun.spct, UV()): Not trimming short end as low.limit is outside spectral data range.}}\begin{alltt}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwd{UV}\hlstd{(),} \hlkwc{fill}\hlstd{=}\hlnum{0}\hlstd{)}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwc{low.limit}\hlstd{=}\hlnum{400}\hlstd{)}
\hlkwd{trim_spct}\hlstd{(my_sun.spct,} \hlkwc{low.limit}\hlstd{=}\hlnum{250}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\code{trim\_tails} can be used for trimming spectra when data is available as vectors. We here present different examples for both functions, we encourage readers to try to reproduce all examples using both functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlkwa{NULL}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{NA}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

If the limits are outside the range of the input spectral data, and \code{fill} is set to a value other than \code{NULL} the output is expanded up to the limits and filled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{NA}\hlstd{))}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{trim_tails}\hlstd{(w.length, s.e.irrad,}
                \hlkwc{low.limit}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{high.limit}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Task: conversion from energy to photon base}\label{sec:base:e2q}

The energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ_energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ_energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ_energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ_molenergy}
\label{eq:energy:mol:photons}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ_energy} while \code{as\_quantum\_mol} uses equation \ref{equ_molenergy}. To obtain \umol we multiply by $10^6$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as_quantum_mol}\hlstd{(}\hlnum{550}\hlstd{,} \hlnum{200}\hlstd{)} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## [1] 919.5147
\end{verbatim}
\end{kframe}
\end{knitrout}

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorized, so they can be applied to whole spectra (when data are available as vectors), to convert \wattnm to \molnm:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(sun.data}\hlopt{$}\hlstd{s.e.irrad,} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 2.609665e-06 6.142401e-06 2.176175e-05
##  [4] 6.780119e-05 1.533491e-04 3.669677e-04
##  [7] 7.845430e-04 1.264554e-03 2.623718e-03
## [10] 3.922583e-03
\end{verbatim}
\begin{alltt}
\hlstd{s.q.irrad} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,}
                  \hlkwd{as_quantum_mol}\hlstd{(w.length, s.e.irrad))}
\hlkwd{head}\hlstd{(s.q.irrad,} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 6.391730e-12 1.509564e-11 5.366385e-11
##  [4] 1.677626e-10 3.807181e-10 9.141345e-10
##  [7] 1.960893e-09 3.171207e-09 6.601607e-09
## [10] 9.902505e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

Once again, easiest is to use spectral objects. The default is to add \code{s.q.irrad} to the source spectrum, unless it is already present in the object in which case values are not recalculated.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{e2q}\hlstd{(my_sun.spct)}
\end{alltt}
\end{kframe}
\end{knitrout}

\code{e2q} has a parameter \code{action}, with default \code{"add"}. Another valid argument value is \code{"replace"}, but it should be used with extreme care, as the returned object, is no longer a \code{source.spct} object and is not compatible with all operators and functions defined for \code{source.spct} objects.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{e2q}\hlstd{(my_sun.spct,} \hlstr{"replace"}\hlstd{)}
\hlstd{my_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Task: conversion from photon to energy base}\label{sec:base:q2e}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

In \cite{Aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ_energy} and \ref{equ_molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output from \code{as\_energy} is expressed in \jmole we multiply the result by $10^{-3}$ to obtain \kjmole:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as_energy}\hlstd{(}\hlnum{600}\hlstd{,} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{1e-3}
\end{alltt}
\begin{verbatim}
## [1] 199.3805
\end{verbatim}
\begin{alltt}
\hlkwd{as_energy}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{1e-3}
\end{alltt}
\begin{verbatim}
## [1] 398.7611
\end{verbatim}
\end{kframe}
\end{knitrout}

Because of vectorization we can also operate on a whole spectrum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{s.e.irrad} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,} \hlkwd{as_energy}\hlstd{(w.length, s.q.irrad))}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \code{q2e} is the reverse of \code{e2q}, it is rarely needed in user code and \code{source.spct} objects almost always contain \code{s.e.irrad}. It can also be used as a roundabout way of removing a \code{s.q.irrad} column, which cloud be usefull when some objects may be missing spectral energy itrradiance data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{q2e}\hlstd{(my_sun.spct,} \hlstr{"replace"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Otherwise it feels more natural to use the following data.table syntax:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_sun.spct[ , s.q.irrad} \hlkwb{:=} \hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad
##   1:      293 2.609665e-06
##   2:      294 6.142401e-06
##   3:      295 2.176175e-05
##   4:      296 6.780119e-05
##   5:      297 1.533491e-04
##  ---                      
## 504:      796 4.080616e-01
## 505:      797 4.141204e-01
## 506:      798 4.236281e-01
## 507:      799 4.185850e-01
## 508:      800 4.069055e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

As we have seen above by default \code{q2e} and \code{e2q} return a modified copy of the spectrum as a new object. This is safe, but inefficient in use of memory and computing resources. We first copy the data to a new object, and delete the \code{s.e.irrad} variable, so that we can test the use of the functions by reference.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad    s.q.irrad
##   1:      293 2.609665e-06 6.391730e-12
##   2:      294 6.142401e-06 1.509564e-11
##   3:      295 2.176175e-05 5.366385e-11
##   4:      296 6.780119e-05 1.677626e-10
##   5:      297 1.533491e-04 3.807181e-10
##  ---                                   
## 504:      796 4.080616e-01 2.715219e-06
## 505:      797 4.141204e-01 2.758995e-06
## 506:      798 4.236281e-01 2.825879e-06
## 507:      799 4.185850e-01 2.795738e-06
## 508:      800 4.069055e-01 2.721132e-06
\end{verbatim}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_sun.spct[ , s.e.irrad} \hlkwb{:=} \hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length    s.q.irrad
##   1:      293 6.391730e-12
##   2:      294 1.509564e-11
##   3:      295 5.366385e-11
##   4:      296 1.677626e-10
##   5:      297 3.807181e-10
##  ---                      
## 504:      796 2.715219e-06
## 505:      797 2.758995e-06
## 506:      798 2.825879e-06
## 507:      799 2.795738e-06
## 508:      800 2.721132e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

When parameter \code{byref} is given \code{TRUE} as argument the original spectrum is modified.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q2e}\hlstd{(my_sun.spct,} \hlkwc{byref}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\hlstd{my_sun.spct}
\end{alltt}
\begin{verbatim}
##      w.length    s.q.irrad    s.e.irrad
##   1:      293 6.391730e-12 2.609665e-06
##   2:      294 1.509564e-11 6.142401e-06
##   3:      295 5.366385e-11 2.176175e-05
##   4:      296 1.677626e-10 6.780119e-05
##   5:      297 3.807181e-10 1.533491e-04
##  ---                                   
## 504:      796 2.715219e-06 4.080616e-01
## 505:      797 2.758995e-06 4.141204e-01
## 506:      798 2.825879e-06 4.236281e-01
## 507:      799 2.795738e-06 4.185850e-01
## 508:      800 2.721132e-06 4.069055e-01
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Task: interpolating a spectrum}\label{sec:base:interpol}

Functions \code{interpolate\_spct} and \code{interpolate\_spectrum} allow interpolation to different wavelength values. \code{interpolate\_spectrum} is used internally, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible in the data analysis.

In this example we generate interpolated data for the range 280~nm to 300~nm at 1~nm steps, by default output values outside the wavelength range of the input are set to \code{NA}s unless a different argument is provided for parameter \code{fill}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwd{seq}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{300}\hlstd{,} \hlkwc{by}\hlstd{=}\hlnum{0.1}\hlstd{))}
\end{alltt}
\begin{verbatim}
##      w.length   s.e.irrad    s.q.irrad
##   1:    290.0          NA           NA
##   2:    290.1          NA           NA
##   3:    290.2          NA           NA
##   4:    290.3          NA           NA
##   5:    290.4          NA           NA
##  ---                                  
##  97:    299.6 0.001072550 2.687082e-09
##  98:    299.7 0.001120551 2.808113e-09
##  99:    299.8 0.001168552 2.929144e-09
## 100:    299.9 0.001216553 3.050176e-09
## 101:    300.0 0.001264554 3.171207e-09
\end{verbatim}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwd{seq}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{300}\hlstd{,} \hlkwc{by}\hlstd{=}\hlnum{0.1}\hlstd{),} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      w.length   s.e.irrad    s.q.irrad
##   1:    290.0 0.000000000 0.000000e+00
##   2:    290.1 0.000000000 0.000000e+00
##   3:    290.2 0.000000000 0.000000e+00
##   4:    290.3 0.000000000 0.000000e+00
##   5:    290.4 0.000000000 0.000000e+00
##  ---                                  
##  97:    299.6 0.001072550 2.687082e-09
##  98:    299.7 0.001120551 2.808113e-09
##  99:    299.8 0.001168552 2.929144e-09
## 100:    299.9 0.001216553 3.050176e-09
## 101:    300.0 0.001264554 3.171207e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{interpolate\_spct} takes any \code{\_\_.spct} object, and returns an object of the same type as its imput. It can be used to interpolate source spectra as well as transmittance, reflectance, response, and even generic spectra.

\code{interpolate\_spectrum} takes numeric vectors as arguments, but is otherwise functionally equivalent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.dt,}
     \hlkwd{interpolate_spectrum}\hlstd{(w.length, s.e.irrad,} \hlnum{290}\hlopt{:}\hlnum{300}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1]           NA           NA           NA
##  [4] 2.609665e-06 6.142401e-06 2.176175e-05
##  [7] 6.780119e-05 1.533491e-04 3.669677e-04
## [10] 7.845430e-04 1.264554e-03
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.dt,}
     \hlkwd{interpolate_spectrum}\hlstd{(w.length, s.e.irrad,} \hlnum{290}\hlopt{:}\hlnum{300}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{0.0}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] 0.000000e+00 0.000000e+00 0.000000e+00
##  [4] 2.609665e-06 6.142401e-06 2.176175e-05
##  [7] 6.780119e-05 1.533491e-04 3.669677e-04
## [10] 7.845430e-04 1.264554e-03
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{framed}
These functions, in their current implementation, always return
interpolated values, even when the density of wavelengths in the output is less than that in the input.
A future version of the package will include a \code{smooth\_spectrum} function, and possibly a \code{remap\_w.length} function that will automatically choose between interpolation and smoothing/averaging as needed.
\end{framed}

\section{Wavebands}\label{sec:wb:objects}

\subsection{How are wavebands stored?}

Wavebands are derived from R lists. All valid R operations for lists can be also used with \code{waveband} objects. However, there are \code{waveband}-specific specializations of generic R methods.

\subsection{How can the user create waveband objects}

Wavebands are created by means of function \code{new\_waveband} which has several arguments, but except for the first two they have default values.

The most simple \code{waveband} creation call is one supplying as arguments just the wavelength limits of the band.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{new_waveband}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{400}\hlstd{)}
\end{alltt}
\begin{verbatim}
## range.300.400 
## low (nm) 300 
## high (nm) 400 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see from the printout a name and label are created automatically. The user can also supply these as arguments, but must be careful not to duplicate existing names. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{new_waveband}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{400}\hlstd{,} \hlkwc{wb.name}\hlstd{=}\hlstr{"a.name"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## a.name 
## low (nm) 300 
## high (nm) 400 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{new_waveband}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{400}\hlstd{,} \hlkwc{wb.name}\hlstd{=}\hlstr{"a.name"}\hlstd{,} \hlkwc{wb.label}\hlstd{=}\hlstr{"A nice name"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## a.name 
## low (nm) 300 
## high (nm) 400 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

If we include a weighting function, there is still quite a lot of flexibility. One can supply either a function that takes energy irradiance as input or a function that takes photon irradiance as input. Unless both are supplied, the missing function will be automatically created. There is are also arguments related to normalization, both of the output, and of the SWF supplied as argument. In the examples above, `hinges' are created automatically for the range extremes. When using SWF with discontinuous derivatives, best results are obtained by supplying the hinges to be used as arguments to \code{new\_waveband}. An example follows for the definition of a waveband for the CIE98 SWF---the function \code{CIE.e.fun} is defined in package \code{photobiologyWavebands} but any R function taking a numeric vector of wavelengths as input and returning a numeric vector of the same length containing weights can be used. The use of SWFs is discussed in more detail in chapter \ref{chap:wt:irrad}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{new_waveband}\hlstd{(}\hlkwc{w.low}\hlstd{=}\hlnum{250}\hlstd{,} \hlkwc{w.high}\hlstd{=}\hlnum{400}\hlstd{,}
               \hlkwc{weight}\hlstd{=}\hlstr{"SWF"}\hlstd{,} \hlkwc{SWF.e.fun}\hlstd{=CIE.e.fun,} \hlkwc{SWF.norm}\hlstd{=}\hlnum{298}\hlstd{,}
               \hlkwc{norm}\hlstd{=}\hlnum{298}\hlstd{,} \hlkwc{hinges}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{249.99}\hlstd{,} \hlnum{250}\hlstd{,} \hlnum{298}\hlstd{,} \hlnum{328}\hlstd{,} \hlnum{399.99}\hlstd{,} \hlnum{400}\hlstd{),}
               \hlkwc{wb.name}\hlstd{=}\hlstr{"CIE98.298"}\hlstd{,} \hlkwc{wb.label}\hlstd{=}\hlstr{"CIE98"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## low (nm) 250 
## high (nm) 400 
## weighted SWF 
## normalized at 298 nm
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsection{What `summary' functions are available for wavebands?}

Special methods for \code{waveband}s of \code{print} giving more compact output than the default \code{print} method for lists. In addition, \code{range, min, max} when applied to wavebands return values corresponding to wavelengths, other generic functions defined in the suite give additional summaries of wavebands \code{spread}, \code{midpoint}, \code{color}, \code{labels}.


\subsection{Operators and functions}

Several functions described in chapters \ref{chap:uw:irrad}, \ref{chap:wt:irrad}, and \ref{chap:plots} use \code{waveband} objects as arguments. Those functions 
\section{Internal-use functions}\label{sec:base:internal}

The generic function \code{check} can be used on any type of \code{.spct} object, and depending on its types checks that the required components are present. If they are missing they are added. If it is possible to calculate the missing values from other optional components, they are calculated, otherwise they are filled with \code{NA}. It is used internally during the creation of spectral objects.

The function \code{check\_spectrum} may need to be called by the user if he/she disables automatic sanity checking to increase calculation speed. The family of functions for calculating multipliers are used internally by the package.

The function \code{insert\_hinges} is used internally to insert individual interpolated values to the spectra when needed to reduce errors in calculations.

The function \code{integrate\_irradiance} is used internally for integrating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible, or never. This function makes it possible to work with spectral data on the original pixel wavelengths.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyLEDs))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}






\chapter{Unweighted irradiance}\label{chap:uw:irrad}

\begin{abstract}
  In this chapter we explain how to calculate unweighted energy and photon irradiances from spectral irradiance.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:uw:intro}



%%%%
\section{Task: (energy) irradiance from spectral irradiance}\label{sec:uw:e2e}

The task to be completed is to calculate the (energy) irradiance ($\irr$) in \watt from spectral (energy) irradiance ($\sirr$) in \wattnm and the corresponding wavelengths ($\lambda$) in nm.

\begin{equation}
\irr[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \sirr\ \mathrm{d}\ \lambda
\label{eq:energy:irrad}
\end{equation}

Let's assume that we want to calculate photosynthetically active radiation (PAR) energy irradiance, for which the most accepted limits are $\lambda_1 = 400 \mathrm{nm}$ and $\lambda_1 = 700 \mathrm{nm}$. In this example we will use example data for sunlight to calculate $\irr[400\,\mathrm{nm} < \lambda < 700\,\mathrm{nm}]$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##      196.7004
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \code{PAR()} is predefined in package \PBWB as a convenience function, so the code above can be replaced by:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##      PAR 
## 196.7004
\end{verbatim}
\end{kframe}
\end{knitrout}

If no waveband is supplied as argument, then the whole range of wavelengths in the spectral data is used for the integration, and the `name' attribute is generated accordingly:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## range.293.800 
##      269.1249
\end{verbatim}
\end{kframe}
\end{knitrout}

If a waveband that does not fully overlap with the data is supplied as argument, then spectral irradiance for wavelengths outside the range is assumed to be zero:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{700}\hlstd{,}\hlnum{1000}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.700.1000 
##       44.09981
\end{verbatim}
\end{kframe}
\end{knitrout}

If a waveband that does not overlap with the data is supplied as argument, then spectral irradiance for wavelengths outside the range is assumed to be zero:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{new_waveband}\hlstd{(}\hlnum{100}\hlstd{,}\hlnum{200}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.100.200 
##             0
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: photon irradiance from spectral irradiance}\label{sec:uw:e2q}

The task to be completed is to calculate the photon irradiance ($\pfd$) in \mol from spectral (energy) irradiance ($\sirr$) in \wattnm and the corresponding wavelengths ($\lambda$) in nm.

Combining equations \ref{eq:energy:irrad} and \ref{eq:energy:mol:photons} we obtain:

\begin{equation}
\pfd[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \sirr\ \frac{h' \cdot c}{\lambda} \mathrm{d}\ \lambda
\end{equation}

Let's assume that we want to calculate photosynthetically active radiation (PAR) photon irradiance. In this example we will use example data for sunlight.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##          PAR 
## 0.0008937598
\end{verbatim}
\end{kframe}
\end{knitrout}

If we want to have $\pfd[\PAR]$ (\PPFD) expressed in the usual units of \umol, we need to multiply the result above by $10^6$:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##      PAR 
## 893.7598
\end{verbatim}
\end{kframe}
\end{knitrout}

\code{PAR()} is predefined in package \PBWB as a convenience function, see section \ref{sec:energy:irrad} for an example with arbitrary values for $\lambda_1$ and $\lambda_2$.

%%%%
\section[Task: irradiance from spectral photon irradiance]{Task: calculate energy and photon irradiances from spectral photon irradiance}\label{sec:uw:irrad:q2e}

In the case of the calculation of energy irradiance from spectral photon irradiance the calculation is:
\begin{equation}
\irr[\lambda_1 < \lambda < \lambda_2] = \int_{\lambda_1}^{\lambda_2} \spfd\ \frac{\lambda}{h' \cdot c} \mathrm{d}\ \lambda
\end{equation}

And the code\footnote{The dataframe \code{sun.data} contains both spectral energy irradiance vales in `column' \code{s.e.irrad} and spectral photon irradiance in `column' \code{s.q.irrad}}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.q.irrad,}
                       \hlkwd{PAR}\hlstd{()),} \hlkwc{unit.in}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##          PAR 
## 0.0008937598
\end{verbatim}
\end{kframe}
\end{knitrout}

The calculation of photon irradiance from spectral photon irradiance, is a simple integration, analogous to that in equation \ref{eq:energy:irrad}, and the code is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.q.irrad,}
                       \hlkwd{PAR}\hlstd{()),} \hlkwc{unit.in}\hlstd{=}\hlstr{"photon"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##          PAR 
## 4.157767e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: irradiances for more than one waveband}\label{sec:uw:mult:wb}

It is possible to calculate the irradiances for several wavebands with a single function call by supplying a \code{list} of \code{wavebands} as argument:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Green}\hlstd{(),} \hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   Red.ISO Green.ISO  Blue.ISO 
##  452.1700  220.1562  148.9735
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB} \hlkwb{<-} \hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Green}\hlstd{(),} \hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\hlkwd{signif}\hlstd{(Q.RGB,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   Red.ISO Green.ISO  Blue.ISO 
##       452       220       149
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB[}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## Red.ISO 
##  452.17
\end{verbatim}
\begin{alltt}
\hlstd{Q.RGB[}\hlstr{"Green.ISO"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## Green.ISO 
##  220.1562
\end{verbatim}
\end{kframe}
\end{knitrout}

A named list can be used to override the use as names for the output of the waveband names:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwc{R}\hlstd{=}\hlkwd{Red}\hlstd{(),} \hlkwc{G}\hlstd{=}\hlkwd{Green}\hlstd{(),} \hlkwc{B}\hlstd{=}\hlkwd{Blue}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##        R        G        B 
## 452.1700 220.1562 148.9735
\end{verbatim}
\end{kframe}
\end{knitrout}

Even when using a single waveband:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                       \hlkwd{list}\hlstd{(}\hlkwc{UVB}\hlstd{=}\hlkwd{UVB}\hlstd{())))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##      UVB 
## 1.526862
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: use simple wavebands}\label{sec:wavebands}

Please, consult the packages' documentation for a list of predefined functions for creating wavebands. Here we will present just a few examples of their use. We usually associate wavebands with colours, however, in many cases there are different definitions in use. For this reason, the functions provided accept an argument that can be used to select the definition to use. In general, the default, is to use the ISO standard whenever it is applicable. The case of the various definitions in use for the \UVB waveband are described on page \pageref{pag:UVB:stds}

We can use a predefined function to create a new \code{waveband} object, which as any other R object can be assigned to a variable:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{uvb} \hlkwb{<-} \hlkwd{UVB}\hlstd{()}
\hlstd{uvb}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

As seen above, there is a specialized \code{print} function for \code{wavebands}. Functions available are \code{min}, \code{max}, \code{range}, \code{center\_wl}, \code{labels}, and \code{color}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{red} \hlkwb{<-} \hlkwd{Red}\hlstd{()}
\hlstd{red}
\end{alltt}
\begin{verbatim}
## Red.ISO 
## low (nm) 610 
## high (nm) 760 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{min}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 610
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 760
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 610 760
\end{verbatim}
\begin{alltt}
\hlkwd{midpoint}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## [1] 685
\end{verbatim}
\begin{alltt}
\hlkwd{labels}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## $label
## [1] "Red"
## 
## $name
## [1] "Red.ISO"
\end{verbatim}
\begin{alltt}
\hlkwd{color}\hlstd{(red)}
\end{alltt}
\begin{verbatim}
## $CMF
##   Red.CMF 
## "#900000" 
## 
## $CC
##    Red.CC 
## "#FF0000"
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate the use of an argument to choose a certain definition:\label{pag:UVB:stds}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{UVB}\hlstd{()}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"ISO"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"CIE"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.CIE 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"medical"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.medical 
## low (nm) 290 
## high (nm) 320 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{UVB}\hlstd{(}\hlstr{"none"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## UVB.none 
## low (nm) 280 
## high (nm) 320 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate the importance of complying with standards, and how much the photon irradiance calculated can depend on the definition used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(}\hlstr{"ISO"}\hlstd{)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##  UVB.ISO 
## 1.526862
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(}\hlstr{"none"}\hlstd{)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## UVB.none 
##  3.28209
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: define simple wavebands}\label{sec:wavebands}

Here we briefly introduce \code{new\_waveband}, and only in chapter \ref{chap:wtirrad} we describe its use in full detail, including the use of spectral weighting functions (SWFs).

Defining a new \code{waveband} based on extreme wavelengths expressed in nm.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wb1} \hlkwb{<-} \hlkwd{new_waveband}\hlstd{(}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{)}
\hlstd{wb1}
\end{alltt}
\begin{verbatim}
## range.500.600 
## low (nm) 500 
## high (nm) 600 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, wb1))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.500.600 
##      314.0618
\end{verbatim}
\begin{alltt}
\hlstd{wb2} \hlkwb{<-} \hlkwd{new_waveband}\hlstd{(}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{,} \hlkwc{wb.name}\hlstd{=}\hlstr{"my.colour"}\hlstd{)}
\hlstd{wb2}
\end{alltt}
\begin{verbatim}
## my.colour 
## low (nm) 500 
## high (nm) 600 
## weighted none
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_irradiance}\hlstd{(w.length, s.e.irrad, wb2))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## my.colour 
##  314.0618
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: photon ratios}\label{sec:photon:ratio}

In photobiology sometimes we are interested in calculation the photon ratio between two wavebands. It makes more sense to calculate such ratios if both numerator and denominator wavebands have the same `width' or if the numerator waveband is fully nested in the denominator waveband. However, frequently used ratios like the \UVB to \PAR photon ratio do not comply with this. For this reason, our functions do not enforce any such restrictions.

For example a ratio frequently used in plant photobiology is the read to far-red photon ratio (R:FR photon ratio or $\zeta$). If we follow the wavelength ranges in the definition given by \cite{Morgan1981a}, using photon irradiance\footnote{In the original text photon fluence rate is used but it not clear whether photon irradiance was meant instead.}:

\begin{equation}
\zeta = \frac{\pfd[655 \mathrm{nm} < \lambda < 665  \mathrm{nm}]}{\pfd[725 \mathrm{nm} < \lambda < 735 \mathrm{nm}]}
\end{equation}

To calculate this for our example sunlight spectrum we can use the following code:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photon_ratio}\hlstd{(w.length, s.e.irrad,}
                  \hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] 1.251099
\end{verbatim}
\end{kframe}
\end{knitrout}

or using the predefined convenience function \code{R\_FR\_ratio}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{R_FR_ratio}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## [1] 1.251099
\end{verbatim}
\end{kframe}
\end{knitrout}

Using defaults for waveband definitions:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{UVB}\hlstd{(),} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## [1] 0.002989897
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: energy ratios}\label{sec:energy:ratio}

An energy ratio, equivalent to $\zeta$ can be calculated as follows:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_ratio}\hlstd{(w.length, s.e.irrad,}
                  \hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] 1.384353
\end{verbatim}
\end{kframe}
\end{knitrout}

For this infrequently used ratio, no pre-defined function is provided.

%%%%
\section{Task: calculate average number of photons per unit energy}\label{sec:photons:energy}

When comparing photo-chemical and photo-biological responses under different light sources it is of interest to calculate the photons per energy in \moljoule. In this case only one waveband definition is used to calculate the quotient:

\begin{equation}
\bar{q'} = \frac{\pfd[\lambda_1 < \lambda < \lambda_2]}{\irr[\lambda_1 < \lambda < \lambda_2]}
\end{equation}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photons_energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## [1] 4.543762e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

For obtaining the same quotient in \umoljoule we just need to multiply by $10^6$. We can use such a multiplier to convert $\irr$ [\watt] into $\pfd$ [\umol] (as \Unit{W} = \Unit{J\,s^{-1}}), or as a divisor to convert $\pfd$ [\umol] into $\irr$ [\watt], \emph{for a given light source and waveband}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{photons_energy_ratio}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## [1] 4.543762
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section[Task: split energy irradiance into regions]{Task: calculate the contribution of different regions of a spectrum to energy irradiance}\label{sec:split:energy}

\sloppy
It can be of interest to split the total (energy) irradiance into adjacent regions delimited by arbitrary wavelengths. We can use the function \code{split\_energy\_irradiance} to obtain to energy of each of the regions delimited by the values in nm supplied in a numeric vector:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##      69.63243      68.53291      58.53508
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we demonstrate that the sum of the four `split' irradiances add to the total for the range of wavelengths covered:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{sum}\hlstd{(}\hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                                 \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{))))}
\end{alltt}
\begin{verbatim}
## [1] 196.7004
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{PAR}\hlstd{()))}
\end{alltt}
\begin{verbatim}
##      PAR 
## 196.7004
\end{verbatim}
\end{kframe}
\end{knitrout}

It also possible to obtain the `split' as a vector of fractions adding up to one,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"relative"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##     0.3540024     0.3484126     0.2975849
\end{verbatim}
\end{kframe}
\end{knitrout}

or as percentages:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##      35.40024      34.84126      29.75849
\end{verbatim}
\end{kframe}
\end{knitrout}

If the `limits' cover only a region of the spectral data, relative and percent values will be calculated with that region as a reference.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{,}\hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##      35.40024      34.84126      29.75849
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{500}\hlstd{,}\hlnum{600}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 
##       50.3979       49.6021
\end{verbatim}
\end{kframe}
\end{knitrout}

A vector of two wavelengths is valid input, although not very useful for percentages:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##           100
\end{verbatim}
\end{kframe}
\end{knitrout}

In contrast, for \code{scale="absolute"}, the default, it can be used as a quick way of calculating an irradiance for a range of wavelengths without having to define a \code{waveband}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_energy_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{700}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## range.400.700 
##      196.7004
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section[Task: split photon irradiance into regions]{Task: calculate the contribution of different regions of a spectrum to photon irradiance}\label{sec:split:photons}

The function \code{split\_photon\_irradiance} takes the same arguments as the equivalent function for photon irradiance, consequently only one code example is provided here (see section \ref{sec:split:energy} for more details):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{split_photon_irradiance}\hlstd{(w.length, s.e.irrad,}
                             \hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,} \hlnum{500}\hlstd{,} \hlnum{600}\hlstd{,} \hlnum{700}\hlstd{),}
                             \hlkwc{scale}\hlstd{=}\hlstr{"percent"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## range.400.500 range.500.600 range.600.700 
##      29.40969      35.13940      35.45092
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}




\chapter{Weighted and effective irradiance}\label{chap:wt:irrad}

\begin{abstract}
  In this chapter we explain how to calculate weighted energy and photon irradiances from spectral irradiance.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:wt:intro}

Weighted irradiance is usually reported in weighted energy units, but it is possible to also use weighted photon based units. In practice the R code to use is exactly the same as for unweighted irradiances, as all the information needed is stored in the \code{waveband} object. An additional factor comes into play and it is the \emph{normalization wavelength}, which is accepted as an argument by the predefined waveband creation functions that use a biological spectral weighting function (BSWF). The focus of this chapter is on the differences between calculations for weighted irradiances compared to those for unweighted irradiances described in chapter \ref{chap:uw:irrad}. In particular it is important that you read sections \ref{sec:uw:e2e}, \ref{sec:uw:e2q}, \ref{sec:uw:q2e}, and \ref{sec:uw:mult:wb} before reading the present chapter.

%%%%
\section{Task: choosing the normalization wavelength}\label{sec:wt:intro}

Function \code{GEN.G()} is predefined in package \PBWB as a convenience function for Green's formulation of Caldwell's generalized plant action spectrum (GPAS) \cite{Green198x}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{()))}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## 0.1033597
\end{verbatim}
\end{kframe}
\end{knitrout}

The code above uses the default normalization wavelength of 300 nm. Any arbitrary wavelength (nm), within the range of the waveband can be provided as an argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{range}\hlstd{(}\hlkwd{GEN.G}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 250.0 313.3
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{energy_irradiance}\hlstd{(w.length, s.e.irrad,} \hlkwd{GEN.G}\hlstd{(}\hlnum{280}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##  GEN.G.280 
## 0.02402434
\end{verbatim}
\end{kframe}
\end{knitrout}


%%%%
\section{Task: use weighted wavebands}\label{sec:wt:intro}

Please, consult the packages' documentation for a list of predefined functions for creating weighted wavebands. Here we will present just a few examples of their use. We usually think of weighted irradiances as being defined by the weighting function, however, in many cases different normalizations are in use, and the result of any calculation depends very strongly on the wavelength used for normalization. For this reason, the functions provided accept an argument that can be used to select the normalization wavelength. In general, the default, is to use the most frequently used normalization.

In a few cases different mathematical formulations are available for the same spectrum, and the differences among them can be quite large. In such cases separate functions are provided for each of them (e.g. \code{GEN.N} and \code{GEN.T} for Green's and Thimijan's formulations of Caldwell's GPAS).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{()}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 300 nm
\end{verbatim}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{(}\hlnum{300}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.300 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 300 nm
\end{verbatim}
\begin{alltt}
\hlkwd{GEN.G}\hlstd{(}\hlnum{280}\hlstd{)}
\end{alltt}
\begin{verbatim}
## GEN.G.280 
## low (nm) 250 
## high (nm) 313 
## weighted SWF 
## normalized at 280 nm
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use one of the predefined functions to create a new \code{waveband} object, which as any other R object can be assigned to a variable:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cie} \hlkwb{<-} \hlkwd{CIE}\hlstd{()}
\hlstd{cie}
\end{alltt}
\begin{verbatim}
## CIE98.298 
## low (nm) 250 
## high (nm) 400 
## weighted SWF 
## normalized at 298 nm
\end{verbatim}
\end{kframe}
\end{knitrout}

As seen above, there is a specialized \code{print} function for \code{wavebands}. Functions available are \code{min}, \code{max}, \code{range}, \code{midpoint}, \code{labels}, and \code{color}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{min}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 250
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 400
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 250 400
\end{verbatim}
\begin{alltt}
\hlkwd{midpoint}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 325
\end{verbatim}
\begin{alltt}
\hlkwd{normalization}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## [1] 298
\end{verbatim}
\begin{alltt}
\hlkwd{labels}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## $label
## [1] "CIE98"
## 
## $name
## [1] "CIE98.298"
\end{verbatim}
\begin{alltt}
\hlkwd{color}\hlstd{(cie)}
\end{alltt}
\begin{verbatim}
## $CMF
## CIE98.CMF 
## "#02000F" 
## 
## $CC
##  CIE98.CC 
## "#1A00DD"
\end{verbatim}
\end{kframe}
\end{knitrout}


%%%%
%\section{Task: define wavebands}\label{sec:wt:wavebands}
%
%In section \ref{sec:uw:wavebands} we briefly introduced \code{new\_waveband}, and here we describe its use in full detail, including the use of spectral weighting functions (SWFs).
%
%Defining a new weighted \code{waveband}. We start with a simple `toy' example:
%
%<<tidy=FALSE>>=
%toy.wb <- new_waveband(400, 700, "SWF",
%                       SWF.e.fun=function(wl){(wl - 400)^2},
%                       norm=550, SWF.norm=550,
%                       wb.name="TOY")
%toy.wb
%with(sun.data,
%     energy_irradiance(w.length, s.e.irrad, toy.wb))
%with(sun.data,
%     photon_irradiance(w.length, s.e.irrad, toy.wb))
%@


%%%%
\section{Introduction}\label{sec:wt:intro}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}







\chapter{Transmission and reflection}

\begin{abstract}
In this chapter we explain how to do calculations related to the description of absortion and reflection of UV and VIS radiation.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:}

\section{Task: absorbance and transmittance}

Transmittance is defined as:
\begin{equation}
\tau(\lambda) = \frac{I}{I_0} = \frac{\sirr}{\sirr[0]} = \frac{\spfd}{\spfd[0]}
\end{equation}

Given this simple relation $\tau(\lambda)$ can be calculated as a division between two "source.spct" objects. This gives the correct answer, but as an object of class "source.scpt".

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tau} \hlkwb{<-} \hlstd{spc_above} \hlopt{/} \hlstd{spc_below}
\end{alltt}
\end{kframe}
\end{knitrout}

Absorptance is just $1 - \tau(\lambda)$, but should be distinguished from absorbance ($A(\lambda)$) which is measured on a logarithmic scale:

\begin{equation}
A(\lambda) = -{\log}_{10} \frac{I}{I_0}
\end{equation}

In chemistry 10 is always used as the base of the logarithm, but in other contexts sometimes $\mathrm{e}$ is used as base.

Given the simple equation, $A(\lambda)$ can be also easily calculated using the operators for spectra. This gives the correct answer, but in an object of class "source.scpt".

The conversion between $\tau(\lambda)$ and $A(\lambda)$ is:

\begin{equation}
A(\lambda) = -{\log}_{10} \tau(\lambda)
\end{equation}

which in S language is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_T2A} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}\hlopt{-}\hlkwd{log10}\hlstd{(x)\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The conversion between  $A(\lambda)$ and $\tau(\lambda)$ is:

\begin{equation}
\tau(\lambda) = 10^{-A(\lambda)}
\end{equation}

which in S language is:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_A2T} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}\hlnum{10}\hlopt{^-}\hlstd{x\}}
\end{alltt}
\end{kframe}
\end{knitrout}

Instead of these functions, the package defines generic functions and specialized functions, that can be used on vectors and on \code{filter.spc} objects. Then functions defined above could be directly applied to vectors but doing this on a column in a \code{filter.spc} is more cumbersome. As the spectra objects are data.tables, one can add a new column, say with transmittances to a copy of the filter data as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_gg400.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(gg400.spct)}
\hlstd{my_gg400.spct[ , A} \hlkwb{:=} \hlkwd{T2A}\hlstd{(Tfr)]}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr A
##   1:      200 1e-05 5
##   2:      210 1e-05 5
##   3:      220 1e-05 5
##   4:      230 1e-05 5
##   5:      240 1e-05 5
##  ---                 
## 176:     4950 1e-05 5
## 177:     5000 1e-05 5
## 178:     5050 1e-05 5
## 179:     5100 1e-05 5
## 180:     5150 1e-05 5
\end{verbatim}
\begin{alltt}
\hlstd{my_gg400.spct}
\end{alltt}
\begin{verbatim}
##      w.length   Tfr A
##   1:      200 1e-05 5
##   2:      210 1e-05 5
##   3:      220 1e-05 5
##   4:      230 1e-05 5
##   5:      240 1e-05 5
##  ---                 
## 176:     4950 1e-05 5
## 177:     5000 1e-05 5
## 178:     5050 1e-05 5
## 179:     5100 1e-05 5
## 180:     5150 1e-05 5
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: spectral absorbance from spectral transmittance}

Using \code{filter.spct} objects, the calculations become very simple.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_gg400.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(gg400.spct)}
\hlkwd{T2A}\hlstd{(my_gg400.spct)}
\hlstd{a.gg400.spct} \hlkwb{<-} \hlkwd{T2A}\hlstd{(my_gg400.spct,} \hlkwc{action}\hlstd{=}\hlstr{"replace"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: spectral transmittance from spectral absorbance}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{A2T}\hlstd{(a.gg400.spct)}
\hlkwd{A2T}\hlstd{(a.gg400.spct,} \hlkwc{action}\hlstd{=}\hlstr{"replace"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: reflected or transmitted spectrum from spectral reflectance and spectral irradiance}

When we multiply a \code{source.spct} by a \code{filter.spct} or by a \code{reflector.spct} we obtain as a result a new \code{source.spct}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(gg400.spct)}
\end{alltt}
\begin{verbatim}
## [1] "filter.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlstd{my_gg400.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(gg400.spct)}
\hlstd{filtered_sun.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{gg400.spct}
\hlkwd{class}\hlstd{(filtered_sun.spct)}
\end{alltt}
\begin{verbatim}
## [1] "source.spct"  "generic.spct" "data.table"  
## [4] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(filtered_sun.spct)}
\end{alltt}
\begin{verbatim}
##    w.length    s.e.irrad
## 1:      293 2.609665e-11
## 2:      294 6.142401e-11
## 3:      295 2.176175e-10
## 4:      296 6.780119e-10
## 5:      297 1.533491e-09
## 6:      298 3.669677e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

The result of the calculation can be directly used as an argument, for example, when calulating irradiance.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##  UV.ISO 
## 85.4784 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_sun.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##  UV.ISO 
## 85.4784 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(filtered_sun.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   UV.ISO 
## 3.153016 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(sun.spct} \hlopt{*} \hlstd{gg400.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   UV.ISO 
## 3.153016 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_sun.spct} \hlopt{*} \hlstd{my_gg400.spct,} \hlkwd{UV}\hlstd{())} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##   UV.ISO 
## 3.153016 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_sun.spct} \hlopt{*} \hlstd{my_gg400.spct)} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.293.800 
##      1135.601 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_sun.spct} \hlopt{*} \hlstd{my_gg400.spct,}
             \hlkwd{new_waveband}\hlstd{(}\hlkwd{min}\hlstd{(sun.spct),} \hlkwd{max}\hlstd{(sun.spct)))} \hlopt{*} \hlnum{1e6}
\end{alltt}
\begin{verbatim}
## range.293.800 
##      1134.281 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

Remember, thet if we want to predict the output of a light source composed of different lamps or LEDs we can add the individual spectral irradiance, but using data measured from the target positions of each individaul light source. If we want then to add the effect of a filter we must multiply by the filter transmittance.

\begin{framed}
In the current version of package \code{photobiology} the operator is ``chosen'' based on the first operand. For this reason, when including a numeric operand, it should always be the second operand of binary operators for spectra.
\end{framed}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not working}
\hlstd{my_luminaire} \hlkwb{<-}
  \hlstd{(}\hlnum{0.5} \hlopt{*} \hlstd{Norlux_B.spct} \hlopt{+} \hlstd{Norlux_R.spct)} \hlopt{*}  \hlstd{PLX0A000_XT.spct}
\hlstd{my_luminaire}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlcom{# works fine}
\hlstd{my_luminaire} \hlkwb{<-}
  \hlstd{(Norlux_B.spct} \hlopt{*} \hlnum{0.5} \hlopt{+} \hlstd{Norlux_R.spct)} \hlopt{*}  \hlstd{PLX0A000_XT.spct}
\hlstd{my_luminaire}
\end{alltt}
\begin{verbatim}
##       w.length s.e.irrad
##    1:   200.00         0
##    2:   200.47         0
##    3:   200.95         0
##    4:   201.00         0
##    5:   201.42         0
##   ---                   
## 2355:   936.05         0
## 2356:   936.48         0
## 2357:   936.91         0
## 2358:   937.00         0
## 2359:   937.34         0
\end{verbatim}
\begin{alltt}
\hlkwd{q_ratio_spct}\hlstd{(my_luminaire,}
             \hlkwd{list}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlkwd{Blue}\hlstd{(),} \hlkwd{Green}\hlstd{()),} \hlkwd{PAR}\hlstd{())}
\end{alltt}
\begin{verbatim}
##   Red.ISO:PAR(q:q)  Blue.ISO:PAR(q:q) 
##        0.816195602        0.146121825 
## Green.ISO:PAR(q:q) 
##        0.003908976
\end{verbatim}
\begin{alltt}
\hlkwd{q_irrad_spct}\hlstd{(my_luminaire,}
             \hlkwd{list}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlkwd{Red}\hlstd{(),} \hlkwd{Blue}\hlstd{(),} \hlkwd{Green}\hlstd{()))} \hlopt{*}  \hlnum{1e6}
\end{alltt}
\begin{verbatim}
##          PAR      Red.ISO     Blue.ISO 
## 1.591314e-02 1.298824e-02 2.325257e-03 
##    Green.ISO 
## 6.220409e-05 
## attr(,"time.unit")
## [1] "second"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: total spectral transmittance from internal spectral transmittance and spectral reflectance}\label{sec:}

%%%%
\section{Task: combined spectral transmittance of two or more filters}\label{sec:}

\subsection{Ignoring reflectance}


\subsection{Considering reflectance}

%%%%
\section{Task: light scattering media (natural waters, plant and animal tissues)}\label{sec:}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyLEDs))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}





\chapter{Colour}

\begin{abstract}
  In this chapter we explain how to use colours according to visual sensitivity. For example calculating red-green-blue (RGB) values for humans.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Introduction}

The calculation of equivalent colours and colour spaces is based on the number of photoreceptors and their spectral sensitivities. For humans it is normally accepted that there are three photoreceptors in the eyes, with maximum sensitivities in the red, green, and blue regions of the spectrum.

When calculating colours we can take either only the colour or both colour and apparent luminance. In our functions, in the first case one needs to provide as input `chromaticity coordinates' (CC) and in the second case `colour matching functions' (CMF). The suite includes data for humans, but the current implementation of the functions should be able to handle also calculations for other organisms with tri-chromic vision.

The functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelengths, based on the assumption of a flat energy irradiance across this range.

By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition. The range of wavelengths used in the calculations is that in the chromaticity data.

One use of these functions is to generate realistic colour for `key' on plots of spectral data. Other uses are also possible, like simulating how different, different objects would look to a certain organism.

\begin{framed}
This package is very `young' so may be to some extent buggy, and/or have rough edges.
We plan to add at least visual data for honey bees.
\end{framed}

%%%%
\section{Task: calculating an RGB colour from a single wavelength}\label{sec:color:wl}

Function \code{w\_length2rgb} must be used in this case. If a vector of wavelengths is supplied as argument, then a vector of \code{color}s, of the same length, is returned. Here are some examples of calculation of R color definitions for monochromatic light:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{550}\hlstd{)} \hlcom{# green}
\end{alltt}
\begin{verbatim}
## wl.550.nm 
## "#00FF00"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{630}\hlstd{)} \hlcom{# red}
\end{alltt}
\begin{verbatim}
## wl.630.nm 
## "#FF0000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{380}\hlstd{)} \hlcom{# UVA}
\end{alltt}
\begin{verbatim}
## wl.380.nm 
## "#000000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlnum{750}\hlstd{)} \hlcom{# far red}
\end{alltt}
\begin{verbatim}
## wl.750.nm 
## "#000000"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length2rgb}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{550}\hlstd{,} \hlnum{630}\hlstd{,} \hlnum{380}\hlstd{,} \hlnum{750}\hlstd{))} \hlcom{# vectorized}
\end{alltt}
\begin{verbatim}
## wl.550.nm wl.630.nm wl.380.nm wl.750.nm 
## "#00FF00" "#FF0000" "#000000" "#000000"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating an RGB colour for a range of wavelengths}\label{sec:color:range}

Function \code{w\_length\_range2rgb} must be used in this case. This function expects as input a vector of two number, as returned by the function \code{range}. If a longer vector is supplied as argument, its range is used, with a warning. If a vector of lengths one is given as argument, then the same output as from function \code{w\_length2rgb} is returned. This function assumes a flat energy spectral irradiance curve within the range. Some examples:
Examples for wavelength ranges:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{400}\hlstd{,}\hlnum{700}\hlstd{))}
\end{alltt}
\begin{verbatim}
## 400-700 nm 
##  "#735B57"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlnum{400}\hlopt{:}\hlnum{700}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Using only extreme wavelength values.}}\begin{verbatim}
## 400-700 nm 
##  "#735B57"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(sun.data}\hlopt{$}\hlstd{w.length)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Using only extreme wavelength values.}}\begin{verbatim}
## 293-800 nm 
##  "#554340"
\end{verbatim}
\begin{alltt}
\hlkwd{w_length_range2rgb}\hlstd{(}\hlnum{550}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Calculating RGB values for monochromatic light.}}\begin{verbatim}
## wl.550.nm 
## "#00FF00"
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%%
\section{Task: calculating an RGB colour for spectrum}\label{sec:color:spc}

Function \code{s\_e\_irrad2rgb} in contrast to those described above, when calculating the color takes into account the spectral irradiance.

Examples for spectra, in this case the solar spectrum:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad))}
\end{alltt}
\begin{verbatim}
## [1] "#544F4B"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCMF2.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#544F4B"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCMF10.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#59534F"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCC2.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#B63C37"
\end{verbatim}
\begin{alltt}
\hlkwd{with}\hlstd{(sun.data,}
     \hlkwd{s_e_irrad2rgb}\hlstd{(w.length, s.e.irrad,} \hlkwc{sens}\hlstd{=ciexyzCC10.spct))}
\end{alltt}
\begin{verbatim}
## [1] "#BD3C33"
\end{verbatim}
\end{kframe}
\end{knitrout}

Except for the first example, we specificity the visual sensitivity data to use.

\section{A sample of colours}

Here we plot the RGB colours for the range covered by the CIE 2006 proposed standard calculated at each 1 nm step:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wl} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{390}\hlstd{,} \hlnum{829}\hlstd{)}

\hlstd{my.colors} \hlkwb{<-} \hlkwd{w_length2rgb}\hlstd{(wl[}\hlnum{1}\hlstd{]}\hlopt{:}\hlstd{wl[}\hlnum{2}\hlstd{])}

\hlstd{colCount} \hlkwb{<-} \hlnum{40} \hlcom{# number per row}
\hlstd{rowCount} \hlkwb{<-} \hlkwd{trunc}\hlstd{(}\hlkwd{length}\hlstd{(my.colors)} \hlopt{/} \hlstd{colCount)}

\hlkwd{plot}\hlstd{(} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,colCount),} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,rowCount),} \hlkwc{type}\hlstd{=}\hlstr{"n"}\hlstd{,}
      \hlkwc{ylab}\hlstd{=}\hlstr{""}\hlstd{,} \hlkwc{xlab}\hlstd{=}\hlstr{""}\hlstd{,}
      \hlkwc{axes}\hlstd{=}\hlnum{FALSE}\hlstd{,} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(rowCount,}\hlnum{0}\hlstd{))}
\hlkwd{title}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"RGB colours for"}\hlstd{,}
            \hlkwd{as.character}\hlstd{(wl[}\hlnum{1}\hlstd{]),} \hlstr{"to"}\hlstd{,}
            \hlkwd{as.character}\hlstd{(wl[}\hlnum{2}\hlstd{]),} \hlstr{"nm"}\hlstd{))}

\hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{0}\hlopt{:}\hlstd{(rowCount}\hlopt{-}\hlnum{1}\hlstd{))}
\hlstd{\{}
  \hlstd{base} \hlkwb{<-} \hlstd{j}\hlopt{*}\hlstd{colCount}
  \hlstd{remaining} \hlkwb{<-} \hlkwd{length}\hlstd{(my.colors)} \hlopt{-} \hlstd{base}
  \hlstd{RowSize} \hlkwb{<-}
    \hlkwd{ifelse}\hlstd{(remaining} \hlopt{<} \hlstd{colCount, remaining, colCount)}
  \hlkwd{rect}\hlstd{((}\hlnum{1}\hlopt{:}\hlstd{RowSize)}\hlopt{-}\hlnum{0.5}\hlstd{, j}\hlopt{-}\hlnum{0.5}\hlstd{, (}\hlnum{1}\hlopt{:}\hlstd{RowSize)}\hlopt{+}\hlnum{0.5}\hlstd{, j}\hlopt{+}\hlnum{0.5}\hlstd{,}
       \hlkwc{border}\hlstd{=}\hlstr{"black"}\hlstd{,}
       \hlkwc{col}\hlstd{=my.colors[base} \hlopt{+} \hlstd{(}\hlnum{1}\hlopt{:}\hlstd{RowSize)])}
\hlstd{\}}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-143-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}


% !Rnw root = r4p.main.Rnw



\chapter{Plotting spectra and colours}



\begin{abstract}
  In this chapter we explain how to plot spectra and colours, using packages \code{ggplot2}, \code{ggtern}, and the functions in our package \code{photobiologygg}. Both \code{ggtern} for ternary plots and \code{photobiologygg} for annotating spectra build new functionality on top of the \code{ggplot2} package. We also use several functions and data from package \code{photobiology} in the examples.
\end{abstract}


\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(scales)}
\hlkwd{library}\hlstd{(ggtern)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# \\\#\# Attaching package: 'ggtern'\\\#\# \\\#\# The following objects are masked from 'package:ggplot2':\\\#\# \\\#\#\ \ \ \  \%+\%, \%+replace\%, aes, calc\_element,\\\#\#\ \ \ \  geom\_density2d, geom\_segment,\\\#\#\ \ \ \  geom\_smooth, ggplot\_build,\\\#\#\ \ \ \  ggplot\_gtable, ggsave, opts,\\\#\#\ \ \ \  stat\_density2d, stat\_smooth, theme,\\\#\#\ \ \ \  theme\_bw, theme\_classic, theme\_get,\\\#\#\ \ \ \  theme\_gray, theme\_grey, theme\_minimal,\\\#\#\ \ \ \  theme\_set, theme\_update}}\begin{alltt}
\hlkwd{library}\hlstd{(gridExtra)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: grid}}\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}



%%%%
\section{Introduction to plotting spectra}\label{sec:plot:intro}

We show in this chapter examples of how spectral data can be plotted. All the examples
are done with package \code{ggplot2}, sometimes using in addition other packages.
\code{ggplot2} provides the most recent, but stable, type of plotting functionality in R, and is
what we use here for most examples. Both \code{base} graphic functions, part of
R itself and `trellis' graphics provided by package \code{lattice} are other popular
alternatives. The new package \code{ggvis} uses similar grammar as \code{ggplot2} but
drastically improves on functionality for interactive plots.
Several of the functions used in this chapter are extensions to
package \code{ggplot2}\footnote{\code{ggplot2} is feature-frozen, in other words the user interface
defined by the functions and their arguments will not change in future versions. Consequently
it is a good basis for adding application-specific functionality through separate
packages. \code{ggplot2} uses the \emph{grammar
of graphics} for describing the plots. This grammar, because it is consistent,
tends to be easier to understand, and makes it easier to design new functionality
that uses extensions based on the same `language grammar' as used by the original package.}

How to depict a spectrum in a figure has to be thought in relation to what aspect of the
information we want to highlight. A line plot of a spectrum with peaks and/or valleys labelled
highlights the shape of the spectrum, while a spectrum plotted with the area below the curve
filled highlights the total energy irradiance (or photon irradiance) for a given region
of the spectrum. Adding a bar with the colours corresponding to the different
wavelengths, facilitates the reading of the plot for people not very familiar with the
interpretation on wavelengths expressed in nanometres. Labeling regions of the spectrum
with waveband names also tends to facilitate the understanding of plotted spectral data.
A basic line plot of spectral data can be easily done with \code{ggplot2} or any of the
other plotting functions in R. In this chapter we focus on how to add to basic line and
dot plots all the `fancy decorations' that can so much facilitate their reading and
interpretation.

Towards the end of the chapter we give examples of plotting of RGB (red-green-blue) colours
for human vision on a ternary plot, and show how to do a ternary plot for GBU
(green-blue-ultraviolet) flower colours for honeybee vision using as reference the reflectance
of a background.

If you are not familiar with \code{ggplot2} and \code{ggtern} plotting, please read Appendix
\ref{chap:R:plotting} on page \pageref{chap:R:plotting} before continuing reading the
present chapter.

%%%%
\section[Task: plotting spectra with ggplot2]{Task: plotting spectra with \code{ggplot2}}\label{sec:plot:spc}

We create a simple line plot, assign it to a variable called \code{fig\_sun.e0} and then on the next line \code{print} it\footnote{we could have used \code{print(fig\_sun.e0)} explicitly, but this is needed only in scripts because printing takes places automatically when working at the R console.}. We obtain a plot with the axis labeled with the names of the variables, which is enough to check the data, but not good enough for publication.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()}

\hlstd{fig_sun.e0}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-sun-linear-0-1} 

}



\end{knitrout}

Next we add \code{labs} to obtain nicer axis labels, instead of assigning the result to a variable for reuse, we print it on-the-fly. As we need superscripts for the $y$-label we have to use \code{expression} instead of a character string as we use for the $x$-label. The syntax of expressions is complex, so please look at \code{help(plotmath)} and appendix \ref{chap:R:plotting} for more details.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-sun-linear-1-1} 

}



\end{knitrout}

As we are going to re-use the same axis-labels in later plots, it is handy to save their definitions to variables. These definitions will be used in  many of this chapter's plots. We also add \code{atop} to two of the expressions to making shorter versions by setting the spectral irradiance units on a second line in the axis labels.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ylab_watt} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}))}
\hlstd{ylab_watt_atop} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(}\hlkwd{atop}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance,}
                  \hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\hlstd{ylab_umol} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{photon}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(mu}\hlopt{*}\hlstd{mol}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}))}
\hlstd{ylab_umol_atop} \hlkwb{<-}
  \hlkwd{expression}\hlstd{(}\hlkwd{atop}\hlstd{(Spectral}\hlopt{~~}\hlstd{photon}\hlopt{~~}\hlstd{irradiance,}
                  \hlstd{(mu}\hlopt{*}\hlstd{mol}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\hlstd{xlab_nm} \hlkwb{<-} \hlstr{"Wavelength (nm)"}
\end{alltt}
\end{kframe}
\end{knitrout}


%%%%
\section{Task: using a log scale}\label{sec:plot:log}

Here without need to recreate the figure, we add a logarithmic scale for the $y$-axis and print on the fly the result, and two of the just saved axis-labels. In this case we override the automatic limits of the scale. We do not give further examples of this, but could be also used with later examples, just by adjusting the values used as scale limits.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+}
  \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{1e-3}\hlstd{,} \hlnum{1e0}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{= xlab_nm,} \hlkwc{y} \hlstd{= ylab_watt)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 7 rows containing missing values (geom\_path).}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-sun-log-1} 

}



\end{knitrout}

The code above generates some harmless warnings, which are due some $y$ values not being valid input for \code{log10}, the function used for the re-scaling, or because they fall outside the scale limits.
%%%%

\section{Task: compare energy and photon spectral units}\label{sec:plot:phot:energy}

We use once more the axis-labels saved above, but this time use the two-line label for the $y$-axis. To make sure that the width of the plotting area of both plots is the same, we need to have tick labels of the same width and format in both plots. For this we define a formatting function \code{num\_one\_dec} and then use it in the scale definition.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{num_one_dec} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{) \{}
  \hlkwd{format}\hlstd{(x,} \hlkwc{nsmall}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{trim}\hlstd{=}\hlnum{FALSE}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{4}\hlstd{, ...)}
  \hlstd{\}}

\hlstd{fig_sun.q} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{labels} \hlstd{= num_one_dec)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{= xlab_nm)}

\hlstd{fig_sun.e1} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{labels} \hlstd{= num_one_dec)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{= xlab_nm)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can use function \code{grid.arrange} to make a single plot from two separate ggplots, and put them side by or on top of each other. We use different $y$-axis labels in the two cases to make better use of the available space.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{grid.arrange}\hlstd{(fig_sun.q}  \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_umol_atop),}
             \hlstd{fig_sun.e1} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_watt_atop),}
             \hlkwc{nrow}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-multiple-1-1} 

}



\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{grid.arrange}\hlstd{(fig_sun.q}  \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_umol),}
             \hlstd{fig_sun.e1} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_watt),}
             \hlkwc{nrow}\hlstd{=}\hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-multiple-2-1} 

}



\end{knitrout}

\section{Task: finding peaks and valleys in spectra}\label{sec:get:pk:vly}

We first show the use of function \code{get\_peaks} that returns the wavelengths at which peaks are located. The parameter \code{span} determines the number of values used to find a local maximum (the higher the value used, the fewer maxima are detected), and the parameter \code{ignore\_threshold} the fraction of the total span along the irradiance that is taken into account (a value of 0.75, requests only peaks in the upper 25\% of the $y$-range to be returned; a value of -0.75 works similarly but for the lower half of the $y$-range)\footnote{In the current example setting \code{ignore\_threshold} equal to 0.75 given that the range of the spectral irradiance data goes from 0.00~\umolnm to 0.82~\umolnm, causes any peaks having a spectral irradiance of less than 0.62 \umolnm to be ignored.}.  It is good to mention that \code{head} returns the first six rows of its argument, and we use it here just to reduce the length of the output, if you run these examples yourself, you can remove \code{head} from the code. In the output, $x$ corresponds to wavelength, and $y$ to spectral irradiance, while \code{label} is a character string with the wavelength, possibly formatted.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 378 0.4969714   378
## 2 416 0.6761818   416
## 3 451 0.8204633   451
## 4 478 0.7869773   478
## 5 495 0.7899872   495
## 6 531 0.7603297   531
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{,}
                    \hlkwc{ignore_threshold}\hlstd{=}\hlnum{0.75}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 416 0.6761818   416
## 2 451 0.8204633   451
## 3 478 0.7869773   478
## 4 495 0.7899872   495
## 5 531 0.7603297   531
## 6 582 0.6853736   582
\end{verbatim}
\end{kframe}
\end{knitrout}

The parameter span, indicates the size in number of observations (e.g.\ number of discrete wavelength values) included in the window used to find local maxima (peaks) or minima (valleys). By providing different values for this argument
we can `adjust' how \emph{fine} or \emph{coarse} is the structure described by the peaks returned by the function. The window is always defined using an odd number of observations, if an even number is provided as argument, it is increased by one, with a warning.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{21}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 354 0.3758625   354
## 2 366 0.4491898   366
## 3 378 0.4969714   378
## 4 416 0.6761818   416
## 5 436 0.7336607   436
## 6 451 0.8204633   451
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_peaks}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 451 0.8204633   451
## 2 495 0.7899872   495
## 3 747 0.5025733   747
\end{verbatim}
\end{kframe}
\end{knitrout}

The equivalent function for finding valleys is \code{get\_valleys} taking the same parameters as \code{get\_peaks} but returning the wavelengths at which the valleys are located.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_valleys}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 358 0.2544907   358
## 2 393 0.2422023   393
## 3 431 0.4136900   431
## 4 487 0.6511654   487
## 5 517 0.6176652   517
## 6 589 0.5658760   589
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{with}\hlstd{(sun.spct,}
          \hlkwd{get_valleys}\hlstd{(w.length, s.e.irrad,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{,}
                      \hlkwc{ignore_threshold}\hlstd{=}\hlnum{0.5}\hlstd{)))}
\end{alltt}
\begin{verbatim}
##     x         y label
## 1 431 0.4136900   431
## 2 487 0.6511654   487
## 3 517 0.6176652   517
## 4 589 0.5658760   589
## 5 656 0.4982959   656
\end{verbatim}
\end{kframe}
\end{knitrout}

In the next section, we plot spectra and annotate them with peaks and valleys. If you find the meaning of the
parameters \code{span} and \code{ignore\_threshold} difficult to grasp from the explanation given above, please, study the code and plots in section \ref{sec:stat:pk:vly}.

%%%%
\section{Task: annotating peaks and valleys in spectra}\label{sec:stat:pk:vly}

Here we show an example of the use the new \code{ggplot} `statistics' \code{stat\_peaks}
from our package \code{photobiologygg}. It uses the same parameter names and take the
same arguments as the \code{get\_peaks} function described in section \ref{sec:get:pk:vly}.
We reuse once more \code{fig\_sun.e} saved in section \ref{sec:plot:spc}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+} \hlkwd{stat_peaks}\hlstd{(}\hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-peaks-2-1} 

}



\end{knitrout}

\sloppy
Now we play with \texttt{ggplot2} to show different ways of plotting the peaks and valleys.
It behaves as a \code{ggplot2} \code{stat\_xxxx} function accepting a \code{geom} argument
and all the aesthetics valid for the chosen geom. By default \code{geom\_text} is used.

We can change aesthetics, for example the colour:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+} \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
            \hlkwd{stat_valleys}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-peaks-valleys-3-1} 

}



\end{knitrout}

We can also use a different geom, in this case \code{geom\_point}, however, be aware that the \code{geom} parameter takes as argument a character string giving the name of the geom, in this case \code{"point"}.
We change a few additional aesthetics of the points: we set \code{shape} to a character, and set its size to 6.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
             \hlkwc{shape}\hlstd{=}\hlstr{"|"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{6}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-peaks-4-1} 

}



\end{knitrout}

We can add the same \code{stat} two or more times to a ggplot, in this example, each time with a different \code{geom}. First we add points to mark the peaks, and afterwards add labels showing the wavelengths at which they are located using geom \code{"text"}. For the \code{shape}, or type of symbol, we use one that supports `fill', and set the \code{fill} to \code{"white"} but keep the border of the symbol \code{"red"} by setting \code{colour}, we also change the \code{size}. With the labels we use \code{vjust} to `justify' the text moving the labels vertically, so that they do not overlap the line depicting the spectrum\footnote{The default position of labels is to have them centred on the coordinates of the peak or valley. Unless we rotate the label, \code{vjust} can be used to shift the label along the $y$-axis, however, justification is a property of the text, not the plot, so the vertical direction is referenced to the position of the text of the label. A value of 0.5 indicates centering, a negative value `up' and a positive value `down'. For example a value of -1 puts the $x, y$ coordinates of the peak or valley at the lower edge of the `bounding box' of the text. For \code{hjust} values of -1 and 1 right and left justify the label with respect to the $x, y$ coordinates supplied. Values other than -1, 0.5, and 1, are valid input, but are rather tricky to use for \code{hjust} as the displacement is computed relative to the width of the bounding box of the label, the displacement being different for the same numerical value depending on the length of the label text.}
In addition we expand the $y$-axis scale so that all labels fall within the plotting area.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlnum{23}\hlstd{,}
             \hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{vjust}\hlstd{=}\hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y}\hlstd{=}\hlnum{0.9}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-peaks-5-1} 

}



\end{knitrout}

Finally an example with rotated labels, using different colours for peaks and valleys. Be aware that the `justification' direction, as discussed in the footnote, is referenced to the position of the text, and for this reason to move the rotated labels upwards we need to use \code{hjust} as the desired displacement is horizontal with respect to the orientation of the text of the label. As we put peak labels above the spectrum and valleys bellow it, we need to use \code{hjust} values of opposite sign, but the exact values used were simply adjusted by trial and error until the figure looked as desired.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.e0} \hlopt{+}
  \hlkwd{stat_peaks}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.5}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{31}\hlstd{)} \hlopt{+}
  \hlkwd{stat_valleys}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{color}\hlstd{=}\hlstr{"blue"}\hlstd{,} \hlkwc{span}\hlstd{=}\hlnum{51}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y}\hlstd{=}\hlnum{1.0}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-peaks-valleys-1} 

}



\end{knitrout}

See section \ref{?} in chapter \ref{chap:sources} for an example these stats together with facets.

%%%%
\section{Task: annotating wavebands}\label{sec:plot:ann:wband}

The function \code{annotate\_waveband} can be used to highlight a waveband in a plot of spectral data. Its first argument should be a \code{waveband} object, and the second argument a \code{geom} as a character string. The positions on the x-axis are calculated automatically by default, but they can be overridden by explicit arguments. The vertical positions have no default, except for \code{ymin} which is equal to zero by default. The colour has a default value calculated from waveband definition, in addition x is by default set to the midpoint of the waveband along the wavelength limits. The default value of the labels is the `name' of the waveband as returned by \code{labels.waveband}.

Here is an example for \PAR using defaults, and with arguments supplied only for parameters with no defaults. The example does the annotation using two different `geoms', \code{"rect"} for marking the region, and \code{"text"} for the labels.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl} \hlkwb{<-} \hlstd{fig_sun.e0} \hlopt{+} \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
                     \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)}

\hlstd{figvl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-annotate-0-1} 

}



\end{knitrout}

This example annotates a narrow waveband.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl} \hlkwb{<-} \hlstd{fig_sun.e0} \hlopt{+} \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Yellow}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
                     \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Yellow}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)}

\hlstd{figvl} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-yellow-annotate-1} 

}



\end{knitrout}

Now an example that is more complex, and demonstrates the flexibility of plots produced with \code{ggplot2}. We add annotations for eight different wavebands, some of them overlapping. For each one we use two `geoms' and some labels are rotated and justified. We can also see in this example that the annotations look nicer on a white background, which can be obtained with \code{theme\_bw}. A much simpler, but less flexible approach for adding annotations for several wavebands is described on page \pageref{chunk:plot:ann:tag}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figv2} \hlkwb{<-} \hlstd{fig_sun.e0} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVC}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVC}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{UVA}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Blue}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Blue}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.5}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Green}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Green}\hlstd{(}\hlstr{"Sellaro"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.50}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.86}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"rect"}\hlstd{,}
                    \hlkwc{ymax}\hlstd{=}\hlnum{0.82}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{Far_red}\hlstd{(}\hlstr{"Smith"}\hlstd{),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{y}\hlstd{=}\hlnum{0.80}\hlstd{,} \hlkwc{angle}\hlstd{=}\hlnum{90}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)}

\hlstd{figv2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-many-annotate-1} 

}



\end{knitrout}

A simple example using \code{geom\_vline}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl3} \hlkwb{<-} \hlstd{fig_sun.q} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept}\hlstd{=}\hlkwd{range}\hlstd{(}\hlkwd{PAR}\hlstd{()))}

\hlstd{figvl3}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-vline-3-1} 

}



\end{knitrout}

And one where we change some of the aesthetics, and add a label:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{figvl4} \hlkwb{<-} \hlstd{fig_sun.q} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept}\hlstd{=}\hlkwd{range}\hlstd{(}\hlkwd{PAR}\hlstd{()),} \hlkwc{linetype}\hlstd{=}\hlstr{"dashed"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlnum{1.4}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}

\hlstd{figvl4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-vline-4-1} 

}



\end{knitrout}

Now including calculated values in the label, first with a simple example with only PAR.
Because of using expressions to obtain superscripts we need to add \code{parse=TRUE} to the call.
In addition as we are expressing the integral in photon based units, we also change the
type of units used for plotting the spectral irradiance (multiplying by $1 \cdot 10^6$ to
because of the unit multiplier used).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,}
                  \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_umol,}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{par} \hlkwb{<-} \hlkwd{q_irrad}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{())} \hlopt{*} \hlnum{1e6}

\hlstd{fig_sun2} \hlkwb{<-} \hlstd{fig_sun} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{3.5}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"PAR:~"}\hlstd{,} \hlkwd{signif}\hlstd{(par,}\hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{"*~mu*mol~m^\{-2\}~s^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{3.75}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}

\hlstd{fig_sun2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-annotate-1-1} 

}



\end{knitrout}

A variation of the previous figure shows how to use smaller rectangles for annotation, which yields plots where the spectrum itself is easier to see than when the rectangle overlaps the spectrum. We achieve this by supplying as argument both \code{ymax} and \code{ymin}, and slightly reducing the size of the text with \code{size = 4}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,}
                  \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{= ylab_umol,}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{par} \hlkwb{<-} \hlkwd{q_irrad}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{())} \hlopt{*} \hlnum{1e6}

\hlstd{fig_sun2} \hlkwb{<-} \hlstd{fig_sun} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"rect"}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{3.95}\hlstd{,} \hlkwc{ymin}\hlstd{=}\hlnum{3.55}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"PAR:~"}\hlstd{,} \hlkwd{signif}\hlstd{(par,}\hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{"*~mu*mol~m^\{-2\}~s^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{3.75}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}

\hlstd{fig_sun2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-annotate-2-1} 

}



\end{knitrout}


This type of annotations can be also easily done for effective exposures or doses, but in this example as we position the annotations manually, we can use ggplot2's `normal' \code{annotate} function. We use \code{xlim} to restrict the plotted region of the spectrum to the range of wavelengths of interest.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_dsun} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{polythene.new.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad} \hlopt{*} \hlnum{1e-3}\hlstd{))} \hlopt{+} \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{polyester.new.spct,}
            \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{data}\hlstd{=sun.daily.spct} \hlopt{*} \hlstd{PC.spct,}
            \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=}
   \hlkwd{expression}\hlstd{(Spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{exposure}\hlopt{~~}\hlstd{(kJ}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{d}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
       \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)} \hlopt{+} \hlkwd{xlim}\hlstd{(}\hlnum{290}\hlstd{,} \hlnum{425}\hlstd{)} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{25}\hlstd{)}

\hlstd{cie.pe} \hlkwb{<-}
  \hlkwd{e_irrad}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{polythene.new.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{cie.ps} \hlkwb{<-}
  \hlkwd{e_irrad}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{polyester.new.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{cie.pc} \hlkwb{<-}
  \hlkwd{e_irrad}\hlstd{(sun.daily.spct} \hlopt{*} \hlstd{PC.spct,} \hlkwd{CIE}\hlstd{())} \hlopt{*} \hlnum{1e-3}
\hlstd{y.pos} \hlkwb{<-} \hlnum{22.5}

\hlstd{fig_dsun2} \hlkwb{<-} \hlstd{fig_dsun} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,}
           \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polythene~~filter~~CIE:~"}\hlstd{,}
                       \hlkwd{signif}\hlstd{(cie.pe,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                       \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
           \hlkwc{y}\hlstd{=y.pos}\hlopt{+}\hlnum{2}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polyester~~filter~~CIE:~"}\hlstd{,}
                               \hlkwd{signif}\hlstd{(cie.ps,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                               \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
           \hlkwc{y}\hlstd{=y.pos,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,}  \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,}  \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"Polycarbonate~~filter~~CIE:~"}\hlstd{,}
                               \hlkwd{signif}\hlstd{(cie.pc,} \hlkwc{digits}\hlstd{=}\hlnum{3}\hlstd{),}
                               \hlstr{"*~kJ~m^\{-2\}~d^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
           \hlkwc{y}\hlstd{=y.pos}\hlopt{-}\hlnum{2}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{300}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{0}\hlstd{,}  \hlkwc{colour}\hlstd{=}\hlstr{"blue"}\hlstd{,}
           \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}

\hlstd{fig_dsun2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-cie-filter-sun-1} 

}



\end{knitrout}

% \section{Task: automating plotting}
%
% <<>>=
% fig_sun.z <-
%   ggplot(data=sun.spct, aes(x=w.length, y=s.e.irrad)) +
%   geom_line()  +
%   labs(
%     y = expression(Spectral~~energy~~irradiance~~(W~m^{-2}~nm^{-1})),
%     x = "Wavelength (nm)")
% fig_sun.z
% @

\section{Task: using colour as data in plots}

The examples in this section use a single spectrum, \code{sun.spct}, but all functions used are methods for \code{generiic.spct} objects, so are equally applicable to the plotting of other spectra like transmittance, reflectance or response ones.

When we want to colour-label individual spectral values, for example, by plotting the individual data points with the colour corresponding to their wavelengths, or fill the area below a plotted spectral curve with colours, we need to first \code{tag} the spectral data set using a waveband definition or a list of waveband definitions. If we just want to add a guide or labels to the plot, we can create new data instead of tagging the spectral data to be plotted. In section \ref{sec:plot:tag} we show code based on tagging spectral data, and in section \ref{sec:plot:guide} the case of using different data for plotting the guide or key is described.

\subsection{Scale definitions}\label{sec:plot:scales}

First we define some new scales for use for plotting with \code{ggplot} when plotting wavelength derived colours. In the future something equivalent may be included in package \code{photobiologygg} as predefined scales. We define two very similar scales, one for colour, and one for fill aesthetics.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{scale_colour_tgspct} \hlkwb{<-}
  \hlkwa{function}\hlstd{(}\hlkwc{...}\hlstd{,}
           \hlkwc{tg.spct}\hlstd{,}
           \hlkwc{labels} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{guide} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{) \{}
    \hlstd{spct.tags} \hlkwb{<-} \hlkwd{attr}\hlstd{(tg.spct,} \hlstr{"spct.tags"}\hlstd{,} \hlkwc{exact}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(guide))\{}
      \hlkwa{if} \hlstd{(spct.tags}\hlopt{$}\hlstd{wb.num} \hlopt{>} \hlnum{12}\hlstd{) \{}
        \hlstd{guide} \hlkwb{=} \hlstr{"none"}
      \hlstd{\}} \hlkwa{else} \hlstd{\{}
        \hlstd{guide} \hlkwb{=} \hlkwd{guide_legend}\hlstd{(}\hlkwc{title}\hlstd{=}\hlkwa{NULL}\hlstd{)}
      \hlstd{\}}
    \hlstd{\}}
    \hlstd{values} \hlkwb{<-} \hlkwd{as.character}\hlstd{(spct.tags}\hlopt{$}\hlstd{wb.colors)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(labels)) \{}
      \hlstd{labels} \hlkwb{<-} \hlstd{spct.tags}\hlopt{$}\hlstd{wb.names}
    \hlstd{\}}
    \hlstd{ggplot2}\hlopt{:::}\hlkwd{manual_scale}\hlstd{(}\hlstr{"colour"}\hlstd{,}
                           \hlkwc{values} \hlstd{= values,}
                           \hlkwc{labels} \hlstd{= labels,}
                           \hlkwc{guide} \hlstd{= guide,}
                           \hlkwc{na.value} \hlstd{= na.value,}
                           \hlstd{...)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{scale_fill_tgspct} \hlkwb{<-}
  \hlkwa{function}\hlstd{(}\hlkwc{...}\hlstd{,}
           \hlkwc{tg.spct}\hlstd{,}
           \hlkwc{labels} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{guide} \hlstd{=} \hlkwa{NULL}\hlstd{,}
           \hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{) \{}
    \hlstd{spct.tags} \hlkwb{<-} \hlkwd{attr}\hlstd{(tg.spct,} \hlstr{"spct.tags"}\hlstd{,} \hlkwc{exact}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(guide))\{}
      \hlkwa{if} \hlstd{(spct.tags}\hlopt{$}\hlstd{wb.num} \hlopt{>} \hlnum{12}\hlstd{) \{}
        \hlstd{guide} \hlkwb{=} \hlstr{"none"}
      \hlstd{\}} \hlkwa{else} \hlstd{\{}
        \hlstd{guide} \hlkwb{=} \hlkwd{guide_legend}\hlstd{(}\hlkwc{title}\hlstd{=}\hlkwa{NULL}\hlstd{)}
      \hlstd{\}}
    \hlstd{\}}
    \hlstd{values} \hlkwb{<-} \hlkwd{as.character}\hlstd{(spct.tags}\hlopt{$}\hlstd{wb.colors)}
    \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(labels)) \{}
      \hlstd{labels} \hlkwb{<-} \hlstd{spct.tags}\hlopt{$}\hlstd{wb.names}
    \hlstd{\}}

    \hlstd{ggplot2}\hlopt{:::}\hlkwd{manual_scale}\hlstd{(}\hlstr{"fill"}\hlstd{,}
                           \hlkwc{values} \hlstd{= values,}
                           \hlkwc{labels} \hlstd{= labels,}
                           \hlkwc{guide} \hlstd{= guide,}
                           \hlkwc{na.value} \hlstd{= na.value,}
                           \hlstd{...)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Plots using colour for the spectral data}\label{sec:plot:tag}

We start by describing how to tag a spectrum, and then show how to use tagged spectra for plotting data. Tagging consist in adding wavelength-derived colour data and waveband-related data to a spectral object. We start with a very simple example.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cp.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(cp.sun.spct)}
\end{alltt}
\end{kframe}
\end{knitrout}

As no waveband information was supplied as input, only wavelength-dependent colour information is added to the spectrum plus a factor \code{wb.f} with only \code{NA} level.

If we instead provide a waveband as input then both wavelength-dependent colour and waveband information are added to the spectral data object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{uvb.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(uvb.sun.spct,} \hlkwd{UVB}\hlstd{())}
\hlkwd{levels}\hlstd{(uvb.sun.spct[[}\hlstr{"wb.f"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] "UVB"
\end{verbatim}
\end{kframe}
\end{knitrout}

The output contains the same variables (columns) but now the factor \code{wb.f} has a level based on the name of the waveband, and a value of \code{NA} outside it.

We can alter the name used for the \code{wb.f} factor levels by using a named list as argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tag}\hlstd{(uvb.sun.spct,} \hlkwd{list}\hlstd{(}\hlstr{'ultraviolet-B'} \hlstd{=} \hlkwd{UVB}\hlstd{()))}
\hlkwd{levels}\hlstd{(uvb.sun.spct[[}\hlstr{"wb.f"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] "ultraviolet-B"
\end{verbatim}
\end{kframe}
\end{knitrout}

This example also shows, that re-tagging a spectrum replaces the old tagging data with the new one.

If we use a list of wavebands then the tagging is based on all of them, but be aware that the wavelength ranges of the wavebands overlap, the result is undefined.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(plant.sun.spct,} \hlkwd{Plant_bands}\hlstd{())}
\hlkwd{levels}\hlstd{(plant.sun.spct[[}\hlstr{"wb.f"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] "UVB"   "UVA"   "Blue"  "Green" "R"    
## [6] "FR"
\end{verbatim}
\end{kframe}
\end{knitrout}

Tagging also adds some additional data as an attribute to the spectrum. This data can be retrieved with the base R function \code{attr}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(cp.sun.spct,} \hlstr{"spct.tag"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $time.unit
## [1] "second"
## 
## $wb.key.name
## [1] "Bands"
## 
## $wl.color
## [1] TRUE
## 
## $wb.color
## [1] TRUE
## 
## $wb.num
## [1] 0
## 
## $wb.colors
## [1] NA
## 
## $wb.names
## [1] NA
## 
## $wb.list
## NULL
\end{verbatim}
\begin{alltt}
\hlkwd{attr}\hlstd{(uvb.sun.spct,} \hlstr{"spct.tag"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $time.unit
## [1] "second"
## 
## $wb.key.name
## [1] "Bands"
## 
## $wl.color
## [1] TRUE
## 
## $wb.color
## [1] TRUE
## 
## $wb.num
## [1] 1
## 
## $wb.colors
## $wb.colors[[1]]
## [1] "#000000"
## 
## 
## $wb.names
## [1] "ultraviolet-B"
## 
## $wb.list
## $wb.list$`ultraviolet-B`
## UVB.ISO 
## low (nm) 280 
## high (nm) 315 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

We now tag a spectrum for use in our first plot example.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(par.sun.spct,} \hlkwd{PAR}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

Here we simply use the \code{wb.f} factor that was added as part of the tagging, with the default colour scale of \code{ggplot2}, which results in a palette unrelated to the real colour of the different wavelengths.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.t00} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=par.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{color}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.t00}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-par-2-1} 

}



\end{knitrout}

We can also use other geoms like \code{geom\_area} in the next chunk, together with, as an example, a grey fill scale from \code{ggplot2}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.t01} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=par.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwc{color}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.t01}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-par-3-1} 

}



\end{knitrout}

The default fill looks too dark and bold, so we change the transparency of the fill by setting \code{fill = 0.3}. The grid in the background becomes slightly visible also in the filled region, facilitating `reading' of the plot and avoiding a to stark contrast between regions, which tends to be disturbing. In later plots we frequently use \code{alpha} to improve how plots look, but we exemplify the effect of changing this aesthetic only here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.t01} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=par.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwc{color}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{,} \hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.t01}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-par-4-1} 

}



\end{knitrout}

As part of the tagging colour information was also added to the spectral data object\footnote{We may want to increase the number of `observations' in the spectrum by interpolation if there are too few observations for a smooth colour gradient.}. We tag each observation in the solar spectrum with human vision colours as defined by ISO.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tg.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(tg.sun.spct,} \hlkwd{VIS_bands}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

See section \ref{sec:plot:scales} on page \pageref{sec:plot:scales} for the definition of the colour and fill scales used for tagged spectra. These definitions are needed for most of the plots in the remaining of the present and next sections. These scales retrieve information about the wavebands both from the data itself and from the attribute described above.

Here we plot using colours by waveband---using the colour definitions by ISO---, with symbols filled with colours. The colour data outside the wavebands is set to \code{NA} so those points are not filled.  One can play with the \code{size} of points until ones get the result wanted. The default `shape' used by \code{ggplot2} do not accept a \code{fill} aesthetic, while shape `21' gives circles that can be `filled'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.t02} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=tg.sun.spct)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{)}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.t02}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-vis-2-1} 

}



\end{knitrout}

Using \code{geom\_area} we can fill the area under the curve according to the colour of different wavebands, we set the fill only for this geom, so that the \code{NA}s do not affect other plotting. To get a single black curve for the spectrum we use \code{geom\_line}. This approach works as long as wavebands do not share the same value for the color, which means that it is not suitable either when more than one band is outside the visible range, or when using many narrow wavebands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.t03} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=tg.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.75}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.t03} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-vis-3-1} 

}



\end{knitrout}

In the next example we tag the solar spectrum with colours using the definitions of plant sensory `colours'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pl.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(pl.sun.spct,} \hlkwd{Plant_bands}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

Here we plot the wavebands corresponding to plant sensory `colours', using the spectrum we tagged in the previous code chunk.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.pl0} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(pl.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=pl.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.75}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.pl0} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-plants-2-1} 

}



\end{knitrout}

We can also use the factor \code{wb.f} which has value \code{NA} outside the wavebands, changing the colour used for \code{NA} to \code{NA} which renders it invisible. We can change the labels used for the wavebands in two different way, when plotting by supplying a labels argument to the scale used, or when tagging the spectrum. The second approach is simpler when producing several different plots from the same spectral object, or when wanting to have consistent labels and names used also in derived results such as irradiance.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.pl1} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(pl.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{name}\hlstd{=}\hlstr{""}\hlstd{,}
                  \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"UVB"}\hlstd{,} \hlstr{"UVA"}\hlstd{,} \hlstr{"Blue"}\hlstd{,}
                           \hlstr{"Green"}\hlstd{,} \hlstr{"Red"}\hlstd{,} \hlstr{"Far red"}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.pl1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tag-plants-3-1} 

}



\end{knitrout}

When using a factor we can play with the scale definitions and represent the wavebands in any way we may want. For example we can use \code{split\_bands} to split a waveband or spectrum into many adjacent narrow bands and get an almost continuous gradient, but we need to get around the problem of repeated colours by using the factor and redefining the scale.

When an spectrum has very few observations we can `fake' a longer spectrum by interpolation as a way of getting a more even fill. The example below is not run, in later examples we just use the example spectral data as is.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{interpolate_spct}\hlstd{(sun.spct,} \hlkwc{length.out}\hlstd{=}\hlnum{800}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We tag the VIS region of the spectrum with 150 narrow wavebands. As `hinges' are inserted, there is no gap, and usually there is no need to increase the length of the spectrum by interpolation. If needed one could try something
like. However, the longer spectrum should not be used for statistical calculations, not even plotting using \code{geom\_smooth}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{splt.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlkwd{tag}\hlstd{(splt.sun.spct,} \hlkwd{split_bands}\hlstd{(}\hlkwd{VIS}\hlstd{(),} \hlkwc{length.out}\hlstd{=}\hlnum{150}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

In the code above, we made a copy of \code{sun.spct} because being part of the package, it is write protected, and \code{tag} works by modifying its argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt0} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(splt.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt.sun.spct)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.75}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.splt0} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-split-VIS-2-1} 

}



\end{knitrout}

In this other example we tag the whole spectrum, dividing it into 200 wavebands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{splt1.sun.spct} \hlkwb{<-} \hlkwd{copy}\hlstd{(sun.spct)}
\hlcom{# splt1.sun.spct <- interpolate_spct(splt1.sun.spct, length.out=1000)}
\hlkwd{tag}\hlstd{(splt1.sun.spct,} \hlkwd{split_bands}\hlstd{(sun.spct,} \hlkwc{length.out}\hlstd{=}\hlnum{200}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

We use \code{geom\_area} and \code{fill}, and colour the area under the curve. This does not work with \code{geom\_line} because there would not be anything to fill, here we use \code{geom\_area} instead.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.splt1} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(splt1.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=splt1.sun.spct)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f),} \hlkwc{alpha}\hlstd{=}\hlnum{0.75}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.splt1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-split-all-2-1} 

}



\end{knitrout}

The next example uses \code{geom\_point} and \code{colour} to color the data points according the waveband they are included in.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.tg1} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{scale_colour_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=tg.sun.spct)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{colour}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.tg1} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-split-all-4-1} 

}



\end{knitrout}

When plotting points, rather than an area we may, instead of using colours from wavebands, want to plot the colour calculated for each individual wavelength value, which \code{tag} adds to the spectrum, whether a waveband definition is supplied or not. In
this case we need to use \code{scale\_color\_identity}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.tg2} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_color_identity}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{color}\hlstd{=wl.color))}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.tg2}  \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-split-all-5-1} 

}



\end{knitrout}

Other possibilities are for example, using one of the symbols that can be filled, and then for example for symbols with a black border and a colour matching its wavelength as a fill aesthetic. It is also possible to use \code{alpha} with points.

\subsection{Plots using waveband definitions}\label{sec:plot:guide}

In the previous section we showed how tagging spectral data can be used to add colour information that can be used when plotting. In contrast, in the present section we create new `fake' spectral data starting from waveband definitions that then we plot as `annotations'. We show different types of annotations based on plotting with different geoms. We show the use of \code{geom\_rect}, \code{geom\_text}, \code{geom\_vline}, and \code{geom\_segment}, that we consider the most useful geometries in this context.

We use three different functions from package \code{photobiology} to generate the data to be plotted from lists of waveband definitions. We use mainly pre-defined wavebands, but user defined wavebands can be used as well. We start by showing the output of these functions, starting with \code{wb2spct} the simplest one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{wb2spct}\hlstd{(}\hlkwd{PAR}\hlstd{())}
\hlkwd{wb2spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \code{wb2tagged\_spct} returns the same `spectrum', but tagged with the same wavebands as used to create the spectral data, and you will also notice that a `hinge' has been added, which is redundant in the case of a single waveband, but needed in the case of wavebands sharing a limit.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{wb2tagged_spct}\hlstd{(}\hlkwd{PAR}\hlstd{())}
\hlkwd{wb2tagged_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

The third function, \code{wb2rect\_spct} is what we use in most examples. It generates data that make it easier to plot rectangles with \code{geom\_rect} as we will see in later examples.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{PAR}\hlstd{())}
\hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

In this case instead of two rows per waveband, we obtain only one row per waveband, with a \code{w.length} value corresponding to its midpoint but with two additional columns giving the low and high wavelength limits.

As we saw earlier for tagged spectra, additional data is stored in an attribute.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(}\hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{PAR}\hlstd{()),} \hlstr{"spct.tags"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $time.unit
## [1] "none"
## 
## $wb.key.name
## [1] "Bands"
## 
## $wl.color
## [1] TRUE
## 
## $wb.color
## [1] TRUE
## 
## $wb.num
## [1] 1
## 
## $wb.colors
## $wb.colors[[1]]
##   PAR.CMF 
## "#735B57" 
## 
## 
## $wb.names
## [1] "PAR"
## 
## $wb.list
## $wb.list[[1]]
## PAR 
## low (nm) 400 
## high (nm) 700 
## weighted none
\end{verbatim}
\end{kframe}
\end{knitrout}

The first plot examples show how to add a colour bar as key. We create new data for use in what is closer to the concept of annotation that to plotting. In most of the examples below we use waveband definitions to create tagged spectral data for use in plotting the guide using \code{geom\_rect}. We present three cases: an almost continuous colour reference guide, a reference guide for colours perceived by plants and one for ISO colour definitions. We also add labels to the bar with \code{geom\_text} and show some examples of how to change the color of the line enclosing the rectangles and of text labels. Finally we show how to use \code{fill} and \code{alpha} to adjust how the guides look. Later on we show some examples using other geoms and also examples combining the use of tagged spectra as described in the previous section with the `annotations' described here.

First we create a simple line plot of the solar spectrum, that we will use as a basis for most of the examples below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_sun.z0} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.z0}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plain-1} 

}



\end{knitrout}


We now add to the plot created above a nearly continuous colour bar for the whole spectrum. To obtain an almost continuous colour scale we use a list of 200 wavebands. We need to specify \code{color = NA} to prevent the line enclosing each of the 200 rectangles from being plotted. We position the bar at the top because we think that it looks best, but by changing the values supplied to \code{ymax} and \code{ymin} move the bar vertically and also change its width.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wl.guide.spct} \hlkwb{<-}
  \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{split_bands}\hlstd{(sun.spct,}
                           \hlkwc{length.out}\hlstd{=}\hlnum{200}\hlstd{))}

\hlstd{fig_sun.z2} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=wl.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
            \hlkwc{color} \hlstd{=} \hlnum{NA}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=wl.guide.spct)}

\hlstd{fig_sun.z2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-wl-all-guide-1} 

}



\end{knitrout}

This second example differs very little from the previous one, but by using a waveband definition instead of a spectrum as argument to \code{split\_bands}, we restrict the region covered by the colour fill to that of the waveband. In fax a vector of length two, or any object for which a \code{range} method is available can be used as input to this function.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wl.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{split_bands}\hlstd{(}\hlkwd{VIS}\hlstd{(),} \hlkwc{length.out}\hlstd{=}\hlnum{200}\hlstd{))}

\hlstd{fig_sun.z1} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=wl.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
            \hlkwc{color} \hlstd{=} \hlnum{NA}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=wl.guide.spct)}

\hlstd{fig_sun.z1}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-wl-vis-guide-1} 

}



\end{knitrout}

In the examples above we have used a list of 200 waveband definitions created with \code{split\_bands}. If we instead use a shorter list of definitions, we get a plot where the wavebands are clearly distinguished. By default if the list of wavebands is short, a key or `guide' is also added to the plot.

To demonstrate this we replace in the previous example, the previous tagged spectrum with one based on ISO colours. We need to do this replacement in the calls to both \code{geom\_rect} and \code{scale\_fill\_tgspct}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{iso.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{VIS_bands}\hlstd{())}

\hlstd{fig_sun.z3} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=iso.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
            \hlkwc{color} \hlstd{=} \hlnum{NA}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=iso.guide.spct)}

\hlstd{fig_sun.z3}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-iso-guide-1} 

}



\end{knitrout}

We use as an example plant's sensory colours, to show the case when the wavebands in the list are not contiguous.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z4} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
            \hlkwc{color} \hlstd{=} \hlstr{"white"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct)}

\hlstd{fig_sun.z4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-1-1} 

}



\end{knitrout}

We add text labels on top of the guide, and make the rectangle borders and text white to make the separation between the different `invisible' wavebands clear. As we are adding labels, the `guide' or key becomes redundant and we remove it by adding \code{guide="none"} to the fill scale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z5} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
            \hlkwc{color} \hlstd{=} \hlstr{"white"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.875}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
            \hlkwc{color} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}

\hlstd{fig_sun.z5}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-2-1} 

}



\end{knitrout}

Here we add \code{alpha} or transparency to make the colours paler, and use black text and lines.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z6} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
           \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
           \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.4}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.875}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}

\hlstd{fig_sun.z6} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-3-1} 

}



\end{knitrout}

We change the guide so that all rectangles are filled with the same shade of grey by moving \code{fill} out of \code{aes} and setting it to a constant.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z7} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.9}\hlstd{,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{),}
            \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"grey90"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.875}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
            \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)}

\hlstd{fig_sun.z7} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-4-1} 

}



\end{knitrout}

We can obtain annotations similar to those in \ref{sec:plot:ann:wban} in page \pageref{sec:plot:ann:wban} created with \code{annotate\_waveband} using geoms.\label{chunk:plot:ann:tag}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z8} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
           \hlkwc{ymin} \hlstd{= y,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,}
           \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
       \hlkwc{color} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.5}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.88}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}

\hlstd{fig_sun.z8} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-5-1} 

}



\end{knitrout}

The example above can be improved by changing the order in which the geoms are added. In the plot above we can see that the rectangles are plotted on top of the line for the spectral irradiance. By changing the order we obtain a better plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z8a} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
           \hlkwc{ymin} \hlstd{= y,} \hlkwc{ymax} \hlstd{= y} \hlopt{+} \hlnum{0.85}\hlstd{,}
           \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{fill}\hlstd{=wb.f),}
       \hlkwc{color} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.5}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.88}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_fill_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)}

\hlstd{fig_sun.z8a} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-5a-1} 

}



\end{knitrout}

In the examples above we used predefined lists of wavebands, but one can, of course, use any list of waveband definitions, for example explicitly created with \code{list} and \code{new\_waveband}, or \code{list} and any combination of user-defined and predefined wavebands. Even single waveband definitions are allowed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{PAR}\hlstd{())}

\hlstd{fig_sun.z9} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=par.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin} \hlstd{= wl.low,} \hlkwc{xmax} \hlstd{= wl.high,}
                \hlkwc{ymin} \hlstd{= y} \hlopt{-} \hlnum{0.1}\hlstd{,} \hlkwc{ymax} \hlstd{= y,}
                \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{),}
            \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"grey90"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=par.guide.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{-} \hlnum{0.05}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
            \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)}

\hlstd{fig_sun.z9} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-guide-1-1} 

}



\end{knitrout}

We can also use \code{geom\_segment} to draw lines, including arrows. In this example we also set a different font \code{family} and label text. We can replace the label text which is by default obtained from the waveband definition by assigning a name to the waveband as member of the list. We use single quotes so that the long name containing space characters is accepted by \code{list}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par.guide1.spct} \hlkwb{<-}
  \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{list}\hlstd{(}\hlstr{'Photosynthetically active radiation'} \hlstd{=} \hlkwd{PAR}\hlstd{()))}

\hlstd{fig_sun.z10} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_segment}\hlstd{(}\hlkwc{data}\hlstd{=par.guide1.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wl.low,} \hlkwc{xend} \hlstd{= wl.high,}
           \hlkwc{y} \hlstd{= y,} \hlkwc{yend} \hlstd{= y),}
       \hlkwc{size} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=par.guide1.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.05}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{family}\hlstd{=}\hlstr{"serif"}\hlstd{)}

\hlstd{fig_sun.z10} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-guide-2-1} 

}



\end{knitrout}

In this section we have used until now function \code{wb2rect\_spct} to create `spectral' annotation data from waveband definitions. Two other functions are available, that are needed or easier to use in some cases. One such case is when we have a list of wavebands and we would like to mark their boundaries with vertical lines. How to do this with \code{annotate} and \code{range} was show earlier in this chapter, but this can become tedious when we have several wavebands. Here we show an alternative approach.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.boundaries.spct} \hlkwb{<-} \hlkwd{wb2spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z11} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{data}\hlstd{=plant.boundaries.spct,}
             \hlkwd{aes}\hlstd{(}\hlkwc{xintercept} \hlstd{= w.length),}
             \hlkwc{linetype} \hlstd{=} \hlstr{"dotted"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.88}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)}

\hlstd{fig_sun.z11} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-6-1} 

}



\end{knitrout}

Function \code{wb2tagged\_spct} returns the same data as \code{wb2spct} but `tagged'. As shown in the next code chunk, tagging allows us to use waveband-dependent colours to the vertical lines.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{plant.boundaries.spct} \hlkwb{<-} \hlkwd{wb2tagged_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}
\hlstd{plant.guide.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{Plant_bands}\hlstd{())}

\hlstd{fig_sun.z12} \hlkwb{<-} \hlstd{fig_sun.z0} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{data}\hlstd{=plant.boundaries.spct,}
             \hlkwd{aes}\hlstd{(}\hlkwc{xintercept} \hlstd{= w.length,} \hlkwc{color}\hlstd{=wb.f),}
             \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{linetype}\hlstd{=}\hlstr{"dashed"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=plant.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.88}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f),} \hlkwc{colour}\hlstd{=wb.f),}
       \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{scale_colour_tgspct}\hlstd{(}\hlkwc{tg.spct}\hlstd{=plant.guide.spct,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}

\hlstd{fig_sun.z12} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-plant-guide-7-1} 

}



\end{knitrout}

Of course it is possible to combine tagged data spectra and tagged spectra created from wavebands. The tagging is consistent, so, as demonstrated in the next figure, the same aesthetic `link' works for both spectra. In this case the fill scale and the setting of fill to \code{wb.f} work accross different `data' and yield a consistent look. This figure also shows that when assigning a constant to an aesthetic, it is possible to use a vector, which in the present example, saves us some work compared to adding a column to the data and using an identity scale. Contrary to earleir examples where we have added layers to a previously saved plot, here we show the whole code needed to build the figure.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.sun.spct} \hlkwb{<-} \hlstd{sun.daily.spct}
\hlkwd{tag}\hlstd{(my.sun.spct,} \hlkwd{list}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{()))}
\hlstd{annotation.spct} \hlkwb{<-} \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{list}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{()))}
\hlstd{fig_sun.uv1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(my.sun.spct,}
                      \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,}
                          \hlkwc{y}\hlstd{=s.e.irrad} \hlopt{*} \hlnum{1e-3}\hlstd{,}
                          \hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_area}\hlstd{()} \hlopt{+} \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Wvelength (nm)"}\hlstd{,}
       \hlkwc{y} \hlstd{=}  \hlkwd{expression}\hlstd{(}\hlkwd{atop}\hlstd{(Spectral}\hlopt{~~}\hlstd{daily}\hlopt{~~}\hlstd{exposure,}
                       \hlstd{(kJ}\hlopt{~~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{d}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\}))),}
       \hlkwc{fill} \hlstd{=} \hlstr{""}\hlstd{,}
       \hlkwc{title} \hlstd{=}
   \hlstr{"Unweighted solar radiation (daily accumulated spectrum)"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=annotation.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{xmin}\hlstd{=wl.low,} \hlkwc{xmax}\hlstd{=wl.high,} \hlkwc{ymin}\hlstd{=}\hlnum{30}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{32}\hlstd{))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=annotation.spct,}
            \hlkwd{aes}\hlstd{(}\hlkwc{label}\hlstd{=}\hlkwd{as.character}\hlstd{(wb.f),} \hlkwc{y}\hlstd{=}\hlnum{31}\hlstd{),}
            \hlkwc{color}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"white"}\hlstd{,}\hlstr{"black"}\hlstd{),} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}

\hlstd{fig_sun.uv1}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-153-1} 

}



\end{knitrout}

Possible variations are almost endless, so we invite the reader to continue exploring how the functions from package \code{photobiology} can be used together with \code{ggplot}, to obtain beautiful plots of spectra. As an example here we show new versions of two plots from the previous section, one using a filled area to label the PAR region, and another one using symbols with colours according to their wavelength, to which we add a guide for PAR.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par} \hlkwb{<-} \hlkwd{q_irrad_spct}\hlstd{(sun.spct,} \hlkwd{PAR}\hlstd{())} \hlopt{*} \hlnum{1e6}

\hlstd{fig_sun.tgrect1} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=par.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwc{color}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{,} \hlkwd{aes}\hlstd{(}\hlkwc{fill}\hlstd{=wb.f))}  \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{(}\hlkwc{na.value}\hlstd{=}\hlnum{NA}\hlstd{,} \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_umol,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate_waveband}\hlstd{(}\hlkwd{PAR}\hlstd{(),} \hlstr{"text"}\hlstd{,}
                    \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(}\hlstr{"PAR:~"}\hlstd{,} \hlkwd{signif}\hlstd{(par,}\hlkwc{digits}\hlstd{=}\hlnum{2}\hlstd{),}
                                \hlstr{" * ~mu * mol~m^\{-2\}~s^\{-1\}"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),}
                    \hlkwc{y}\hlstd{=}\hlnum{1.5}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}

\hlstd{fig_sun.tgrect1}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-tag-annotate-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{par.guide.spct} \hlkwb{<-}
  \hlkwd{wb2rect_spct}\hlstd{(}\hlkwd{list}\hlstd{(}\hlstr{'Photosynthetically active radiation'} \hlstd{=} \hlkwd{PAR}\hlstd{()))}

\hlstd{fig_sun.tgrect2} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=tg.sun.spct,}
         \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{scale_color_identity}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{color}\hlstd{=wl.color))}  \hlopt{+}
  \hlkwd{labs}\hlstd{(}
    \hlkwc{y} \hlstd{= ylab_watt,}
    \hlkwc{x} \hlstd{=} \hlstr{"Wavelength (nm)"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_segment}\hlstd{(}\hlkwc{data}\hlstd{=par.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wl.low,} \hlkwc{xend} \hlstd{= wl.high,} \hlkwc{y} \hlstd{= y,} \hlkwc{yend} \hlstd{= y),}
       \hlkwc{size} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=par.guide.spct,}
       \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y} \hlopt{+} \hlnum{0.05}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{as.character}\hlstd{(wb.f)),}
       \hlkwc{color} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{family}\hlstd{=}\hlstr{"serif"}\hlstd{)}

\hlstd{fig_sun.tgrect2} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-par-tag-segment-1} 

}



\end{knitrout}

\section{Task: plotting effective spectral irradiance}

This task is here simply to show that there is nothing special about plotting spectra based on calculations, and that one can combine different functions to get the job done. We also show how to `row bind' spectra for plotting, in this case to make it easy to use facets.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sun.eff.cie.nf.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlkwd{CIE}\hlstd{()}
\hlstd{sun.eff.cie.pe.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{polyester.new.spct} \hlopt{*} \hlkwd{CIE}\hlstd{()}
\hlstd{sun.eff.cie.226.spct} \hlkwb{<-} \hlstd{sun.spct} \hlopt{*} \hlstd{uv.226.new.spct} \hlopt{*} \hlkwd{CIE}\hlstd{()}
\hlkwd{tag}\hlstd{(sun.eff.cie.nf.spct,} \hlkwd{UV_bands}\hlstd{())}
\hlkwd{tag}\hlstd{(sun.eff.cie.pe.spct,} \hlkwd{UV_bands}\hlstd{())}
\hlkwd{tag}\hlstd{(sun.eff.cie.226.spct,} \hlkwd{UV_bands}\hlstd{())}
\hlstd{sun.eff.cie.nf.spct[ , filter} \hlkwb{:=} \hlstr{'no filter'}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad wl.color wb.f
##   1:      293 2.609665e-06  #000000  UVB
##   2:      294 6.142401e-06  #000000  UVB
##   3:      295 2.176175e-05  #000000  UVB
##   4:      296 6.780119e-05  #000000  UVB
##   5:      297 1.533491e-04  #000000  UVB
##  ---                                    
## 506:      796 0.000000e+00  #000000   NA
## 507:      797 0.000000e+00  #000000   NA
## 508:      798 0.000000e+00  #000000   NA
## 509:      799 0.000000e+00  #000000   NA
## 510:      800 0.000000e+00  #000000   NA
##         filter
##   1: no filter
##   2: no filter
##   3: no filter
##   4: no filter
##   5: no filter
##  ---          
## 506: no filter
## 507: no filter
## 508: no filter
## 509: no filter
## 510: no filter
\end{verbatim}
\begin{alltt}
\hlstd{sun.eff.cie.pe.spct[ , filter} \hlkwb{:=} \hlstr{'polyester'}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length    s.e.irrad wl.color wb.f
##   1:      293 7.828995e-09  #000000  UVB
##   2:      294 1.842720e-08  #000000  UVB
##   3:      295 6.528525e-08  #000000  UVB
##   4:      296 2.034036e-07  #000000  UVB
##   5:      297 4.600472e-07  #000000  UVB
##  ---                                    
## 506:      796 0.000000e+00  #000000   NA
## 507:      797 0.000000e+00  #000000   NA
## 508:      798 0.000000e+00  #000000   NA
## 509:      799 0.000000e+00  #000000   NA
## 510:      800 0.000000e+00  #000000   NA
##         filter
##   1: polyester
##   2: polyester
##   3: polyester
##   4: polyester
##   5: polyester
##  ---          
## 506: polyester
## 507: polyester
## 508: polyester
## 509: polyester
## 510: polyester
\end{verbatim}
\begin{alltt}
\hlstd{sun.eff.cie.226.spct[ , filter} \hlkwb{:=} \hlstr{'Rosco #226'}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      w.length s.e.irrad wl.color wb.f     filter
##   1:      293         0  #000000  UVB Rosco #226
##   2:      294         0  #000000  UVB Rosco #226
##   3:      295         0  #000000  UVB Rosco #226
##   4:      296         0  #000000  UVB Rosco #226
##   5:      297         0  #000000  UVB Rosco #226
##  ---                                            
## 506:      796         0  #000000   NA Rosco #226
## 507:      797         0  #000000   NA Rosco #226
## 508:      798         0  #000000   NA Rosco #226
## 509:      799         0  #000000   NA Rosco #226
## 510:      800         0  #000000   NA Rosco #226
\end{verbatim}
\begin{alltt}
\hlstd{sun.eff.cie.spct} \hlkwb{<-} \hlkwd{rbindspct}\hlstd{(}\hlkwd{list}\hlstd{(sun.eff.cie.nf.spct,}
                                   \hlstd{sun.eff.cie.pe.spct,}
                                   \hlstd{sun.eff.cie.226.spct))}
\hlstd{sun.eff.cie.spct[ , filter} \hlkwb{:=} \hlkwd{factor}\hlstd{(filter)]}
\end{alltt}
\begin{verbatim}
##       w.length    s.e.irrad wl.color wb.f
##    1:      293 2.609665e-06  #000000  UVB
##    2:      293 7.828995e-09  #000000  UVB
##    3:      293 0.000000e+00  #000000  UVB
##    4:      294 6.142401e-06  #000000  UVB
##    5:      294 1.842720e-08  #000000  UVB
##   ---                                    
## 1526:      799 0.000000e+00  #000000   NA
## 1527:      799 0.000000e+00  #000000   NA
## 1528:      800 0.000000e+00  #000000   NA
## 1529:      800 0.000000e+00  #000000   NA
## 1530:      800 0.000000e+00  #000000   NA
##           filter
##    1:  no filter
##    2:  polyester
##    3: Rosco #226
##    4:  no filter
##    5:  polyester
##   ---           
## 1526:  polyester
## 1527: Rosco #226
## 1528:  no filter
## 1529:  polyester
## 1530: Rosco #226
\end{verbatim}
\begin{alltt}
\hlstd{fig_sun.cie0} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=sun.eff.cie.spct,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=w.length,} \hlkwc{y}\hlstd{=s.e.irrad,} \hlkwc{fill}\hlstd{=wb.f))} \hlopt{+}
  \hlkwd{scale_fill_grey}\hlstd{()} \hlopt{+}
  \hlkwd{geom_area}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{= xlab_nm,}
       \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Effective}\hlopt{~~}\hlstd{spectral}\hlopt{~~}\hlstd{energy}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(W}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{nm}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
       \hlkwc{title} \hlstd{=} \hlstr{"CIE 1998 erythemal BSWF"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(filter}\hlopt{~}\hlstd{.)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{fill}\hlstd{=}\hlstr{""}\hlstd{)} \hlopt{+}
  \hlkwd{xlim}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{400}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{legend.position}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.90}\hlstd{,} \hlnum{0.9}\hlstd{))}

\hlstd{fig_sun.cie0}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 400 rows containing missing values (position\_stack).}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 400 rows containing missing values (position\_stack).}}

{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 400 rows containing missing values (position\_stack).}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-eff-cie-1-1} 

}



\end{knitrout}

There is one warning issued for each panel, as the use of \code{xlim} discards 400 observations for wavelengths longer than 400~\Unit(nm). One should be aware that these are estimated values and in practice stray light reduces the eficiency of the filters for blocking radiation, and the amount of stray light depends on many factors including the relative positions of plants, filter and sun.

A couple of details need to be remembered: the tagging has to be done before row-binding the spectra, as \code{tag} works only on spectra that have unique values for wavelengths and discards `repeated' rows if they are present. We use \code{theme(legend.position=c(0.90, 0.9))} to change where the legend or guide is positioned. In this case, we move the legend to a place within the plotting region. As we are using also \code{theme\_bw()} which resets the legend position to the default, the order in which they are added is significant.

\section{Task: making a bar plot of effective irradiance}



In this task we aim at creating bar plots depicting the contributions of the UVB and UVA bands to the total erythemal effective irradiance in sunlight filtered with different plastic films. First we calculate the effective energy irradiance using the waveband definition for erythemal BSWF (CIE98) separately for the estimated solar spectral irradiance under each filter type.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cie.nf.irrad} \hlkwb{<-} \hlkwd{e_irrad}\hlstd{(sun.spct} \hlopt{*} \hlkwd{CIE}\hlstd{(),}
                        \hlkwd{list}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{()))}
\hlstd{cie.pe.irrad} \hlkwb{<-} \hlkwd{e_irrad}\hlstd{(sun.spct} \hlopt{*} \hlstd{polyester.new.spct} \hlopt{*} \hlkwd{CIE}\hlstd{(),}
                        \hlkwd{list}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{()))}
\hlstd{cie.226.irrad} \hlkwb{<-} \hlkwd{e_irrad}\hlstd{(sun.spct} \hlopt{*} \hlstd{uv.226.new.spct} \hlopt{*} \hlkwd{CIE}\hlstd{(),}
                         \hlkwd{list}\hlstd{(}\hlkwd{UVB}\hlstd{(),} \hlkwd{UVA}\hlstd{()))}
\end{alltt}
\end{kframe}
\end{knitrout}

We assemble a data table by concatenating the irradiance and adding factors for filter type and wave bands. When
defining the factors, we use \code{levels} to make sure that the levels are ordered as we would like to plot them.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cie.dt} \hlkwb{<-} \hlkwd{data.table}\hlstd{(}
  \hlkwc{cie.irrad} \hlstd{=} \hlkwd{c}\hlstd{(cie.nf.irrad, cie.pe.irrad, cie.226.irrad),}
  \hlkwc{filter} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'none'}\hlstd{,} \hlstr{'polyester'}\hlstd{,} \hlstr{'Rosco #226'}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{2}\hlstd{,}\hlnum{2}\hlstd{)),}
                  \hlkwc{levels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{'none'}\hlstd{,} \hlstr{'polyester'}\hlstd{,} \hlstr{'Rosco #226'}\hlstd{)),}
  \hlkwc{w.band} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'UVB'}\hlstd{,} \hlstr{'UVA'}\hlstd{),} \hlnum{3}\hlstd{),}
                  \hlkwc{levels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{'UVB'}\hlstd{,} \hlstr{'UVA'}\hlstd{)) )}
\end{alltt}
\end{kframe}
\end{knitrout}

Now we plot stacked bars using \code{geom\_bar}, however as the default \code{stat} of this geom is not suitable for our data, we specify \code{stat="identity"} to have the data plotted as is. We set a specific palette for fill, and add a black border to the bars by means of \code{color="black"}, we remove the grid lines corresponding to the $x$-axis, and also position the legend within the plotting region.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_cie_bars0} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=cie.dt,}
                        \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= cie.irrad} \hlopt{*} \hlnum{1e3}\hlstd{,}
                            \hlkwc{x} \hlstd{= filter,}
                            \hlkwc{fill} \hlstd{= w.band))} \hlopt{+}
  \hlkwd{scale_fill_brewer}\hlstd{(}\hlkwc{palette}\hlstd{=}\hlstr{"PRGn"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Filter type"}\hlstd{,}
       \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Effective}\hlopt{~~}\hlstd{irradiance}\hlopt{~~~}\hlstd{(mW}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\})),}
       \hlkwc{title} \hlstd{=} \hlstr{"CIE 1998 erythemal BSWF"}\hlstd{,}
       \hlkwc{fill} \hlstd{=} \hlstr{""}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{(}\hlnum{13}\hlstd{)} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{legend.position}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.85}\hlstd{,} \hlnum{0.85}\hlstd{))} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{panel.grid.minor.x}\hlstd{=}\hlkwd{element_blank}\hlstd{(),}
        \hlkwc{panel.grid.major.x}\hlstd{=}\hlkwd{element_blank}\hlstd{())}

\hlstd{fig_cie_bars0}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-bar-cie-2-1} 

}



\end{knitrout}

The figure above is good for showing the relative contribution of UVB and UVA radiation to the total effect, and the size of the total effect. On the other hand if we would like to show how much the effective irradiance in the UVB and UVA decreases under each of the filters is better to avoid stacking of the bars, plotting them side by side using \code{position=position\_dodge()}. In addition we swap the aesthetics to which the two factors are linked.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_cie_bars1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=cie.dt,}
                        \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= cie.irrad} \hlopt{*} \hlnum{1e3}\hlstd{,}
                            \hlkwc{x} \hlstd{= w.band,}
                            \hlkwc{fill}\hlstd{=filter))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{,}
           \hlkwc{position}\hlstd{=}\hlkwd{position_dodge}\hlstd{(),}
           \hlkwc{color}\hlstd{=}\hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_brewer}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Wavelength band"}\hlstd{,}
       \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Effective}\hlopt{~~}\hlstd{irradiance}\hlopt{~~~}\hlstd{(mW}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\})),}
       \hlkwc{title} \hlstd{=} \hlstr{"CIE 1998 erythemal BSWF"}\hlstd{,}
       \hlkwc{fill} \hlstd{=} \hlstr{""}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{legend.position}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.80}\hlstd{,} \hlnum{0.85}\hlstd{))} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{panel.grid.minor.x}\hlstd{=}\hlkwd{element_blank}\hlstd{(),}
        \hlkwc{panel.grid.major.x}\hlstd{=}\hlkwd{element_blank}\hlstd{())}

\hlstd{fig_cie_bars1}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-bar-cie-3-1} 

}



\end{knitrout}

\section{Task: plotting a spectrum using colour bars}



We show now the last example, related to the ones above, but creating a bar plot with more bars. First we calculate photon irradiance for different equally spaced bands within PAR using function \code{split\_bands}. The code is written so that by changing the first two lines you can adjust the output.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wl.range} \hlkwb{<-} \hlkwd{range}\hlstd{(}\hlkwd{PAR}\hlstd{())}
\hlstd{num.bands} \hlkwb{<-} \hlnum{15}
\hlstd{many.bands} \hlkwb{<-} \hlkwd{split_bands}\hlstd{(wl.range,} \hlkwc{length.out}\hlstd{=num.bands)}
\hlstd{w.length} \hlkwb{<-} \hlkwd{numeric}\hlstd{(num.bands)}
\hlstd{wb.name} \hlkwb{<-} \hlstd{wb.color} \hlkwb{<-} \hlkwd{character}\hlstd{(num.bands)}

\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{num.bands) \{}
  \hlstd{w.length[i]} \hlkwb{<-} \hlkwd{midpoint}\hlstd{(many.bands[[i]])}
  \hlstd{wb.color[i]} \hlkwb{<-} \hlkwd{color}\hlstd{(many.bands[[i]],} \hlkwc{type}\hlstd{=}\hlstr{"CMF"}\hlstd{)}
  \hlstd{wb.name[i]} \hlkwb{<-} \hlkwd{labels}\hlstd{(many.bands[[i]])[[}\hlstr{"name"}\hlstd{]]}
\hlstd{\}}

\hlstd{q.irrad.bands.sun} \hlkwb{<-} \hlkwd{q_irrad}\hlstd{(sun.spct, many.bands)}
\hlstd{q.irrad.sun.dt} \hlkwb{<-} \hlkwd{data.table}\hlstd{(}\hlkwc{q.irrad} \hlstd{= q.irrad.bands.sun,}
                                   \hlkwc{w.length} \hlstd{= w.length,}
                                   \hlkwc{wb.color} \hlstd{= wb.color,}
                                   \hlkwc{wb.name} \hlstd{= wb.name)}
\end{alltt}
\end{kframe}
\end{knitrout}

Now we can plot the data as bars, filling each bar with the corresponding colour. In this case we plot the bars using a continuous variable, wavelength, for the $x$-axis.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig_qirrad_bar} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=q.irrad.sun.dt,}
                        \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= q.irrad} \hlopt{*} \hlnum{1e6}\hlstd{,}
                            \hlkwc{x} \hlstd{= w.length,}
                            \hlkwc{fill}\hlstd{=}\hlkwd{as.character}\hlstd{(wb.color)))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{,}
           \hlkwc{color}\hlstd{=}\hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_identity}\hlstd{(}\hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{= xlab_nm,}
       \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Photon}\hlopt{~~}\hlstd{irradiance}\hlopt{~~}\hlstd{(mu}\hlopt{*}\hlstd{mol}\hlopt{~}\hlstd{m}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{2}\hlstd{\}}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
       \hlkwc{fill} \hlstd{=} \hlstr{""}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}

\hlstd{fig_qirrad_bar}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-bar-qirrad-bands-1-1} 

}



\end{knitrout}

In the case of the example spectrum with equal wavelength steps, one could have directly summed the values, however, the approach shown here is valid for any type of spacing of the values along the wavelength axis, including variable one, like is the case for array spectrometers.
%%%%
\section{Task: plotting colours in Maxwell's triangle}\label{sec:max:tri}

\subsection{Human vision: RGB}
Given a color definition, we can convert it to RGB values by means of R's function \code{col2rgb}. We can obtain a color definition for monochromatic light from its wavelength with function \code{w\_length2rgb} (see section \ref{}), from a waveband with function \code{color} (see section \ref{}), for a wavelength range with \code{w\_length\_range2rgb} (see section \ref{}), and from a spectrum with function \code{s\_e\_irrad2rgb}  (see section \ref{}). The RGB values can be used to locate the position of any colour on Maxwell's triangle, given a set of chromaticity coordinates defining the triangle. In the first example we use some of R's predefined colors. We use the function \code{ggtern} from the package of the same name. It is based on \code{ggplot} and to produce a ternary diagram we need to use \code{ggtern} instead of \code{ggplot}. Geoms, aesthetics, stats and faceting function normally in most cases. Of course, being a ternary plot, the aesthetics \code{x}, \code{y}, and \code{z} should be all assigned to variables in the data.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{colours} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"green"}\hlstd{,} \hlstr{"yellow"}\hlstd{,} \hlstr{"white"}\hlstd{,}
             \hlstr{"orange"}\hlstd{,} \hlstr{"purple"}\hlstd{,} \hlstr{"seagreen"}\hlstd{,} \hlstr{"pink"}\hlstd{)}
\hlstd{rgb.values} \hlkwb{<-} \hlkwd{col2rgb}\hlstd{(colours)}
\hlstd{test.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{colour}\hlstd{=colours,}
                        \hlkwc{R}\hlstd{=rgb.values[}\hlnum{1}\hlstd{, ],}
                        \hlkwc{G}\hlstd{=rgb.values[}\hlnum{2}\hlstd{, ],}
                        \hlkwc{B}\hlstd{=rgb.values[}\hlnum{3}\hlstd{, ])}
\hlstd{maxwell.tern} \hlkwb{<-} \hlkwd{ggtern}\hlstd{(}\hlkwc{data}\hlstd{=test.data,}
                       \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=R,} \hlkwc{y}\hlstd{=G,} \hlkwc{z}\hlstd{=B,} \hlkwc{label}\hlstd{=colour,} \hlkwc{fill}\hlstd{=colour))} \hlopt{+}
                       \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{23}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.2}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"R"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlstr{"G"}\hlstd{,} \hlkwc{z}\hlstd{=}\hlstr{"B"}\hlstd{)} \hlopt{+} \hlkwd{scale_fill_identity}\hlstd{()}
\hlstd{maxwell.tern}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-tern-1-1} 

}



\end{knitrout}

\section{Honey-bee vision: GBU}

In this case we start with the spectral responsiveness of the photoreceptors present in the eyes of honey bees. Bees, as humans have three photoreceptors, but instead of red, green and blue (RGB), bees see green, blue and UV-A (GBU). To plot colours seen by bees one can still use a ternary plot, but the axes represent different photoreceptors than for humans, and the colour space is shifted towards shorter wavelengths.

The calculations we will demonstrate here, in addition are geared to compare a background to a foreground object (foliage vs.\ flower). We have followed xxxxx \cite{chitka?} in this example, but be aware that calculations presented in this reference do not match the equations presented. In the original published example, the calculations have been simplified by leaving out $\delta \lambda$. Although not affecting the final result for their example, intermediate results are different (wrong?). We have further generalized the calculations and equations to make the calculations also valid for spectra measured using $\delta \lambda$ that itself varies along the wavelength axis. This is the usual situation with array spectrometers, nowadays frequently used when measuring reflectance.

The assessment of the perceived `colour difference' between background and foreground objects requires taking into consideration several spectra: the incident `light' spectrum, the reflectance spectra of the two objects, and the sensitivity spectra of three photoreceptors in the case of trichromic vision. In addition to these data, we need to take into consideration the shape of the dose response of the photoreceptors.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologygg))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggtern))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{gridExtra))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyFilters))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiologyWavebands))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{photobiology))}
\end{alltt}
\end{kframe}
\end{knitrout}



\part{Catalogue of data sources}




\chapter{Radiation sources}\label{chap:sources}

\begin{abstract}
  In this chapter we explain how to use the spectral data for light sources.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologySun)}
\hlkwd{library}\hlstd{(photobiologyLamps)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggtern)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:sources:intro}

%%%%
\section{Task: using the data}\label{sec:}

%%%%
\section{Task: extraterrestrial solar radiation spectra}\label{sec:}

%%%%
\section{Task: terrestrial  solar radiation spectra}\label{sec:}

%%%%
\section{Task: incandescent lamps}\label{sec:}

%%%%
\section{Task: discharge lamps}\label{sec:}

%%%%
\section{Task: LEDs}\label{sec:}




\chapter{Filters}\label{chap:filters}

\begin{abstract}
  In this chapter we explain how to use spectral data for filters and how to convolute it spectral data for light sources.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(photobiology)}
\hlkwd{library}\hlstd{(photobiologyFilters)}
\hlkwd{library}\hlstd{(photobiologySun)}
\hlkwd{library}\hlstd{(photobiologyLamps)}
\hlkwd{library}\hlstd{(photobiologyLEDs)}
\hlkwd{library}\hlstd{(photobiologyWavebands)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggtern)}
\hlkwd{library}\hlstd{(photobiologygg)}
\end{alltt}
\end{kframe}
\end{knitrout}

%%%%
\section{Introduction}\label{sec:filters:intro}

%%%%
\section{Task: using the data}\label{sec:filters:using}

%%%%
\section{Task: spectral transmittance for optical glass filters}\label{sec:filters:glass}

%%%%
\section{Task: spectral transmittance for plastic films}\label{sec:filters:films}

%%%%
\section{Task: spectral transmittance for plastic sheets}\label{sec:filters:sheets}




\chapter{Photoreceptors}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}



\part{Data acquisition and modelling}




\chapter{Calibration}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}




\chapter{Simulation}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}




\chapter{Measurement}

\begin{abstract}
  In this chapter we explain how to .
\end{abstract}

%%%%
\section{Task: }\label{sec:}





\printbibliography

\appendix

\part{Appendixes}




\chapter{R as a powerful calculator}\label{chap:R:as:calc}

\section{Working in the R console}

I assume that you are already familiar with RStudio. These examples use only the console window, and results a printed to the console. The values stored in the different variables are also visible in the Environment tab in RStudio.

In the console can type commands at the \texttt{>} prompt.
When you end a line by pressing the return key, if the line can be interpreted as an R command, the result will be printed in the console, followed by a new \texttt{>} prompt.
If the command is incomplete a \texttt{+} continuation prompt will be shown, and you will be able to type-in the rest of the command. For example if the whole calculation that you would like to do is $1 + 2 + 4$, if you enter in the console \texttt{1 + 2 +} in one line, you will get a continuation prompt where you will be able to type \texttt{3}. However, if you type \texttt{1 + 2}, the result will be calculated, and printed.

When working at the command prompt, results are printed by default, but other cases you may need to use the function \texttt{print} explicitly. The examples here rely on the automatic printing.

The idea with these examples is that you learn by working out how different commands work based on the results of the example calculations listed. The examples are designed so that they allow the rules, and also a few quirks, to be found by `detective work'. This should hopefully lead to better understanding than just studying rules.

\section{Examples with numbers}

When working with arithmetic expression the normal precedence rules are followed and parentheses can be used to alter this order. In addition parentheses can be nested.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{2} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlnum{2} \hlopt{+} \hlnum{10} \hlopt{/} \hlnum{5}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlstd{(}\hlnum{2} \hlopt{+} \hlnum{10}\hlstd{)} \hlopt{/} \hlnum{5}
\end{alltt}
\begin{verbatim}
## [1] 2.4
\end{verbatim}
\begin{alltt}
\hlnum{10}\hlopt{^}\hlnum{2} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 101
\end{verbatim}
\begin{alltt}
\hlkwd{sqrt}\hlstd{(}\hlnum{9}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlstd{pi} \hlcom{# whole precision not shown when printing}
\end{alltt}
\begin{verbatim}
## [1] 3.141593
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(pi,} \hlkwc{digits}\hlstd{=}\hlnum{22}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3.141592653589793115998
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)} \hlcom{# oops! Read on for explanation.}
\end{alltt}
\begin{verbatim}
## [1] 1.224606e-16
\end{verbatim}
\begin{alltt}
\hlkwd{log}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 4.60517
\end{verbatim}
\begin{alltt}
\hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{log2}\hlstd{(}\hlnum{8}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{exp}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2.718282
\end{verbatim}
\end{kframe}
\end{knitrout}

One can use variables to store values. Variable names and all other names in R are case sensitive. Variables \texttt{a} and \texttt{A} are two different variables. Variable names can be quite long, but usually it is not a good idea to use very long names. Here I am using very short names, that is usually a very bad idea. However, in cases like these examples where the stored values have no real connection to the real world and are used just once or twice, these names emphasize the abstract nature.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlstd{a} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{10}
\hlstd{b} \hlkwb{<-} \hlstd{a} \hlopt{+} \hlstd{b}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\begin{alltt}
\hlnum{3e-2} \hlopt{*} \hlnum{2.0}
\end{alltt}
\begin{verbatim}
## [1] 0.06
\end{verbatim}
\end{kframe}
\end{knitrout}

There are some syntactically legal statements that are not very frequently used, but you should be aware that they are valid, as they will not trigger error messages, and may surprise you. The important thing is that you write commands consistently. \texttt{1 -> a} is valid but almost never used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstd{b} \hlkwb{<-} \hlstd{c} \hlkwb{<-} \hlnum{0.0}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlkwb{->} \hlstd{a}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{=} \hlnum{3}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

Numeric variables can contain more than one value. Even single numbers are vectors of length one. We will later see why this is important. As you have seen above the results of calculations were printed preceded with \texttt{[1]}. This is the index or position in the vector of the first number (or other value) displayed at the head of the line.

One can use \texttt{c} `concatenate' to create a vector of numbers from individual numbers.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{,}\hlnum{2}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,}\hlnum{5}\hlstd{,}\hlnum{0}\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0
\end{verbatim}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b)}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2 4 5 0
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{c}\hlstd{(b, a)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

One can also create sequences, or repeat values:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlopt{-}\hlnum{1}\hlopt{:}\hlnum{5}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] -1  0  1  2  3  4  5
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{5}\hlopt{:-}\hlnum{1}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  5  4  3  2  1  0 -1
\end{verbatim}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{to} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{by} \hlstd{=} \hlnum{0.1}\hlstd{)}
\hlstd{c}
\end{alltt}
\begin{verbatim}
##  [1] -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 -0.4 -0.3 -0.2
## [10] -0.1  0.0  0.1  0.2  0.3  0.4  0.5  0.6  0.7
## [19]  0.8  0.9  1.0
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{-}\hlnum{5}\hlstd{,} \hlnum{4}\hlstd{)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] -5 -5 -5 -5
\end{verbatim}
\end{kframe}
\end{knitrout}

Now something that makes R different from most other programming languages: vectorized arithmetic.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1} \hlcom{# we add one to vector a defined above}
\end{alltt}
\begin{verbatim}
## [1] 0 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{(a} \hlopt{+} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1]  0  2  4  6  8 10 12
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 4 4 4 4 4 4 4
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{-} \hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 0 0 0 0 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

It can be seen in first line above, another peculiarity of R, that frequently called recycling: as vector \texttt{a} is of length 6, but the constant 1 is a vector of length 1, this 1 is extended by recycling into a vector of the same length as the longest vector in the statement.

Make sure you understand what calculations are taking place in the chunk above, and also the one below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1 1 1 1 1 1
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 2 3 2 3 2 3
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{3}
\end{alltt}
\begin{verbatim}
## [1] 2 3 4 2 3 4
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{4}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in a + 1:4: longer object length is not a multiple of shorter object length}}\begin{verbatim}
## [1] 2 3 4 5 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}


A couple on useful things to know: a vector can have length zero. One can remove variables from the workspace with \texttt{rm}. One can use \texttt{ls()} to list all objects in the environment, or by supplying a \code{pattern} argument, only the objects with names matching the \code{pattern}. The pattern is given as a regular expression, with \verb|[]| enclosing alternative matching characters, \verb|^| and \verb|$| indicating the extremes of the name. For example \verb|"^z$"| matches only the single character `z' while \verb|"^z"| matches any name starting with `z'. In contrast \verb|"^[zy]$"| matches both `z' and `y' but neither `zy' nor `yz', and \verb|"^[a-z]"| matches any name starting with a lower case ASCII letter. If you are using RStudio, all objects are listed in the Environment pane, and the search box of the panel can be used to find a given object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)}
\hlstd{z}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\begin{alltt}
\hlkwd{ls}\hlstd{(}\hlkwc{pattern}\hlstd{=}\hlstr{"^z$"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "z"
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(z)}
\hlkwd{try}\hlstd{(z)}
\hlkwd{ls}\hlstd{(}\hlkwc{pattern}\hlstd{=}\hlstr{"^z$"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

There are some special values available for numbers. \texttt{NA} meaning `not available' is used for missing values. Calculations can yield also the following values \texttt{NaN} `not a number', \texttt{Inf} and \texttt{-Inf} for $\infty$ and $-\infty$. As you will see below, calculations yielding these values do \textbf{not} trigger errors or warnings, as they are arithmetically valid.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{NA}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlopt{-}\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] -Inf
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{/} \hlnum{Inf}
\end{alltt}
\begin{verbatim}
## [1] NaN
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{+} \hlnum{4}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\end{kframe}
\end{knitrout}

One thing to be aware of, and which we will discuss again later, is that numbers in computers are almost always stored with finite precision. This means that they not always behave as Real numbers as defined in mathematics. In R the usual numbers are stored as \texttt{double-precision floats}, which means that there are limits to the largest and smallest numbers that can be represented (approx. $-1 \cdot 10^{308}$ and $1 \cdot 10^{308})$, and the number of significant digits that can be stored (usually described as $\epsilon$ (epsilon, abbreviated \texttt{eps}, defined as the largest number for which $ 1 + \epsilon = 1$)). This can be sometimes important, and can generate unexpected results in some cases, especially when testing for equality. In the example below, the result of the subtraction is still exactly 1. \label{par:float}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

It is usually safer not to test for equality to zero when working with numeric values. One alternative is comparing against a suitably small number, which will depend on the situation, although \code{eps} is usualy a safe bet, unless the expected range of values is known to be small.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{abs}\hlstd{(x)} \hlopt{<} \hlstd{eps}
\hlkwd{abs}\hlstd{(x)} \hlopt{<} \hlnum{1e-100}
\end{alltt}
\end{kframe}
\end{knitrout}

The same applies to tests for equality, so whenever possible according to the logic of the calculations, it is best to test for inequalities, for example using \verb|x <= 1.0| instead of \verb|x == 1.0|. If this is not possible, then the tests should be treated as above, for example replacing \verb|x == 1.0| with \verb|abs(x - 1.0) < eps|.

When comparing integer values these problems do not exist, as integer arithmetic is not afected by loss of precision in  calculations restricted to integers (the \code{L} comes from `long' a name sometimes used for a machine represenation of intergers):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1L} \hlopt{+} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{*} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{%/%} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{/} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0.3333333
\end{verbatim}
\end{kframe}
\end{knitrout}

The last example above, using the `usual' division operator yields a floating-point \code{numeric} result, while the integer division operator \verb|%/%| yields an integer result.

\section{Examples with logical values}

What in maths are usually called Boolean values, are called \texttt{logical} values in R. They can have only two values \texttt{TRUE} and \texttt{FALSE}, in addition to \texttt{NA}. They are vectors. There are also logical operators that allow boolean algebra (and some support for set operations that we will not describe here).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{TRUE}
\hlstd{b} \hlkwb{<-} \hlnum{FALSE}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlopt{!}\hlstd{a} \hlcom{# negation}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&&} \hlstd{b} \hlcom{# logical AND}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{||} \hlstd{b} \hlcom{# logical OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Again vectorization is possible. I present this here, and will come back again to this, because this is one of the most troublesome aspects of the R language. The two types of `equivalent' logical operators behave very differently, but use very similar syntax! The vectorized operators have single-character names \verb|&| and \verb:|:, while the non vectorized ones have two double-character names \verb|&&| and \verb:||:. There is only one version of the negation operator \verb|!| that is vectorized.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{FALSE}\hlstd{)}
\hlstd{b} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlcom{# vectorized AND}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{|} \hlstd{b} \hlcom{# vectorized OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&&} \hlstd{b} \hlcom{# not vectorized}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{||} \hlstd{b} \hlcom{# not vectorized}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions \code{any} and \code{all} take a logical vector as argument, and return a single logical value `summarizing' the logical values in the vector. \code{all} returns \code{TRUE} only if every value in the argument is \code{TRUE}, and \code{any} returns \code{TRUE} unless every value in the argument is \code{FALSE}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{any}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(a} \hlopt{&} \hlstd{b)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a} \hlopt{&} \hlstd{b)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Another important thing to know about logical operators is that they `short-cut' evaluation. If the result is known from the first part of the statement, the rest of the statement is not evaluated. Try to understand what happens when you enter the following commands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{TRUE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

When using the vectorized operators on vectors of length greater than one, `short-cut' evaluation still applies for the result obtained.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlopt{&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{&} \hlstd{b} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{|} \hlstd{b} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Comparison operators}

Comparison operators yield as a result logical values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1.2} \hlopt{>} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{>=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{==} \hlnum{1.0} \hlcom{# be aware that here we use two = symbols}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{!=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{20}
\hlstd{a} \hlopt{<} \hlnum{100} \hlopt{&&} \hlstd{a} \hlopt{>} \hlnum{10}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Again these operators can be used on vectors of any length, the result is a logical vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{a} \hlopt{>} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{<} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{==} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlstd{a} \hlopt{>} \hlnum{5}
\hlstd{b}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Be once more aware of `short-cut evaluation'. If the result would not be affected by the missing value then the result is returned. If the presence of the NA makes the end result unknown, then NA is returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlstd{c} \hlopt{>} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE    NA
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{is.na}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.na}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(}\hlkwd{is.na}\hlstd{(c))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(}\hlkwd{is.na}\hlstd{(c))}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

This behaviour can be changed by using the optional argument \texttt{na.rm} which removes NA values \textbf{before} the function is applied. (Many functions in R have this optional parameter.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(c} \hlopt{<} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(c} \hlopt{>} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

You may skip this on first read, see page \pageref{par:float}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1e20} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{0} \hlopt{==} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

In many situations, when writing programs one should avoid testing for equality of floating point numbers (`floats'). Here we show how to handle gracefully rounding errors.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlopt{==} \hlnum{0.0} \hlcom{# may not always work}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(a)} \hlopt{<} \hlnum{1e-15} \hlcom{# is safer}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [8] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)} \hlopt{==} \hlnum{0.0} \hlcom{# angle in radians, not degrees!}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)} \hlopt{==} \hlnum{0.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)}
\end{alltt}
\begin{verbatim}
## [1] 1.224606e-16
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)}
\end{alltt}
\begin{verbatim}
## [1] -2.449213e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.eps} \hlcom{# see help for .Machine for explanation}
\end{alltt}
\begin{verbatim}
## [1] 2.220446e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.neg.eps}
\end{alltt}
\begin{verbatim}
## [1] 1.110223e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Character values}

Character variables can be used to store any character. Character constants are written by enclosing characters in quotes. There are three types of quotes in the ASCII character set, double quotes \texttt{"}, single quotes \texttt{'}, and back ticks \texttt{`}. The first two types of quotes can be used for delimiting characters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstr{"A"}
\hlstd{b} \hlkwb{<-} \hlstd{letters[}\hlnum{2}\hlstd{]}
\hlstd{c} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlstd{]}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] "b"
\end{verbatim}
\begin{alltt}
\hlstd{c}
\end{alltt}
\begin{verbatim}
## [1] "a"
\end{verbatim}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b, c)}
\hlstd{d}
\end{alltt}
\begin{verbatim}
## [1] "A" "b" "a"
\end{verbatim}
\begin{alltt}
\hlstd{e} \hlkwb{<-} \hlkwd{c}\hlstd{(a, b,} \hlstr{"c"}\hlstd{)}
\hlstd{e}
\end{alltt}
\begin{verbatim}
## [1] "A" "b" "c"
\end{verbatim}
\begin{alltt}
\hlstd{h} \hlkwb{<-} \hlstr{"1"}
\hlkwd{try}\hlstd{(h} \hlopt{+} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Vectors of characters are not the same as character strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{f} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"1"}\hlstd{,} \hlstr{"2"}\hlstd{,} \hlstr{"3"}\hlstd{)}
\hlstd{g} \hlkwb{<-} \hlstr{"123"}
\hlstd{f} \hlopt{==} \hlstd{g}
\end{alltt}
\begin{verbatim}
## [1] FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{f}
\end{alltt}
\begin{verbatim}
## [1] "1" "2" "3"
\end{verbatim}
\begin{alltt}
\hlstd{g}
\end{alltt}
\begin{verbatim}
## [1] "123"
\end{verbatim}
\end{kframe}
\end{knitrout}

One can use the `other' type of quotes as delimiter when one want to include quotes in a string. Pretty-printing is changing what I typed into how the string is stored in R: I typed \texttt{b <- 'He said "hello" when he came in'}, try it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstr{"He said 'hello' when he came in"}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] "He said 'hello' when he came in"
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlstr{'He said "hello" when he came in'}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] "He said \"hello\" when he came in"
\end{verbatim}
\end{kframe}
\end{knitrout}

The outer quotes are not part of the string, they are `delimiters' used to mark the boundaries. As you can see when \texttt{b} is printed special characters can be represented using `escape sequences'. There are several of them, and here we will show just a few.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{c} \hlkwb{<-} \hlstr{"abc\textbackslash{}ndef\textbackslash{}txyz"}
\hlkwd{print}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
## [1] "abc\ndef\txyz"
\end{verbatim}
\begin{alltt}
\hlkwd{cat}\hlstd{(c)}
\end{alltt}
\begin{verbatim}
## abc
## def	xyz
\end{verbatim}
\end{kframe}
\end{knitrout}

Above, you will not see any effect of these escapes when using \code{print}: \verb|\n| represents `new line' and \verb|\t| means `tab' (tabulator). The \textit{scape codes} work only in some contexts, as when using \code{cat} to generate the output. They also are very useful when one wants to split an axis-label, title or label in a plot into two or more lines.

\section{Finding the `mode' of objects}

Variables have \emph{mode} that determines what can be stored in them. But differently to other languages, assignment of a variable of a different mode is allowed. However, there is a restriction that all elements in a vector, array or matrix, must be of the same mode, while this is not required for lists. Functions with names starting with \code{is.} are tests returning \code{TRUE}, \code{FALSE} or \code{NA}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_var} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{5}
\hlkwd{mode}\hlstd{(my_var)}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(my_var)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.logical}\hlstd{(my_var)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.character}\hlstd{(my_var)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{my_var} \hlkwb{<-} \hlstr{"abc"}
\hlkwd{mode}\hlstd{(my_var)}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Type conversions}

The least intuitive ones are those related to logical values. All others are as one would expect. By convention, functions used to convert objects from one mode to a different one have names starting with \code{as.}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "1"
\end{verbatim}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{3.0e10}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "3e+10"
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"1"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"5E+5"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 5e+05
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"A"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: NAs introduced by coercion}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{+} \hlnum{TRUE}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{+} \hlnum{FALSE}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"T"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"t"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"TRUE"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"true"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{f} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"1"}\hlstd{,} \hlstr{"2"}\hlstd{,} \hlstr{"3"}\hlstd{)}
\hlstd{g} \hlkwb{<-} \hlstr{"123"}
\hlkwd{as.numeric}\hlstd{(f)}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(g)}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

Some tricks useful when dealing with results. Be aware that the printing is being done by default, these functions return numerical values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.01246
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.0125
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1789.123
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1790
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{0.12345}
\hlstd{b} \hlkwb{<-} \hlkwd{round}\hlstd{(a,} \hlnum{2}\hlstd{)}
\hlstd{a} \hlopt{==} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{-} \hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.00345
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.12
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Vectors}

You already know how to create a vector. Now we are going to see how to get individual numbers out of a vector. They are accessed using an index. The index indicates the position in the vector, starting from one, following the usual mathematical tradition. What in maths would be $x_i$ for a vector $x$, in R is represented as \texttt{x[i]}. (In R indexes (or subscripts) always start from one, while in some other programming languages indexes start from zero.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{a}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "b"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "c" "b"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "j" "i" "h" "g" "f" "e" "d" "c" "b" "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

The examples below demonstrate what is the result of using a longer vector of indexes than the indexed vector. The length of the indexing vector has no restriction, but the acceptable range of values for the indexes is given by the length of the indexed vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "c" "c" "c" "c"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##  [1] "j" "i" "h" "g" "f" "e" "d" "c" "b" "a" "a"
## [12] "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

Negative indexes have a special meaning, they indicate the positions at which values should be excluded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlopt{-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlopt{-}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

Results from indexing with out-of-range values may be surprising.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlnum{11}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{1}\hlopt{:}\hlnum{11}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Results from indexing with special values may be surprising.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[ ]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{NA}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] NA NA NA NA NA NA NA NA NA NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{NA}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" NA
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwa{NULL}\hlstd{]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlkwa{NULL}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

Another way of indexing, which is very handy, but not available in most other programming languages, is indexing with a vector of logical values. In practice, the vector of logical values used for `indexing' is in most cases of the same length as the vector from which elements are going to be selected. However, this is not a requirement, and if the logical vector is shorter it is `recycled' as discussed above in relation to operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a[}\hlnum{TRUE}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlnum{FALSE}\hlstd{]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "e" "g" "i"
\end{verbatim}
\begin{alltt}
\hlstd{a[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "b" "d" "f" "h" "j"
\end{verbatim}
\begin{alltt}
\hlstd{a} \hlopt{>} \hlstr{"c"}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
##  [8]  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{a[a} \hlopt{>} \hlstr{"c"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{selector} \hlkwb{<-} \hlstd{a} \hlopt{>} \hlstr{"c"}
\hlstd{a[selector]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlkwd{which}\hlstd{(a} \hlopt{>} \hlstr{"c"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{indexes} \hlkwb{<-} \hlkwd{which}\hlstd{(a} \hlopt{>} \hlstr{"c"}\hlstd{)}
\hlstd{a[indexes]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{b[selector]}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{b[indexes]}
\end{alltt}
\begin{verbatim}
## [1]  4  5  6  7  8  9 10
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Factors}

Factors are used for indicating categories, most frequently the factors describing the treatments in an experiment, or categories in a survey. They can be created either from numerical or character vectors. The different possible values are called \emph{levels}. Normal factors created with \code{factor} are unordered or categorical. R has ordered factors, that can be created with function \code{ordered}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.vector} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"treated"}\hlstd{)}
\hlstd{my.factor} \hlkwb{<-} \hlkwd{factor}\hlstd{(my.vector)}
\hlstd{my.factor} \hlkwb{<-} \hlkwd{factor}\hlstd{(my.vector,} \hlkwc{levels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"treatment"}\hlstd{,} \hlstr{"control"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

It is always preferable to use meaningful names for levels, although it is possible to use numbers. The order of levels becomes important when plotting data, as it affects the order of the levels along the axes, or in legends. Converting factors to numbers, even if the levels look like numbers when displayed, they are just character strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.vector2} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{3}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{4}\hlstd{)}
\hlstd{my.factor2} \hlkwb{<-} \hlkwd{factor}\hlstd{(my.vector2)}
\hlkwd{as.numeric}\hlstd{(my.factor2)}
\end{alltt}
\begin{verbatim}
##  [1] 1 2 3 1 2 3 1 2 3 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlkwd{as.character}\hlstd{(my.factor2))}
\end{alltt}
\begin{verbatim}
##  [1] 3 4 5 3 4 5 3 4 5 3 4 5
\end{verbatim}
\end{kframe}
\end{knitrout}

Internally factor levels are stored as running numbers starting from zero, and those are the numbers returned by \code{as.numeric} applied to a factor.

Factors are very important in R. In contrast to other statistical software in which the role of a variable is set when defining a model to be fitted or setting up a test, in R models are specified exactly in the same way for ANOVA and regression analysis, as linear models. What `decides' what type of model is fitted is whether the explanatory variable is a factor (giving ANOVA) or a numerical variable (giving regression). This makes a lot of sense, as in most cases, considering an explanatory variable as categorical or not, depends on the design of the experiment or survey, in other words, is a property of the data rather than of the analysis.

\section{Lists}

Elements of a \code{list} are not ordered, and can be of different type. Lists can be also nested. Elements in list are named, and normally are accessed by name. List are defined using function \code{list}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.list} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"a"}\hlstd{,} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\hlstd{a.list}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3 4 5 6
## 
## $y
## [1] "a"
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(a.list)}
\end{alltt}
\begin{verbatim}
## List of 3
##  $ x: int [1:6] 1 2 3 4 5 6
##  $ y: chr "a"
##  $ z: logi [1:2] TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a.list}\hlopt{$}\hlstd{x}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.list[[}\hlstr{"x"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.list[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.list[}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.list[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3 4 5 6
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{try}\hlstd{(a.list[[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)]])}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

Using double square brackets for indexing gives the element stored in the list, in its original mode, in the example above, \code{a.list[["x"]]} returns a numeric vector, while \code{a.list[1]} returns a list containing the numeric vector \code{x}. \code{a.list\$x} returns the same value as \code{a.list[["x"]]}, a numeric vector. While \code{a.list[c(1,3)]} returns a list of length two, \code{a.list[[c(1,3)]]}.

\section{Data frames}

Data frames are a special type of list, in which each element is a vector or a factor of the same length. The are crested with function \code{data.frame} with a syntax similar to that used for lists. When a shorter vector is supplied as argument, it is recycled, until the full length of the variable is filled. This is very different to what we obtained in the previous section when we created a list.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"a"}\hlstd{,} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\hlstd{a.df}
\end{alltt}
\begin{verbatim}
##   x y     z
## 1 1 a  TRUE
## 2 2 a FALSE
## 3 3 a  TRUE
## 4 4 a FALSE
## 5 5 a  TRUE
## 6 6 a FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(a.df)}
\end{alltt}
\begin{verbatim}
## 'data.frame':	6 obs. of  3 variables:
##  $ x: int  1 2 3 4 5 6
##  $ y: Factor w/ 1 level "a": 1 1 1 1 1 1
##  $ z: logi  TRUE FALSE TRUE FALSE TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{a.df}\hlopt{$}\hlstd{x}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.df[[}\hlstr{"x"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.df[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(a.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

R is an object oriented language, and objects belong to classes. With function \code{class} we can query the class of an object. As we saw in the two previous chunks lists and data frames objects belong to two different classes.

We can add also to lists and data frames.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.df}\hlopt{$}\hlstd{x2} \hlkwb{<-} \hlnum{6}\hlopt{:}\hlnum{1}
\hlstd{a.df}\hlopt{$}\hlstd{x3} \hlkwb{<-} \hlstr{"b"}
\hlstd{a.df}
\end{alltt}
\begin{verbatim}
##   x y     z x2 x3
## 1 1 a  TRUE  6  b
## 2 2 a FALSE  5  b
## 3 3 a  TRUE  4  b
## 4 4 a FALSE  3  b
## 5 5 a  TRUE  2  b
## 6 6 a FALSE  1  b
\end{verbatim}
\end{kframe}
\end{knitrout}

We have added two columns to the data frame, and in the case of column \code{x3} recycling took place. Data frames are extremely important to anyone analysing or plotting data in R. One can think of data frames as tightly structured work-sheets, or as lists. As you may have guessed from the examples earlier in this section, there several different ways of accessing columns, rows, and individual observations stored in a data frame. The columns can to some extent be treated as elements in a list, and can be accessed both by name or index (position). When accessed by name, using \code{\$} or double square brackets a single column is returned as a vector or factor. In contrast to lists, data frames are `rectangular' and for this reason the values stored can be also accessed in a way similar to how elements in a matrix are accessed, using two indexes. As we saw for vectors indexes can be vectors of integer numbers or vectors of logical values. For columns they can be vectors of character strings matching the names of the columns. When using indexes it is extremely important to remember that the indexes are always given \textbf{row first}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.df[ ,} \hlnum{1}\hlstd{]}   \hlcom{# first column}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.df[ ,} \hlstr{"x"}\hlstd{]} \hlcom{# first column}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlstd{a.df[}\hlnum{1}\hlstd{, ]}    \hlcom{# first row}
\end{alltt}
\begin{verbatim}
##   x y    z x2 x3
## 1 1 a TRUE  6  b
\end{verbatim}
\begin{alltt}
\hlstd{a.df[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
             \hlcom{# first two rows of the third column}
\hlstd{a.df[a.df}\hlopt{$}\hlstd{z , ]} \hlcom{# the rows for which z is true}
\end{alltt}
\begin{verbatim}
##   x y    z x2 x3
## 1 1 a TRUE  6  b
## 3 3 a TRUE  4  b
## 5 5 a TRUE  2  b
\end{verbatim}
\begin{alltt}
\hlstd{a.df[a.df}\hlopt{$}\hlstd{x} \hlopt{>} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{3}\hlstd{]} \hlcom{# the rows for which x > 3 for}
\end{alltt}
\begin{verbatim}
##   x y x2 x3
## 4 4 a  3  b
## 5 5 a  2  b
## 6 6 a  1  b
\end{verbatim}
\begin{alltt}
                 \hlcom{# all columns except the third one }
\end{alltt}
\end{kframe}
\end{knitrout}

When the names of data frames are long, complex conditions become awkward to write. In such cases \code{subset} is handy because evaluation is done in the `environment' of the data frame, i.e.\ the names of the columns are recognized if entered directly.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(a.df, x} \hlopt{>} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   x y     z x2 x3
## 4 4 a FALSE  3  b
## 5 5 a  TRUE  2  b
## 6 6 a FALSE  1  b
\end{verbatim}
\end{kframe}
\end{knitrout}

When calling functions that return a vector, data farme, or other structure, the square brackets can be appended to the rightmost parenthesis of the function call, in the same way as to the name of a variable holding the same data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(a.df, x} \hlopt{>} \hlnum{3}\hlstd{)[ ,} \hlopt{-}\hlnum{3}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   x y x2 x3
## 4 4 a  3  b
## 5 5 a  2  b
## 6 6 a  1  b
\end{verbatim}
\begin{alltt}
\hlkwd{subset}\hlstd{(a.df, x} \hlopt{>} \hlnum{3}\hlstd{)}\hlopt{$}\hlstd{x}
\end{alltt}
\begin{verbatim}
## [1] 4 5 6
\end{verbatim}
\end{kframe}
\end{knitrout}

None of the examples in the last three code chunks alter the original data frame \code{a.df}. We can store the returned value using a new name, if we want to preserve \code{a.df} unchanged, or we can assign the result to \code{a.df} deleting in the process the original \code{a.df}. The next to examples do assignment to \code{a.df}, but either to only one columns, or by indexing the individual values in both the `right side' and `left side' of the assignment.
Another way to delete a column from a data frame is to assign \code{NULL} to it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.df[[}\hlstr{"x2"}\hlstd{]]} \hlkwb{<-} \hlkwa{NULL}
\hlstd{a.df}\hlopt{$}\hlstd{x3} \hlkwb{<-} \hlkwa{NULL}
\hlstd{a.df}
\end{alltt}
\begin{verbatim}
##   x y     z
## 1 1 a  TRUE
## 2 2 a FALSE
## 3 3 a  TRUE
## 4 4 a FALSE
## 5 5 a  TRUE
## 6 6 a FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

In the previous code chuck we deleted the last two columns of the data frame \code{a.df}.
Finally an esoteric trick for you think about.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a.df[}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)]} \hlkwb{<-} \hlstd{a.df[}\hlnum{6}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{)]}
\hlstd{a.df}
\end{alltt}
\begin{verbatim}
##   x y z
## 1 0 a 6
## 2 1 a 5
## 3 0 a 4
## 4 1 a 3
## 5 0 a 2
## 6 1 a 1
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Simple built-in statistical functions}

Being R's main focus in statistics, it provides functions for both simple and complex calculations, going from means and variances to fitting very complex models. we will start with the simple ones.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{20}
\hlkwd{mean}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 10.5
\end{verbatim}
\begin{alltt}
\hlkwd{var}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 35
\end{verbatim}
\begin{alltt}
\hlkwd{median}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 10.5
\end{verbatim}
\begin{alltt}
\hlkwd{mad}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 7.413
\end{verbatim}
\begin{alltt}
\hlkwd{sd}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 5.91608
\end{verbatim}
\begin{alltt}
\hlkwd{range}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1]  1 20
\end{verbatim}
\begin{alltt}
\hlkwd{max}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 20
\end{verbatim}
\begin{alltt}
\hlkwd{min}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 20
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Functions and execution flow control}

Although functions can be defined and used at the command prompt, we will discuss them when looking at scripts. We will do the same in the case of flow-control statements (e.g.\ repetition and conditional execution).





\chapter{R Scripts and Programming}\label{chap:R:scripts}

\section{What is a script?}

We call \textit{script} to a text file that contains the same commands that you would type at the console prompt. A true script is not for example an MS-Word file where you have pasted or typed some R commands. A script file has the following characteristics.
\begin{itemize}
  \item The script is a text file (ASCII or some other encoding e.g. UTF-8 that R uses in your set-up).
  \item The file contains valid R statements (including comments) and nothing else.
  \item Comments start at a \texttt{\#} and end at the end of the line. (True end-of line as coded in file, the editor may wrap it or not at the edge of the screen).
  \item The R statements are in the file in the order that they must be executed.
  \item R scripts have file names ending in \texttt{.r}
\end{itemize}

It is good practice to write scripts so that they will run in a new R session, which means that the script should include library commands to load all the required packages.



\section{How do we use a scrip?}

A script can be sourced.

If we have a text file called \texttt{my.first.script.r}
\begin{verbatim}
# this is my first R script
print(3+4)
\end{verbatim}

And then source this file:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{source}\hlstd{(}\hlstr{"my.first.script.r"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\end{kframe}
\end{knitrout}

The results of executing the statements contained in the file will appear in the console. The commands themselves are not shown (the sourced file is not echoed) and the results will not be printed unless you include an explicit \texttt{print} command. This also applies in many cases also to plots. A fig created with \texttt{ggplot} needs to be printed if we want to see it when the script is run.

From within RStudio, if you have an R script open in the editor, there will a ``source'' drop box ($\neq$ DropBox) visible from where you can choose ``source'' as described above, or ``source with echo'' for the currently open file.

When a script is sourced, the output can be saved to a text file instead of being shown in the console. It is also easy to call R with the script file as argument directly at the command prompt of the operating system.

\begin{verbatim}
RScript my.first.script.r
\end{verbatim}

You can open a `shell' from the Tools menu in RStudio, to run this command. The output will be printed to the shell console. If you would like to save the output to a file, use redirection.

\begin{verbatim}
RScript my.first.script.r > my.output.txt
\end{verbatim}

Sourcing is very useful when the script is ready, however, while developing a script, or sometimes when testing things, one usually wants to run ($=$ execute) one or a few statements at a time. This can be done using the ``run'' button after either locating the cursor in the line to be executed, or selecting the text that one would like to run (the selected text can be part of a line, a whole line, or a group of lines, as long as it is syntactically valid).

\section{How to write a script?}

The approach used, or mix of approaches will depend on your preferences, and on how confident you are that the statements will work as expected.
\begin{description}
\item[If one is very familiar with similar problems] One would just create a new text file and write the whole thing in the editor, and then test it. This is rather unusual.
\item[If one if moderately familiar with the problem] One would write the script as above, but testing it, part by part as one is writing it. This is usually what I do.
\item[If ones mostly playing around] Then if one is using RStudio, one type statements at the console prompt. As you should know by now, everything you run at the console is saved to the ``History''. In RStudio the History is displayed in its own pane, and in this pane one can select any previous statement and by pressing a single having copy and pasted to either the console prompt, or the cursor position in the file visible in the editor. In this way one can build a script by copying and pasting from the history to your script file the bits that have worked as you wanted.
\end{description}

\section{The need to be understandable to people}

When you write a script, it is either because you want to document what you have done or you want re-use it at a later time. In either case, the script itself although still meaningful for the computer could become very obscure to you, and even more to someone seeing it for the first time.

How does one achieve an understandable script or program?
\begin{itemize}
  \item Avoid the unusual. People using a certain programming language tend to use some implicit or explicit rules of style. As a minimum try to be consistent with yourself.
  \item Use meaningful names for variables, and any other object. What is meaningful depends on the context. Depending on common use a single letter may be more meaningful than a long word. However self explaining names are better: e.g. using \texttt{n.rows} and \texttt{n.cols} is much clearer than using \texttt{n1} and \texttt{n2} when dealing with a matrix of data. Probably \texttt{number.of.rows} and \texttt{number.of.columns} would just increase the length of the lines in the script, and one would spend more time typing without getting much in return.
  \item How to make the words visible in names: traditionally in R one would use dots to separate the words and use only lower case. Some years ago, it became possible to use underscores. The use of underscores is quite common nowadays because in some contexts is ``safer'' as in special situations a dot may have a special meaning. What we call ``camel case'' is very rarely used in R programming but is common in other languages like Pascal. An example of camel case is \texttt{NumCols}. In some cases it can become a bit confusing as in \texttt{UVMean} or \texttt{UvMean}.
\end{itemize}

\section{Exercises}

By now you should be familiar enough with R to be able to write your own script.
\begin{enumerate}
  \item Create a new R script (in RStudio, from `File' menu, ``+'' button, or by typing ``Ctrl + Shift + N'').
  \item Save the file as ``my.second.script.r''.
  \item Use the editor pane in RStudio to type some R commands and comments.
  \item \textbf{Run} individual commands.
  \item \textbf{Source} the whole file.
\end{enumerate}

\section{Functions}

When writing scripts, or any program, one should avoid repeating code (groups of statements). The reasons for this are: 1) if the code needs to be changed, you have to make changes in more than one place in the file, or in more than one file. Sooner or later, some copies will remain unchanged by mistake. 2) it makes the script file longer, and this makes debugging, commenting, etc. more tedious, and error prone.

How do we avoid repeating bits of code? We write a function containing the statements that we would need to repeat, and then \texttt{call} the function in their place.

Functions are defined by means of \textbf{function}, and saved like any other object in R by assignment a variable. \texttt{x} is a parameter, the name used within the function for an object that will be supplied as ``argument'' when the function is called. One can think of parameter names as place-holders.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.prod} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{y}\hlstd{)\{x} \hlopt{*} \hlstd{y\}}
\hlkwd{my.prod}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 12
\end{verbatim}
\end{kframe}
\end{knitrout}

First some basic knowledge. In R, arguments are passed by copy. This is something very important to remember. Whatever you do within a function to the passed argument, its value outside the function will remain unchanged.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.change} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{x} \hlkwb{<-} \hlnum{NA}\hlstd{\}}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlkwd{my.change}\hlstd{(a)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

Any result that needs to be made available outside the function must be returned by the function. If the function \texttt{return} is not explicitly used, the value returned by the last statement within the body of the function will be returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{print.x.1} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.1}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.2} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{print}\hlstd{(x);} \hlkwd{return}\hlstd{(x)\}}
\hlkwd{print.x.2}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.3} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{(x);} \hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.3}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "test"
\end{verbatim}
\begin{alltt}
\hlstd{print.x.4} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{();} \hlkwd{print}\hlstd{(x)\}}
\hlkwd{print.x.4}\hlstd{(}\hlstr{"test"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

We can assign to a variable defined outside a function with operator \texttt{<<-} but the usual recommendation is to avoid its use. This type of effects of calling a function are frequently called `side-effects'.

Now we will define a useful function: a function for calculating the standard error of the mean from a numeric vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x)}\hlopt{/}\hlkwd{length}\hlstd{(x))\}}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{5}\hlstd{)}
\hlstd{a.na} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

For example in \texttt{SEM(a)} we are calling function \texttt{SEM} with \texttt{a} as argument.

The function we defined above may sometimes give a wrong answer because NAs will be counted by \texttt{length}, so we need to remove NAs before calling \texttt{length}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)} \hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}\hlopt{/}\hlkwd{length}\hlstd{(}\hlkwd{na.omit}\hlstd{(x)))}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{5}\hlstd{)}
\hlstd{a.na} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\end{kframe}
\end{knitrout}

R does not have a function for standard error, so the function above would be generally useful. If we would like to make this function both safe, and consistent with other R functions, one could define it as follows, allowing the user to provide a second argument which is passed as an argument to \texttt{var}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{FALSE}\hlstd{)\{}\hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x,} \hlkwc{na.rm}\hlstd{=na.rm)}\hlopt{/}\hlkwd{length}\hlstd{(}\hlkwd{na.omit}\hlstd{(x)))\}}
\hlkwd{SEM}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(a.na,} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlkwc{x}\hlstd{=a.na,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlnum{TRUE}\hlstd{, a.na)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in if (na.rm) "{}na.or.complete"{} else "{}everything"{}: the condition has length > 1 and only the first element will be used}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{,} \hlkwc{x}\hlstd{=a.na)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\end{kframe}
\end{knitrout}

In this example you can see that functions can have more than one parameter, and that parameters can have default values to be used if no argument is supplied. In addition if the name of the parameter is indicated, then arguments can be supplied in any order, but if parameter names are not supplied, then arguments are assigned to parameters based on their position. Once one parameter name is given, all later arguments need also to be explicitly matched to parameters. Obviously if given by position, then arguments should be supplied explicitly for all parameters at `intermediate' positions.

\section{R built-in functions}

\subsection{Plotting}

The built-in generic function \texttt{plot} can be used to plot data. It is a generic function, that has suitable methods for different kinds of objects.

Before we can plot anything, we need some data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(cars)}
\hlkwd{names}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
## [1] "speed" "dist"
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
## 3     7    4
## 4     7   22
## 5     8   16
## 6     9   10
\end{verbatim}
\begin{alltt}
\hlkwd{tail}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
##    speed dist
## 45    23   54
## 46    24   70
## 47    24   92
## 48    24   93
## 49    24  120
## 50    25   85
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{cars} is an example data set that is included in R. It is stored as a dataframe. Data frames are used for storing data, they consist in columns of equal length. The different columns can be different types (e.g. numeric and character). With \texttt{data} we load it; with \texttt{names} we obtain the names of the variables or columns. With head with can see the top several lines, and with tail the lines at the end.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data}\hlstd{=cars)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-plot-2-1} 

}



\end{knitrout}

\subsection{Fitting linear models}

\subsubsection{Regression}

The R function \texttt{lm} is used next to fit a linear regression.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm1} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm1)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm1)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed, data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -29.069  -9.525  -2.272   9.215  43.201 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)
## (Intercept) -17.5791     6.7584  -2.601   0.0123
## speed         3.9324     0.4155   9.464 1.49e-12
##                
## (Intercept) *  
## speed       ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 15.38 on 48 degrees of freedom
## Multiple R-squared:  0.6511,	Adjusted R-squared:  0.6438 
## F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm1)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##           Df Sum Sq Mean Sq F value   Pr(>F)    
## speed      1  21186 21185.5  89.567 1.49e-12 ***
## Residuals 48  11354   236.5                     
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-1-1} 
\includegraphics[width=.95\textwidth]{figure/pos-models-1-2} 
\includegraphics[width=.95\textwidth]{figure/pos-models-1-3} 
\includegraphics[width=.95\textwidth]{figure/pos-models-1-4} 

}



\end{knitrout}

Let's look at each step separately: \texttt{dist ~ speed} is the specification of the model to be fitted. The intercept is always implicitly included. To `remove' this implicit intercept from the earlier model we can use \texttt{dist ~ speed - 1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm2} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm2)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm2)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed - 1, data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -26.183 -12.637  -5.455   4.590  50.181 
## 
## Coefficients:
##       Estimate Std. Error t value Pr(>|t|)    
## speed   2.9091     0.1414   20.58   <2e-16 ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 16.26 on 49 degrees of freedom
## Multiple R-squared:  0.8963,	Adjusted R-squared:  0.8942 
## F-statistic: 423.5 on 1 and 49 DF,  p-value: < 2.2e-16
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##           Df Sum Sq Mean Sq F value    Pr(>F)    
## speed      1 111949  111949  423.47 < 2.2e-16 ***
## Residuals 49  12954     264                      
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-2-1} 
\includegraphics[width=.95\textwidth]{figure/pos-models-2-2} 
\includegraphics[width=.95\textwidth]{figure/pos-models-2-3} 
\includegraphics[width=.95\textwidth]{figure/pos-models-2-4} 

}



\end{knitrout}

We now we fit a second degree polynomial.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{),} \hlkwc{data}\hlstd{=cars)} \hlcom{# we fit a model, and then save the result}
\hlkwd{plot}\hlstd{(fm3)} \hlcom{# we produce diagnosis plots}
\hlkwd{summary}\hlstd{(fm3)} \hlcom{# we inspect the results from the fit}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed + I(speed^2), data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.720  -9.184  -3.188   4.628  45.152 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)
## (Intercept)  2.47014   14.81716   0.167    0.868
## speed        0.91329    2.03422   0.449    0.656
## I(speed^2)   0.09996    0.06597   1.515    0.136
## 
## Residual standard error: 15.18 on 47 degrees of freedom
## Multiple R-squared:  0.6673,	Adjusted R-squared:  0.6532 
## F-statistic: 47.14 on 2 and 47 DF,  p-value: 5.852e-12
\end{verbatim}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm3)} \hlcom{# we calculate an ANOVA}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##            Df  Sum Sq Mean Sq F value    Pr(>F)
## speed       1 21185.5 21185.5  91.986 1.211e-12
## I(speed^2)  1   528.8   528.8   2.296    0.1364
## Residuals  47 10824.7   230.3                  
##               
## speed      ***
## I(speed^2)    
## Residuals     
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-models-3-1} 
\includegraphics[width=.95\textwidth]{figure/pos-models-3-2} 
\includegraphics[width=.95\textwidth]{figure/pos-models-3-3} 
\includegraphics[width=.95\textwidth]{figure/pos-models-3-4} 

}



\end{knitrout}

We can also compare the two models.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm1)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: dist ~ speed - 1
## Model 2: dist ~ speed
##   Res.Df   RSS Df Sum of Sq      F  Pr(>F)  
## 1     49 12954                              
## 2     48 11354  1    1600.3 6.7655 0.01232 *
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

Or three or more models. But be careful, as the order of the arguments matters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm1, fm3)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: dist ~ speed - 1
## Model 2: dist ~ speed
## Model 3: dist ~ speed + I(speed^2)
##   Res.Df   RSS Df Sum of Sq      F  Pr(>F)  
## 1     49 12954                              
## 2     48 11354  1   1600.26 6.9482 0.01133 *
## 3     47 10825  1    528.81 2.2960 0.13640  
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use different criteria to choose the best model: significance based on $P$-values or information criteria (AIC, BIC) that penalize the result based on the number of parameters in the fitted model. In the case of AIC and BIC, a smaller value is better, and values returned can be either positive or negative, in which case more negative is better.

\section{Control of execution flow}

\subsection{Conditional execution}

\subsubsection{Non-vectorized}

R has two types of ``if'' statements, non-vectorized and vectorized. We will start with the non-vectorized one, which is similar to what is available in most other computer programming languages.

Before this we need to explain compound statements. Individual statements can be grouped into compound statements by enclosed them in curly braces.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{\{}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"C"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "B"
## [1] "C"
\end{verbatim}
\end{kframe}
\end{knitrout}

The example above is pretty useless, but becomes useful when used together with `control' constructs. The \texttt{if} construct controls the execution of one statement, however, this statement can be a compound statement of almost any length or complexity. Play with the code below by changing the value assigned to \texttt{printing}, including NA, and logical(0).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{printing} \hlkwb{<-} \hlnum{TRUE}
\hlkwa{if} \hlstd{(printing) \{}
  \hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\end{kframe}
\end{knitrout}

The condition `(\ \ )' can be anything yielding a logical vector, however, as this is not vectorized, only the first element will be used. Play with this example by changing the value assigned to \texttt{a}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{10.0}
\hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0.0}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"'a' is negative"}\hlstd{)} \hlkwa{else} \hlkwd{print}\hlstd{(}\hlstr{"'a' is not negative"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"This is always printed"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "This is always printed"
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see above the statement immediately following \texttt{else} is executed if the condition is false. Later statements are executed independently of the condition.

Do you still remember the rules about continuation lines?



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# 1}
\hlkwd{if} (a < 0.0)
  \hlkwd{print}(\hlstr{"\hlstr{'a'} is negative"}) else
    \hlkwd{print}(\hlstr{"\hlstr{'a'} is not negative"})
\hlcom{# 2 (not evaluated here)}
\hlkwd{if} (a < 0.0) \hlkwd{print}(\hlstr{"\hlstr{'a'} is negative"})
else \hlkwd{print}(\hlstr{"\hlstr{'a'} is not negative"})
\end{alltt}
\end{kframe}
\end{knitrout}

Why does only the second example above trigger an error?

Play with the use conditional execution, with both simple and compound statements, and also think how to combine \texttt{if} and \texttt{else} to select among more than two options.

There is in R a \texttt{switch} statement, that we will not describe here, that can be used to select among ``cases'', or several alternative statements, based on an expression evaluating to a number or a character string.

\subsubsection{Vectorized}

The vectorized conditional execution is coded by means of a \textbf{function} called \texttt{ifelse} (one word). This function takes three arguments: a logical vector, a result vector for TRUE, a result vector for FALSE. All three can be any construct giving the necessary argument as their result. In the case of result vectors, recycling will apply if they are not of the correct length. \textcolor{red}{The length of the result is determined by the length of the logical vector in the first argument!}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{,} \hlnum{1}\hlstd{,} \hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] -1 -1 -1 -1 -1  1  1  1  1  1
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1]  0  1  2  3  4  7  8  9 10 11
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{any}\hlstd{(a}\hlopt{>}\hlnum{5}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# tricky}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{logical}\hlstd{(}\hlnum{0}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# even more tricky}
\end{alltt}
\begin{verbatim}
## logical(0)
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlnum{NA}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# as expected}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Try to understand what is going on in the previous example. Create your own examples to test how \texttt{ifelse} works.

Exercise: write using \texttt{ifelse} a single statement to combine numbers from a and b into a result vector d, based on whether the corresponding value in c is the character "a" or "b".

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{b} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlopt{+}\hlnum{1}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{5}\hlstd{))}
\hlcom{# your code}
\end{alltt}
\end{kframe}
\end{knitrout}

If you do not understand how the three vectors are built, or you cannot guess the values they contain by reading the code, print them, and play with the arguments, until you have clear what each parameter does.

\subsection{Why using vectorized functions and operators is important}

If you have written programs in other languages, it would feel to you natural to use loops (for, repeat while, repeat until) for many of the things for which we have been using vectorization. When using the R language it is best to use vectorization whenever possible, because it keeps the listing of scripts and programs shorter and easier to understand (at least for those with experience in R). However, there is another very important reason: execution speed. The reason behind this is that R is an interpreted language. In current versions of R it is possible to byte-compile functions, but this is rarely used for scripts, and even byte-compiled loops are much slower and vectorized functions.

However, there are cases were we need to repeatedly execute statements in a way that cannot be vectorized, or when we do not need to maximize execution speed. The R language does have loop constructs, and we will describe them next.

\subsection{Repetition}

The most frequently used type of loop is a \texttt{for} loop. These loops work in R are based on lists or vectors of values to act upon.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0}
\hlkwa{for} \hlstd{(a} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{) b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{sum}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{)} \hlcom{# built-in function}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\end{kframe}
\end{knitrout}

Here the statement \texttt{b <- b + a} is executed five times, with a sequentially taking each of the values in \texttt{1:5}. Instead of a simple statement used here, also a compound statement could have been used.

Here are a few examples that show some of the properties of \texttt{for} loops and functions, combined with the use of a function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{test.for} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlstd{x) \{}\hlkwd{print}\hlstd{(i)\}}
\hlstd{\}}
\hlkwd{test.for}\hlstd{(}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{))}
\hlkwd{test.for}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
## [1] 2
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{NA}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{list}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{test.for}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"z"}\hlstd{, letters[}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{]))}
\end{alltt}
\begin{verbatim}
## [1] "z"
## [1] "a"
## [1] "b"
## [1] "c"
## [1] "d"
\end{verbatim}
\end{kframe}
\end{knitrout}

In contrast to other languages, in R function arguments are not checked for `type' when the function is called. The only requirement is that the function code can handle the argument provided. In this example you can see that the same function works with numeric and character vectors, and with lists. We haven't seen lists before. As earlier discussed all elements in a vector should have the same type. This is not the case for lists. It is also interesting to note that a list or vector of length zero is a valid argument, that triggers no error, but that as one would expect, causes the statements in the loop body to be skipped.

Some examples of use of \texttt{for} loops --- and of how to avoid there use.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) x}\hlopt{*}\hlnum{2} \hlcom{# result is lost}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a)} \hlkwd{print}\hlstd{(x}\hlopt{*}\hlnum{2}\hlstd{)} \hlcom{# print is needed!}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 8
## [1] 6
## [1] 12
## [1] 16
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) x}\hlopt{*}\hlnum{2} \hlcom{# doesn't work as expected, but triggers no error}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) b} \hlkwb{<-} \hlstd{x}\hlopt{*}\hlnum{2} \hlcom{# a bit of a surprise, as b is not a vector!}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 16
\end{verbatim}
\begin{alltt}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 1
## [1]  1 16
## [1]  1 16  9
## [1]  1 16  9 36
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlcom{# is a vector!}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlcom{# a bit faster if we first allocate a vector of the required length}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a))}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 1 0 0 0 0
## [1]  1 16  0  0  0
## [1]  1 16  9  0  0
## [1]  1 16  9 36  0
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlstd{b} \hlcom{# is a vector!}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlcom{# vectorization is simplest and fastest}
\hlstd{b} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\end{kframe}
\end{knitrout}

Look at the results from the above examples, and try to understand where does the returned value come from in each case.

We sometimes may not be able to use vectorization, or may be easiest to not use it. However, whenever working with large data sets, or many similar datasets, we will need to take performance into account. As vectorization usually also makes code simpler, it is good style to use it whenever possible.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{)}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along}\hlstd{=b)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 3 0 0 0
## [1]  3 -1  0  0
## [1]  3 -1  3  0
## [1]  3 -1  3  2
\end{verbatim}
\begin{alltt}
\hlcom{# although in this case there were alternatives, there}
\hlcom{# are other cases when we need to use indexes explicitly}
\hlstd{b} \hlkwb{<-} \hlstd{a[}\hlnum{2}\hlopt{:}\hlkwd{length}\hlstd{(a)]} \hlopt{-} \hlstd{a[}\hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{]}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  3 -1  3  2
\end{verbatim}
\begin{alltt}
\hlcom{# or even better}
\hlstd{b} \hlkwb{<-} \hlkwd{diff}\hlstd{(a)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  3 -1  3  2
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{seq(along=b)} builds a new numeric vector with a sequence of the same length as the length as the vector given as argument for parameter `along'.

\texttt{while} loops are quite frequently also useful. Instead of a list or vector, they take a logical argument, which is usually an expression, but which can also be a variable. For example the previous calculation could be also done as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlstd{i} \hlkwb{<-} \hlnum{1}
\hlkwa{while} \hlstd{(i} \hlopt{<} \hlkwd{length}\hlstd{(a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
  \hlstd{i} \hlkwb{<-} \hlstd{i} \hlopt{+} \hlnum{1}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1]  1 -1  3  2
## [1]  1 16  3  2
## [1]  1 16  9  2
## [1]  1 16  9 36
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36
\end{verbatim}
\end{kframe}
\end{knitrout}

Here is another example. In this case we use the result of the previous iteration in the current one. In this example you can also see, that it is allowed to put more than one statement in a single line, in which case the statements should be separated by a semicolon (;).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{while} \hlstd{(a} \hlopt{<} \hlnum{50}\hlstd{) \{}\hlkwd{print}\hlstd{(a); a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

Make sure that you understand why the final value of \texttt{a} is larger than 50.

\texttt{repeat} is seldom used, but adds flexibility as \texttt{break} can be in the middle of the compound statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{repeat}\hlstd{\{}
  \hlkwd{print}\hlstd{(a)}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
  \hlkwa{if} \hlstd{(a} \hlopt{>} \hlnum{50}\hlstd{) \{}\hlkwd{print}\hlstd{(a);} \hlkwa{break}\hlstd{()\}}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
## [1] 256
\end{verbatim}
\begin{alltt}
\hlcom{# or more elegantly}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{repeat}\hlstd{\{}
  \hlkwd{print}\hlstd{(a)}
  \hlkwa{if} \hlstd{(a} \hlopt{>} \hlnum{50}\hlstd{)} \hlkwa{break}\hlstd{()}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

Please, make sure you understand what is happening in the previous examples.

\subsection{Nesting}

All the execution-flow control statements seen above can be nested. We will show an example with two \texttt{for} loops. We first need a matrix of data to work with:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlnum{10}\hlstd{,} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlcom{# argument names used for clarity}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{5}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\end{kframe}
\end{knitrout}

All the statements above are equivalent, but some are easier to read than others.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# slower as size needs to be expanded}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{nrow}\hlstd{(A))} \hlcom{# faster}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

Look at the output of these two examples to understand what is happening differently with \texttt{row.sum}.

The code above is very general, it will work with any size of two dimensional matrix, which is good programming practice. However, sometimes we need more specific calculations. \texttt{A[1, 2]} selects one cell in the matrix, the one on the first row of the second column. \texttt{A[1, ]} selects row one, and  \texttt{A[ , 2]} selects column two. In the example above the value of \texttt{i} changes for each iteration of the outer loop. The value of \texttt{j} changes for each iteration of the inner loop, and the inner loop is run in full for each iteration of the outer loop. The inner loop index \texttt{j} changes fastest.

Exercises: 1) modify the example above to add up only the first three columns of A, 2) modify the example above to add the last three columns of A.

Will the code you wrote continue working as expected if the number of rows in A changed? and what if the number of columns in A changed, and the required results still needed to be calculated for relative positions? What would happen if A had fewer than three columns? Try to think first what to expect based on the code you wrote. Then create matrices of different sizes and test your code. After that think how to improve the code, at least so that wrong results are not produced.

Vectorization can be achieved in this case easily for the inner loop.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{nrow}\hlstd{(A))} \hlcom{# faster}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlkwd{sum}\hlstd{(A[i, ])}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

\texttt{A[i, ]} selects row \texttt{i} and all columns. In R, the row index always comes first, which is not the case in all programming languages.

Full vectorization can be achieved with \texttt{apply} functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{apply}\hlstd{(A,} \hlkwc{MARGIN} \hlstd{=} \hlnum{1}\hlstd{, sum)} \hlcom{# MARGIN=1 inidcates rows}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

How would you change this last example, so that only the last three columns are added up? (Think about use of subscripts to select a part of the matrix.)

There are many variants of \texttt{apply} functions, both in base R and in contributed packages.

\section{Packages}

In R speak `library' is the location where `packages' are installed. Packages are sets of functions, and data, specific for some particular purpose, that can be loaded into an R session to make them available so that they can be used in the same way as built-in R functions and data. The function \texttt{library} is used to load packages, already installed in the local R library, into the current session, while the function \texttt{install.packages} is used to install packages, either from a file, or directly from the internet into the library. When using RStudio it is easiest to use RStudio commands (which call \texttt{install.packages} and \texttt{update.packages}) to install and update packages.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(graphics)}
\end{alltt}
\end{kframe}
\end{knitrout}

Currently there are thousands of packages available. The most reliable source of packages is CRAN, as only packages that pass strict tests and are actively maintained are included. In some cases you may need or want to install less stable code, and this is also possible.

R packages can be installed either from source, or from already built `binaries'. Installing from sources, depending on the package, may require quite a lot of additional software to be available. Under MS-Windows, very rarely the needed shell, commands and compilers are already available. Installing then is not too difficult (you will need RTools, and MiKTeX). For this reason it is the norm to install packages from binary .zip files. Under Linux most tools will be available, or very easy to install, so it is not unusual to install from sources. For OS X (Mac) the situation is somewhere in-between. If the tools are available, packages can be very easily installed from source from within RStudio.

The development of packages is beyond the scope of the current course, but it is still interesting to know a few things about packages. Using RStudio it is relatively easy to develop your own packages. Packages can be of very different sizes. Packages use a relatively rigid structure of folder for storing the different types of files, and there is a built-in help system, that one needs to use, so that the package documentation gets linked to the R help system when the package is loaded. In addition to R code, packages can call C, C++, FORTRAN, Java, etc. functions and routines, but some kind of `glue' is needed, as data is stored differently. At least for C++, the recently developed Rcpp R package makes the gluing extremely easy.

In addition to some packages from CRAN, later in the course we will use a suite of packages for photobiology that I have developed during the last couple of years. Some of the functions in these packages are very simple, and others more complex. In one of the packages, I included some C++ functions to improve performance. Replacing some R for loops with C++ for loops and iterators, resulted in a huge speed increase. The reason for this is that R is an interpreted language and C++ is compiled into machine code. Recent versions of R allow byte-compilation which can give some speed improvement, without need to switch to another language.

The source code for the photobiology and many other packages is freely available, so if you are interested you can study it. For any function defined in R, typing at the command prompt the name of the function without the parentheses lists the code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{length}  \hlcom{# a function defined in C within R itself}
\end{alltt}
\begin{verbatim}
## function (x)  .Primitive("length")
\end{verbatim}
\begin{alltt}
\hlstd{SEM} \hlcom{# the function we defined earlier}
\end{alltt}
\begin{verbatim}
## function(x, na.rm=FALSE){sqrt(var(x, na.rm=na.rm)/length(na.omit(x)))}
\end{verbatim}
\end{kframe}
\end{knitrout}

One good way of learning how R works, is by experimenting with it, and whenever using a certain function looking at the help, to check what are all the available options.



% !Rnw root = r4p.main.Rnw



\chapter{Storing and manipulating data with R}\label{chap:R:data}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(data.table)}
\end{alltt}
\end{kframe}
\end{knitrout}



\section{Introduction}

Data frames have been discussed in \ref{chap:R:as:calc} and data tables are also data frames. In other words they are `derived' from data frames, so they can be used whenever data frames are expected as input. Package \code{data.frame} is under active development but it is already a better option than data frames in many contexts, specially when working with large data sets. The reason for this is that because of the way the R language is defined, data frames are are very frequently copied in whole even when a small part of the data is altered, or when passed as arguments to many functions. This has a very large impact on performance. The \code{data.table} avoids or delays copying as much as possible, and also implements fast search, sort, etc. operations. This makes a huge difference for large data sets. For smaller data set the main advantage is the new (additional) syntax that is more concise, though not in all cases easier to understand.

\section[Differences between data.tables and data.frames]{Differences between \code{data.tables} and \code{data.frames}}

Data tables are also data frames, and if one operates on them with the usual data-frame syntax, in most cases they behave identically to data frames. To achieve the full advantage in performance one should be careful of one codes scripts and functions. Data tables can created in a similar way as data frames.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.dt} \hlkwb{<-} \hlkwd{data.table}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{))}
\hlkwd{class}\hlstd{(my.dt)}
\end{alltt}
\begin{verbatim}
## [1] "data.table" "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

We can `convert' in place, without any copying, a data frame into a data table using \code{setDT}, and with \code{setDF} `convert' a data table into a data frame.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{))}
\hlkwd{class}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{setDT}\hlstd{(my.df)}
\hlkwd{class}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.table" "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{setDF}\hlstd{(my.df)}
\hlkwd{class}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

An assignment of a data frame is equivalent to a copy, and in most cases results in the whole data frame being copyed from one location in memory to a different one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.cp.df} \hlkwb{<-} \hlstd{my.df}
\hlkwd{identical}\hlstd{(my.cp.df, my.df)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.df}\hlopt{$}\hlstd{y} \hlkwb{<-} \hlnum{1}
\hlkwd{identical}\hlstd{(my.cp.df, my.df)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

With data tables, assignment with \code{<-} just creates a new name for the same object. However, if we use `data.frame' syntax to alter the new name, a copy is done at that moment, and yields the same result as a true data frame.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.cp.dt} \hlkwb{<-} \hlstd{my.dt}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.dt}\hlopt{$}\hlstd{y} \hlkwb{<-} \hlstd{my.cp.dt}\hlopt{$}\hlstd{y} \hlopt{+} \hlnum{1}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

However, if we use the special syntax introduced by the \code{data.frame} package, no copy is done, and both names continue pointing to the same, now modified data table.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.cp.dt} \hlkwb{<-} \hlstd{my.dt}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.dt[ , y} \hlkwb{:=} \hlstd{y} \hlopt{+} \hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1  0.7987479
##  2:  2 -0.9847955
##  3:  3  1.9382394
##  4:  4 -0.8072314
##  5:  5  1.6242514
##  6:  6  1.8858853
##  7:  7  1.4229916
##  8:  8  1.9892583
##  9:  9  1.4554775
## 10: 10  0.1493907
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1  0.7987479
##  2:  2 -0.9847955
##  3:  3  1.9382394
##  4:  4 -0.8072314
##  5:  5  1.6242514
##  6:  6  1.8858853
##  7:  7  1.4229916
##  8:  8  1.9892583
##  9:  9  1.4554775
## 10: 10  0.1493907
\end{verbatim}
\begin{alltt}
\hlstd{my.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1  0.7987479
##  2:  2 -0.9847955
##  3:  3  1.9382394
##  4:  4 -0.8072314
##  5:  5  1.6242514
##  6:  6  1.8858853
##  7:  7  1.4229916
##  8:  8  1.9892583
##  9:  9  1.4554775
## 10: 10  0.1493907
\end{verbatim}
\end{kframe}
\end{knitrout}

The assignemnt of the value `1' using the new syntax, changed the only object, pointed at by both names. When using data table syntax, if we really want a copy, then we should use the function \code{copy}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.cp.dt} \hlkwb{<-} \hlkwd{copy}\hlstd{(my.dt)}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.dt[ , y} \hlkwb{:=} \hlstd{y} \hlopt{-} \hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1 -0.2012521
##  2:  2 -1.9847955
##  3:  3  0.9382394
##  4:  4 -1.8072314
##  5:  5  0.6242514
##  6:  6  0.8858853
##  7:  7  0.4229916
##  8:  8  0.9892583
##  9:  9  0.4554775
## 10: 10 -0.8506093
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.cp.dt, my.dt)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{my.cp.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1 -0.2012521
##  2:  2 -1.9847955
##  3:  3  0.9382394
##  4:  4 -1.8072314
##  5:  5  0.6242514
##  6:  6  0.8858853
##  7:  7  0.4229916
##  8:  8  0.9892583
##  9:  9  0.4554775
## 10: 10 -0.8506093
\end{verbatim}
\begin{alltt}
\hlstd{my.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1  0.7987479
##  2:  2 -0.9847955
##  3:  3  1.9382394
##  4:  4 -0.8072314
##  5:  5  1.6242514
##  6:  6  1.8858853
##  7:  7  1.4229916
##  8:  8  1.9892583
##  9:  9  1.4554775
## 10: 10  0.1493907
\end{verbatim}
\end{kframe}
\end{knitrout}

For fast access of large data sets one can set a 'key' based on one or more columns, using function \code{setkey}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setkey}\hlstd{(my.dt, y)}
\hlstd{my.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  2 -0.9847955
##  2:  4 -0.8072314
##  3: 10  0.1493907
##  4:  1  0.7987479
##  5:  7  1.4229916
##  6:  9  1.4554775
##  7:  5  1.6242514
##  8:  6  1.8858853
##  9:  3  1.9382394
## 10:  8  1.9892583
\end{verbatim}
\begin{alltt}
\hlkwd{setkey}\hlstd{(my.dt, x)}
\hlstd{my.dt}
\end{alltt}
\begin{verbatim}
##      x          y
##  1:  1  0.7987479
##  2:  2 -0.9847955
##  3:  3  1.9382394
##  4:  4 -0.8072314
##  5:  5  1.6242514
##  6:  6  1.8858853
##  7:  7  1.4229916
##  8:  8  1.9892583
##  9:  9  1.4554775
## 10: 10  0.1493907
\end{verbatim}
\end{kframe}
\end{knitrout}

There is also an special \code{print} method for datables, that is used automatically by default, that instead of printing the whole data.table, only prints the `head' and the `tail' of the tables, unless the table has few rows.
In the examples above all rows were printed because, there were not many of them.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.table}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{1000}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{runif}\hlstd{(}\hlnum{1000}\hlstd{))}
\end{alltt}
\begin{verbatim}
##          x          y
##    1:    1 0.34983682
##    2:    2 0.92519237
##    3:    3 0.03820683
##    4:    4 0.60678066
##    5:    5 0.89697260
##   ---                
##  996:  996 0.00523750
##  997:  997 0.46947011
##  998:  998 0.63985154
##  999:  999 0.97660882
## 1000: 1000 0.61242673
\end{verbatim}
\end{kframe}
\end{knitrout}

\section[Using data.frames and data.tables]{Using \code{data.frames} and \code{data.tables}}

Adding new columns based on other columns, or other variables, uses the same syntax shown above for modifying column `y'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.cp.dt[ , z} \hlkwb{:=} \hlstd{y} \hlopt{+} \hlstd{x} \hlopt{*} \hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
##      x          y         z
##  1:  1 -0.2012521  1.798748
##  2:  2 -1.9847955  2.015205
##  3:  3  0.9382394  6.938239
##  4:  4 -1.8072314  6.192769
##  5:  5  0.6242514 10.624251
##  6:  6  0.8858853 12.885885
##  7:  7  0.4229916 14.422992
##  8:  8  0.9892583 16.989258
##  9:  9  0.4554775 18.455477
## 10: 10 -0.8506093 19.149391
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{data.table))}
\end{alltt}
\end{kframe}
\end{knitrout}


% !Rnw root = r4p.main.Rnw



\chapter{Making publication quality plots with R}\label{chap:R:plotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library, the last three packages seem to interfere with each other, in particular GGally does not function in ggtern is loaded, so the are loaded only in the sections where they are used:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(plyr)}
\hlkwd{library}\hlstd{(grid)}
\hlkwd{library}\hlstd{(Hmisc)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: lattice\\\#\# Loading required package: survival\\\#\# Loading required package: splines\\\#\# Loading required package: Formula\\\#\# \\\#\# Attaching package: 'Hmisc'\\\#\# \\\#\# The following objects are masked from 'package:plyr':\\\#\# \\\#\#\ \ \ \  is.discrete, summarize\\\#\# \\\#\# The following objects are masked from 'package:base':\\\#\# \\\#\#\ \ \ \  format.pval, round.POSIXt, trunc.POSIXt,\\\#\#\ \ \ \  units}}\begin{alltt}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(scales)}
\hlcom{# library(rgdal)}
\hlcom{# library(ggtern)}
\hlcom{# library(ggmap)}
\hlcom{# library(GGally)}
\end{alltt}
\end{kframe}
\end{knitrout}



\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \code{Lattice} and \code{ggplot2}. There are packages that add extra functionality to these packages.

In the examples in this handbook we mainly use \code{ggplot}, \code{ggmap} and \code{ggtern}. In this appendix we give an introduction to the `grammar of graphics' and \code{ggplot2}. There is ample literature on the use of ggplot2, starting with very good reference documentation at \url{http://ggplot2.org/}. The book `R Graphics Cookbook' \cite{Chang2013} is very useful and should be always near you, when using the package, as it contains many worked out examples. There is some overlap between this appendix and the documents mentioned above. There is little well-organized literature on packages extending ggplot2, and as we make use of several of them in this handbook, we have included some examples of their use in this appendix.

\section{Bases of plotting with \code{ggplot2}}

The grammar of graphics is based on aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geometry. In the examples that follow we will use the \code{mtcars} data set included in R.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-186-1} 

}



\end{knitrout}

Aesthetics can be `linked' to data variables, either continuous (numeric) or categorical (factor). Variable \code{cyl} is encoded in the \code{mtcars} dataframe as numeric values. Even though only three values are present, a continuous color scale is used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=cyl))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-187-1} 

}



\end{knitrout}

We can convert \code{cyl} in a factor `on-the-fly' to force the use of a discrete color scale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-188-1} 

}



\end{knitrout}

Data assigned to an aesthetic can be the `result of a calculation'.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{y}\hlstd{=mpg} \hlopt{/} \hlstd{disp))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-189-1} 

}



\end{knitrout}

Within \code{aes} the aesthetics are interpreted as being a function of the values in the data. If given outside \code{aes} they are interpreted as constants, which apply to one geom if given within the call to \code{geom\_xxx} but outside \code{aes} or to the whole plot if given within \code{ggplot} but outside \code{aes}. The aesthetics and data given as \code{ggplot}'s arguments become the defaults for all the geoms, but geoms also take aesthetics and data as arguments, which then override the defaults.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{fill}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"grey10"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-190-1} 

}



\end{knitrout}

In the next example we override the \code{color} aesthetic in \code{geom\_smooth}\footnote{Smoothing and curve fitted is discussed in more detail in section \ref{sec:???}.}, causing all the data to be fitted together

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-191-1} 

}



\end{knitrout}

We can assign the same variable to more than one aesthetic, and the combined key will be produced automatically.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{shape}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-192-1} 

}



\end{knitrout}

We can change the labels for the different aesthetics, and give a title (\verb!\n! means `new line' and can be used to continue a label in the next line). In this case, if two aesthetics are linked to the same variable, the labels supplied should be identical, otherwise two separate keys will be produced.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=hp,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl),} \hlkwc{shape}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
    \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Engine displacement)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Gross horsepower"}\hlstd{,}
       \hlkwc{colour}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{shape}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{title}\hlstd{=}\hlstr{"Motor Trend Car Road Tests (1973-74 models)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-193-1} 

}



\end{knitrout}

We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{mylabs} \hlkwb{<-} \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"Engine displacement)"}\hlstd{,}
       \hlkwc{y}\hlstd{=}\hlstr{"Gross horsepower"}\hlstd{,}
       \hlkwc{colour}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{shape}\hlstd{=}\hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
       \hlkwc{title}\hlstd{=}\hlstr{"Motor Trend Car Road Tests (1973-74 models)"}\hlstd{)}
\hlstd{myplot}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-194-1} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-194-2} 

}



\end{knitrout}

And now we can assemble them into plots.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-195-1} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-195-2} 

}



\end{knitrout}

We can also save intermediate results.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mylogplot} \hlkwb{<-} \hlstd{myplot} \hlopt{+} \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,}\hlnum{20}\hlstd{,}\hlnum{40}\hlstd{),} \hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{8}\hlstd{,}\hlnum{45}\hlstd{))}
\hlstd{mylogplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-196-1} 

}



\end{knitrout}

The are a few predefined themes, even the default \code{theme\_grey} can come in handy because the first parameter to themes is the point size used as reference to calculate all other font sizes. You can see in the two examples bellow, that the size of all text elements changes proportionally.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_grey}\hlstd{(}\hlnum{10}\hlstd{)}
\hlstd{myplot} \hlopt{+} \hlstd{mylabs} \hlopt{+} \hlkwd{theme_grey}\hlstd{(}\hlnum{16}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-197-1} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-197-2} 

}



\end{knitrout}

Be aware that the different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. We use the \code{alpha} aesthetic to make the confidence band less transparent so that the example is easier to see in print.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+} \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-198-1} 

}



\end{knitrout}

The plot looks different if the order of the geoms is swapped. The data points overlapping the confidence band are more clearly visible in this second example because they are above the shaded area instead of bellow it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=disp,} \hlkwc{y}\hlstd{=mpg,} \hlkwc{colour}\hlstd{=}\hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
   \hlkwd{geom_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-199-1} 

}



\end{knitrout}

\section{Adding fitted curves, including splines}

We will now show an example of use of \code{stat\_smooth} using the default spline smoothing.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# geom\_smooth: method="{}auto"{} and size of largest group is <1000, so using loess. Use 'method = x' to change the smoothing method.}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-200-1} 

}



\end{knitrout}

Instead of using the default spline, we can use a linear model fit. In this example we use a linear model, fitted by lm, as smoother:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-201-1} 

}



\end{knitrout}

Instead of using the default linear regression as smoother, we can use a linear model fit. In this example we use a polynomial of order 2 fitted by lm.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{formula}\hlstd{=y}\hlopt{~}\hlkwd{poly}\hlstd{(x,}\hlnum{2}\hlstd{),} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-202-1} 

}



\end{knitrout}

If we do not use \code{colour="black"} then the colour aesthetics supplied to \code{ggplot} is used, and splits the data into three groups to which the model is fitted separately.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{myplot} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-203-1} 

}



\end{knitrout}

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use these more advanced models.

\section{Adding statistical ``summaries''}

It is also possible to summarize data on-the-fly when plotting, but before showing this we will generate some normally distributed artificial data:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{2}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{0.5}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{0.7}\hlstd{)),}
  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{20}\hlstd{)))}
  \hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Now we use these data to plot means and confidence intervals by group:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake.data,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlstd{fig2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-205-1} 

}



\end{knitrout}

We have saved the base figure in \code{fig2}, so now we can play with different summaries. We first add just the mean. In this case we need to add as argument to \code{stat\_summary} the geom to use, as the default one expects data for plotting error bars, in later examples, this is not needed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"mean"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlstr{"-"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-206-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"median"}\hlstd{,} \hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{shape}\hlstd{=}\hlstr{"-"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-207-1} 

}



\end{knitrout}

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_boot"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-208-1} 

}



\end{knitrout}

We can instead add the means and $p = 0.90$ confidence intervals, by supplying a value to parameter \code{conf.int}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_boot"}\hlstd{,} \hlkwc{conf.int}\hlstd{=}\hlnum{0.90}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-209-1} 

}



\end{knitrout}

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-210-1} 

}



\end{knitrout}

In this case the multiplier \code{mult} is by default is calculated from the $t$ distribution according to degrees of freedom, but if we force the multiplier to 1, then we get error bars corresponding to $\pm$s.e. (standard errors).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,} \hlkwc{mult}\hlstd{=}\hlnum{1}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-211-1} 

}



\end{knitrout}

Finally we can plot error bars showing $\pm$s.d. (standard deviation). The default value for \code{mult} is 2, giving error bars $\pm 2$ s.d., we use 1 as multiplier instead.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+} \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_sdl"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.7}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-212-1} 

}



\end{knitrout}

We do not show it here, but instead of using these functions (from package \code{Hmisc}) it is possible to define one's own functions.

Finally we plot the means in a bar plot, with the observations superimposed and $p = 0.95$ C.I. (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets they can be assigned to factors in the data set.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake.data,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.y} \hlstd{=} \hlstr{"mean"}\hlstd{,} \hlkwc{geom} \hlstd{=} \hlstr{"bar"}\hlstd{,}
               \hlkwc{fill}\hlstd{=}\hlstr{"yellow"}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
               \hlkwc{geom} \hlstd{=} \hlstr{"errorbar"}\hlstd{,}
               \hlkwc{width}\hlstd{=}\hlnum{0.1}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-213-1} 

}



\end{knitrout}

\section{Plotting functions}

We can also directly plot functions, without need to generate data beforehand:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=dnorm)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-214-1} 

}



\end{knitrout}

We can even pass additional arguments to a function:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= dnorm,} \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{.5}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-215-1} 

}



\end{knitrout}

Of course, user-defined functions (not shown), and anonymous functions can also be used:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlnum{0}\hlopt{:}\hlnum{1}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{a}\hlstd{,} \hlkwc{b}\hlstd{)\{a} \hlopt{+} \hlstd{b} \hlopt{*} \hlstd{x}\hlopt{^}\hlnum{2}\hlstd{\},}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{1.4}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-216-1} 

}



\end{knitrout}

Here is another example of a predefined function, but in this case the default scale is not the best:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-217-1} 

}



\end{knitrout}

In this case we need to change the x-axis scale to better suit the sin function and the use of radians as angular units\footnote{The use of \code{expression} is explained in detail in section \ref{sec:??}, an the use of \code{scales} in section \ref{sec:???}.}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}
    \hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,}
    \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"0"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{0.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(pi),}
             \hlkwd{expression}\hlstd{(}\hlnum{1.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(}\hlnum{2}\hlopt{~}\hlstd{pi)))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlstr{"sin(x)"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-218-1} 

}



\end{knitrout}

\section{Plotting text}

One can use \code{geom\_text} to add text labels to observations. The aesthetic \code{label} gives text and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{colour} aesthetic can be also used for text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of zero for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the label left or down, and positive values right or up. A value of 1 or -1 sets the text so that its edge is at the supplied coordinate. Values outside the range $-1\ldots 1$ sift the text even further away.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y}\hlstd{=}\hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwc{label}\hlstd{=}\hlkwd{paste}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{],} \hlstr{" "}\hlstd{))}
\hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x,y,}\hlkwc{label}\hlstd{=label))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{45}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-219-1} 

}



\end{knitrout}

In this example we use \code{paste} (which uses recycling here) to add a space at the end of each label. Justification values outside the range $-1\ldots 1$ are allowed, but are relative to the with of the label. As the default font used in this case has variable with characters, the justification would be inconsistent (e.g. try the code above but using \code{hjust} set to 3 instead of to 1 without pasting a space character to the labels.)


\section{Scales}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted object, such as \code{colour}, \code{size}, position (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the x-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also assign the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different one, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Be aware that for example for colour, and `numbers' there are both discrete and continuous scales available.

Advanced scale manipulation requires the package \code{scales} to be loaded. Some simple examples follow.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake2.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{20}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{5}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{40}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{10}\hlstd{)),}
  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{20}\hlstd{))),}
  \hlkwc{z} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{40}\hlstd{,} \hlkwc{mean}\hlstd{=}\hlnum{12}\hlstd{,} \hlkwc{sd}\hlstd{=}\hlnum{6}\hlstd{)}
  \hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data}\hlstd{=fake2.data,}
         \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=y,} \hlkwc{x}\hlstd{=group,} \hlkwc{shape}\hlstd{=group,} \hlkwc{colour}\hlstd{=group,} \hlkwc{size}\hlstd{=z))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlstd{fig2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-222-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig2} \hlopt{+}
  \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,}\hlnum{20}\hlstd{,}\hlnum{30}\hlstd{,}\hlnum{40}\hlstd{,}\hlnum{50}\hlstd{,}\hlnum{60}\hlstd{))} \hlopt{+}
       \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
                    \hlkwc{colour}\hlstd{=}\hlstr{"black"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{1}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{1}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.}}\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-223-1} 

}



\end{knitrout}

\section{Adding annotations}

Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the ggplot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=sin)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}
    \hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,}
    \hlkwc{labels}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"0"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{0.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(pi),}
             \hlkwd{expression}\hlstd{(}\hlnum{1.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(}\hlnum{2}\hlopt{~}\hlstd{pi)))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y}\hlstd{=}\hlstr{"sin(x)"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{label}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"+"}\hlstd{,} \hlstr{"-"}\hlstd{),}
           \hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{1.5}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlopt{-}\hlnum{0.5}\hlstd{),}
           \hlkwc{size}\hlstd{=}\hlnum{20}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
           \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,}
           \hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,}
           \hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{,}
           \hlkwc{x}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y}\hlstd{=}\hlnum{0}\hlstd{,}
           \hlkwc{size}\hlstd{=}\hlnum{6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-224-1} 

}



\end{knitrout}

\section{Using facets}

Sets of coordinated plots are a very useful tool for visualizing data. These became popular through the \code{trellis} graphs in S, and the \code{lattice} package in R. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \code{ggplot2} there are two possible types of facets: facets organized in a grid, and facets on along a single `axis' but wrapped into several rows. In the examples below we use \code{geom\_point} but faceting can be used with any geom, and even with maps and ternary plots.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(mpg, wt))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlcom{# With one variable}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-225-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(cyl} \hlopt{~} \hlstd{.)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-226-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl,} \hlkwc{scales} \hlstd{=} \hlstr{"free"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-227-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl,} \hlkwc{scales} \hlstd{=} \hlstr{"free"}\hlstd{,} \hlkwc{space} \hlstd{=} \hlstr{"free"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-228-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(vs} \hlopt{~} \hlstd{am)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-229-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(vs} \hlopt{~} \hlstd{am,} \hlkwc{margins}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-230-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-231-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-232-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{margins}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-233-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(cyl} \hlopt{~} \hlstd{vs,} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-234-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mtcars}\hlopt{$}\hlstd{cyl12} \hlkwb{<-} \hlkwd{factor}\hlstd{(mtcars}\hlopt{$}\hlstd{cyl,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"alpha"}\hlstd{,} \hlstr{"beta"}\hlstd{,} \hlstr{"sqrt(x, y)"}\hlstd{))}
\hlstd{p1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(mpg, wt))} \hlopt{+} \hlkwd{geom_point}\hlstd{()}
\hlstd{p1} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{cyl12,} \hlkwc{labeller} \hlstd{= label_parsed)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-235-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_grid}\hlstd{(.} \hlopt{~} \hlstd{vs,} \hlkwc{labeller} \hlstd{=} \hlkwd{label_bquote}\hlstd{(alpha} \hlopt{^} \hlkwd{.}\hlstd{(x)))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-236-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlopt{~} \hlstd{cyl)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-237-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlopt{~} \hlstd{vs} \hlopt{+} \hlstd{am,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-238-1} 

}



\end{knitrout}

At the current time, \code{facet\_wrap} does not accept labellers, so neither expressions nor including the name of the variable in the labels can be done automatically.

\section{Plot matrices}

In this type of plot a set of several variables are plotted against each other, forming all possible pairs.
There is a function \code{plotmatrix} in ggplot2, but it is deprecated. Function \code{ggpairs} from package GGally provides this type of plots as an extension to ggplot.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(GGally)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Use sample of the diamonds data}
\hlkwd{data}\hlstd{(diamonds,} \hlkwc{package}\hlstd{=}\hlstr{"ggplot2"}\hlstd{)}
\hlstd{diamonds.samp} \hlkwb{<-} \hlstd{diamonds[}\hlkwd{sample}\hlstd{(}\hlnum{1}\hlopt{:}\hlkwd{dim}\hlstd{(diamonds)[}\hlnum{1}\hlstd{],}\hlnum{200}\hlstd{),]}
\hlcom{# Custom Example}
\hlstd{pm} \hlkwb{<-} \hlkwd{ggpairs}\hlstd{(}
\hlstd{diamonds.samp[,}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],}
\hlkwc{upper} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{continuous} \hlstd{=} \hlstr{"density"}\hlstd{,} \hlkwc{combo} \hlstd{=} \hlstr{"box"}\hlstd{),}
\hlkwc{lower} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{continuous} \hlstd{=} \hlstr{"points"}\hlstd{,} \hlkwc{combo} \hlstd{=} \hlstr{"dot"}\hlstd{),}
\hlkwc{color} \hlstd{=} \hlstr{"cut"}\hlstd{,}
\hlkwc{title} \hlstd{=} \hlstr{"Diamonds"}
\hlstd{)}
\hlstd{pm}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-241-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{GGally))}
\end{alltt}
\end{kframe}
\end{knitrout}



\section{Circular plots}

A funny example stolen from the ggplot2 website at \url{http://docs.ggplot2.org/current/coord_polar.html}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Hadley's favourite pie chart}
\hlstd{df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{variable} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"resembles"}\hlstd{,} \hlstr{"does not resemble"}\hlstd{),}
  \hlkwc{value} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{80}\hlstd{,} \hlnum{20}\hlstd{)}
\hlstd{)}
\hlkwd{ggplot}\hlstd{(df,} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{""}\hlstd{,} \hlkwc{y} \hlstd{= value,} \hlkwc{fill} \hlstd{= variable))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat} \hlstd{=} \hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"yellow"}\hlstd{))} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{(}\hlstr{"y"}\hlstd{,} \hlkwc{start} \hlstd{= pi} \hlopt{/} \hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{"Pac man"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-244-1} 

}



\end{knitrout}

Something just a bit more useful, also stolen from the same page:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# A pie chart = stacked bar chart + polar coordinates}
\hlstd{pie} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mtcars,} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlnum{1}\hlstd{),} \hlkwc{fill} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
 \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{)}
\hlstd{pie} \hlopt{+} \hlkwd{coord_polar}\hlstd{(}\hlkwc{theta} \hlstd{=} \hlstr{"y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-245-1} 

}



\end{knitrout}

\section{Pie charts vs.\ bar plots example}

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}). %The original figure was created with the following code (not run):



Here is my \code{ggplot2} version of the same figure, using much simpler code and obtaining almost the same result.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{example.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{17}\hlstd{,} \hlnum{18}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{22}\hlstd{,} \hlnum{23}\hlstd{,}
                        \hlnum{20}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{19}\hlstd{,} \hlnum{21}\hlstd{,} \hlnum{20}\hlstd{,}
                        \hlnum{23}\hlstd{,} \hlnum{22}\hlstd{,} \hlnum{20}\hlstd{,} \hlnum{18}\hlstd{,} \hlnum{17}\hlstd{),}
             \hlkwc{examples}\hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,}\hlnum{5}\hlstd{,}\hlnum{5}\hlstd{)),}
             \hlkwc{cols} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"blue"}\hlstd{,} \hlstr{"green"}\hlstd{,} \hlstr{"yellow"}\hlstd{,} \hlstr{"black"}\hlstd{),} \hlnum{3}\hlstd{)}
  \hlstd{)}

\hlkwd{ggplot}\hlstd{(example.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=cols,} \hlkwc{y}\hlstd{=values,} \hlkwc{fill}\hlstd{=cols))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(.}\hlopt{~}\hlstd{examples)} \hlopt{+}
  \hlkwd{scale_fill_identity}\hlstd{()}
\hlkwd{ggplot}\hlstd{(example.data,} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{factor}\hlstd{(}\hlnum{1}\hlstd{),} \hlkwc{y}\hlstd{=values,} \hlkwc{fill}\hlstd{=cols))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{stat}\hlstd{=}\hlstr{"identity"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(.}\hlopt{~}\hlstd{examples)} \hlopt{+}
  \hlkwd{scale_fill_identity}\hlstd{()} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{(}\hlkwc{theta}\hlstd{=}\hlstr{"y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-247-1} 
\includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-247-2} 

}



\end{knitrout}

\section{A classical example about regression}

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}. The original code (not run):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
 \hlkwd{svg}\hlstd{(}\hlstr{"anscombe.svg"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{10.5}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{7}\hlstd{)}
 \hlkwd{par}\hlstd{(}\hlkwc{las}\hlstd{=}\hlnum{1}\hlstd{)}

 \hlcom{##-- some "magic" to do the 4 regressions in a loop:}
 \hlstd{ff} \hlkwb{<-} \hlstd{y} \hlopt{~} \hlstd{x}
 \hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{4}\hlstd{) \{}
   \hlstd{ff[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{]} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"y"}\hlstd{,}\hlstr{"x"}\hlstd{), i,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), as.name)}
   \hlcom{## or   ff2 <- as.name(paste("y", i, sep=""))}
   \hlcom{##      ff3 <- as.name(paste("x", i, sep=""))}
   \hlkwd{assign}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"lm."}\hlstd{,i,}\hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), lmi} \hlkwb{<-} \hlkwd{lm}\hlstd{(ff,} \hlkwc{data}\hlstd{= anscombe))}
 \hlstd{\}}

 \hlcom{## Now, do what you should have done in the first place: PLOTS}
 \hlstd{op} \hlkwb{<-} \hlkwd{par}\hlstd{(}\hlkwc{mfrow}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{2}\hlstd{),} \hlkwc{mar}\hlstd{=}\hlnum{1.5}\hlopt{+}\hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,}\hlnum{3.5}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{1}\hlstd{),} \hlkwc{oma}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{0}\hlstd{),}
           \hlkwc{lab}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{6}\hlstd{,}\hlnum{6}\hlstd{,}\hlnum{7}\hlstd{),} \hlkwc{cex.lab}\hlstd{=}\hlnum{1.5}\hlstd{,} \hlkwc{cex.axis}\hlstd{=}\hlnum{1.3}\hlstd{,} \hlkwc{mgp}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{,}\hlnum{0}\hlstd{))}
 \hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{4}\hlstd{) \{}
   \hlstd{ff[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{]} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"y"}\hlstd{,}\hlstr{"x"}\hlstd{), i,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{), as.name)}
   \hlkwd{plot}\hlstd{(ff,} \hlkwc{data} \hlstd{=anscombe,} \hlkwc{col}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{pch}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{bg} \hlstd{=} \hlstr{"orange"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{2.5}\hlstd{,}
        \hlkwc{xlim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{19}\hlstd{),} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{13}\hlstd{),}
        \hlkwc{xlab}\hlstd{=}\hlkwd{eval}\hlstd{(}\hlkwd{substitute}\hlstd{(}\hlkwd{expression}\hlstd{(x[i]),} \hlkwd{list}\hlstd{(}\hlkwc{i}\hlstd{=i))),}
        \hlkwc{ylab}\hlstd{=}\hlkwd{eval}\hlstd{(}\hlkwd{substitute}\hlstd{(}\hlkwd{expression}\hlstd{(y[i]),} \hlkwd{list}\hlstd{(}\hlkwc{i}\hlstd{=i))))}
   \hlkwd{abline}\hlstd{(}\hlkwd{get}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"lm."}\hlstd{,i,}\hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{)),} \hlkwc{col}\hlstd{=}\hlstr{"blue"}\hlstd{)}
 \hlstd{\}}

 \hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

My version using \code{ggplot2}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# we rearrange the data}
\hlstd{my.mat} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{as.matrix}\hlstd{(anscombe),} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\hlstd{my.anscombe} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{= my.mat[ ,} \hlnum{1}\hlstd{],} \hlkwc{y} \hlstd{= my.mat[ ,} \hlnum{2}\hlstd{],} \hlkwc{case}\hlstd{=}\hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{,} \hlkwd{rep}\hlstd{(}\hlnum{11}\hlstd{,}\hlnum{4}\hlstd{))))}
\hlcom{# we draw the figure}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-249-1} 

}



\end{knitrout}

It is not much more difficult to make it look similar to the original

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{,} \hlkwc{se}\hlstd{=}\hlnum{FALSE}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-250-1} 

}



\end{knitrout}

Although I think that the confidence bands make the point of the example much clearer

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(my.anscombe,} \hlkwd{aes}\hlstd{(x,y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method}\hlstd{=}\hlstr{"lm"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{case,} \hlkwc{ncol}\hlstd{=}\hlnum{2}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-251-1} 

}



\end{knitrout}

This classical example form Anscombe \cite{xxx} demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

\section{Ternary plots}



Being an extension to \code{ggplot2} the main difference is that a ternary plot can be created using \code{coord\_tern} and that the three aesthetics \code{x, y, z} are required. By default the values of the variables mapped to these aesthetics are re-expressed as percentages or fractions. We present here only a few examples, and we encourage the readers to check the package's web site at \url{http://www.ggtern.com}.

For the first example we first generate some random data values from the uniform distribution:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# create some artificial data}
\hlstd{my.trn1.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{),} \hlkwc{y}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{),} \hlkwc{z}\hlstd{=}\hlkwd{runif}\hlstd{(}\hlnum{50}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

A ternary plot is just a plot with a different system of coordinates, and can be obtained using \code{coord\_tern}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(my.trn1.data,} \hlkwd{aes}\hlstd{(x,y,z))} \hlopt{+}
  \hlkwd{coord_tern}\hlstd{(}\hlkwc{L}\hlstd{=}\hlstr{"x"}\hlstd{,}\hlkwc{T}\hlstd{=}\hlstr{"y"}\hlstd{,}\hlkwc{R}\hlstd{=}\hlstr{"z"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

One can achieve a similar result by using \code{ggtern} instead of \code{ggplot}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlkwb{<-} \hlkwd{ggtern}\hlstd{(my.trn1.data,} \hlkwd{aes}\hlstd{(x,y,z))}
\end{alltt}
\end{kframe}
\end{knitrout}

As with any other plot based on \code{ggplot2} one builds the plot by adding `layers'. Themes are also supported.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-256-1} 
\includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-256-2} 

}



\end{knitrout}

It is possible to also draw confidence regions:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_confidence}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-257-1} 

}



\end{knitrout}

Or density estimates. In this last version of the plot I adjust a few other aesthetics and refine the appearance of the plot:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig.trn} \hlopt{+}
  \hlkwd{stat_density2d}\hlstd{(}\hlkwc{fullrange}\hlstd{=T,}\hlkwc{n}\hlstd{=}\hlnum{200}\hlstd{,}
                       \hlkwc{geom}\hlstd{=}\hlstr{"polygon"}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"grey10"}\hlstd{,}
                       \hlkwd{aes}\hlstd{(}\hlkwc{alpha} \hlstd{=..level..))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape}\hlstd{=}\hlnum{21}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlstr{"orange"}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlstr{"x (%)"}\hlstd{,} \hlkwc{y}\hlstd{=}\hlstr{"y (%)"}\hlstd{,} \hlkwc{z}\hlstd{=}\hlstr{"z (%)"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlstr{"Density"}\hlstd{)} \hlopt{+}
  \hlkwd{theme_rgbw}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-unnamed-chunk-258-1} 

}



\end{knitrout}



As a final example we reproduce an elaborate ternary plot from \url{http://www.ggtern.com/2014/01/15/usda-textural-soil-classification/}, the website of the package.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Load the Data. (Available in ggtern 1.0.3.0 next version)}
\hlkwd{data}\hlstd{(USDA)}

\hlcom{# Put tile labels at the midpoint of each tile.}
\hlstd{USDA.LAB} \hlkwb{=} \hlkwd{ddply}\hlstd{(USDA,} \hlstr{'Label'}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{df}\hlstd{) \{}
    \hlkwd{apply}\hlstd{(df[,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],} \hlnum{2}\hlstd{, mean)}
\hlstd{\})}

\hlcom{# Tweak}
\hlstd{USDA.LAB}\hlopt{$}\hlstd{Angle} \hlkwb{=} \hlnum{0}
\hlstd{USDA.LAB}\hlopt{$}\hlstd{Angle[}\hlkwd{which}\hlstd{(USDA.LAB}\hlopt{$}\hlstd{Label} \hlopt{==} \hlstr{'Loamy Sand'}\hlstd{)]} \hlkwb{=} \hlopt{-}\hlnum{35}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Construct the plot.}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= USDA,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=Clay,} \hlkwc{x}\hlstd{=Sand,} \hlkwc{z}\hlstd{=Silt,}
                        \hlkwc{color} \hlstd{= Label,}
                        \hlkwc{fill} \hlstd{= Label))} \hlopt{+}
  \hlkwd{coord_tern}\hlstd{(}\hlkwc{L}\hlstd{=}\hlstr{"x"}\hlstd{,}\hlkwc{T}\hlstd{=}\hlstr{"y"}\hlstd{,}\hlkwc{R}\hlstd{=}\hlstr{"z"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.75}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{color} \hlstd{=} \hlstr{'black'}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data} \hlstd{= USDA.LAB,}
            \hlkwd{aes}\hlstd{(}\hlkwc{label} \hlstd{= Label,} \hlkwc{angle} \hlstd{= Angle),}
            \hlkwc{color} \hlstd{=} \hlstr{'black'}\hlstd{,}
            \hlkwc{size} \hlstd{=} \hlnum{3.5}\hlstd{)} \hlopt{+}
  \hlkwd{theme_rgbw}\hlstd{()} \hlopt{+}
  \hlkwd{theme_showsecondary}\hlstd{()} \hlopt{+}
  \hlkwd{theme_showarrows}\hlstd{()} \hlopt{+}
  \hlkwd{custom_percent}\hlstd{(}\hlstr{"Percent"}\hlstd{)} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{legend.justification} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
        \hlkwc{legend.position}      \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
        \hlkwc{axis.tern.padding}    \hlstd{=} \hlkwd{unit}\hlstd{(}\hlnum{0.15}\hlstd{,} \hlstr{'npc'}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{'USDA Textural Classification Chart'}\hlstd{,}
       \hlkwc{fill}  \hlstd{=} \hlstr{'Textural Class'}\hlstd{,}
       \hlkwc{color} \hlstd{=} \hlstr{'Textural Class'}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-261-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggtern))}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Plotting data onto maps}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(ggmap)}
\hlkwd{library}\hlstd{(rgdal)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: sp\\\#\# rgdal: version: 0.9-1, (SVN revision 518)\\\#\# Geospatial Data Abstraction Library extensions to R successfully loaded\\\#\# Loaded GDAL runtime: GDAL 1.11.0, released 2014/04/16\\\#\# Path to GDAL shared files: C:/Users/aphalo/Documents/R/win-library/3.1/rgdal/gdal\\\#\# GDAL does not use iconv for recoding strings.\\\#\# Loaded PROJ.4 runtime: Rel. 4.8.0, 6 March 2012, [PJ\_VERSION: 480]\\\#\# Path to PROJ.4 shared files: C:/Users/aphalo/Documents/R/win-library/3.1/rgdal/proj}}\end{kframe}
\end{knitrout}


Another extension to package \code{ggplot2} is package \code{ggmap}. Package \code{ggmap} makes it possible to plot data using normal \code{ggplot2} syntax on top of a map. Maps can be easily retrieved from the internet through different services. Some of these services require the user to register and obtain a key for access. As Google Maps do not require such a key for normal resolution maps, we use this service in the examples.

The first step is to fetch the desired map. One can fetch the maps base on any valid Google Maps search term, or by giving the coordinates at the center of the map. Although \code{zoom} defaults to "auto", frequently the best result is obtained by providing this argument. Valid values for \code{zoom} are integers in the range 1 to 20.


\begin{framed}

We will fetch maps from Google Maps. We have disabled the messages, to avoid repeated messages about Google's terms of use.

\begin{description}
\item[Google Maps API Terms of Service:] \url{http://developers.google.com/maps/terms}
\item[Information from URL:] \url{http://maps.googleapis.com/maps/api/geocode/json?address=Europe&sensor=false}
\item[Map from URL:] \url{http://maps.googleapis.com/maps/api/staticmap?center=Europe&zoom=3&size=%20640x640&scale=%202&maptype=terrain&sensor=false}
\end{description}

\end{framed}

We start by fetching and plotting a map of Europe of type  \code{satellite}. We use the default extent \code{panel}, and also the extent \code{device} and \code{normal}. The \code{normal} plot includes axes showing the coordinates, while \code{device} does not show them, while \code{panel} shows axes but the map fits tightly into the drawing area:



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Europe1} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe1)}

\hlkwd{ggmap}\hlstd{(Europe1,} \hlkwc{extent} \hlstd{=} \hlstr{"device"}\hlstd{)}

\hlkwd{ggmap}\hlstd{(Europe1,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.32\textwidth]{figure/pos-plot-maps-21} 
\includegraphics[width=.32\textwidth]{figure/pos-plot-maps-22} 
\includegraphics[width=.32\textwidth]{figure/pos-plot-maps-23} 

}



\end{knitrout}

To demonstrate the option to fetch a map in black and white instead of the default colour version, we use a map of Europe of type \code{terrain}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Europe2} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe2)}

\hlstd{Europe3} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Europe"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{3}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{,}
                  \hlkwc{color}\hlstd{=}\hlstr{"bw"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Europe3)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-31} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-32} 

}



\end{knitrout}

To demonstrate the difference between type \code{roadmap} and the default type \code{terrain}, we use the map of Finland. Note that we search for ``Oulu'' instead of ``Finland'' as Google Maps takes the position of the label ``Finland'' as the center of the map, and clips the northern part. By means of \code{zoom} we override the default automatic zooming onto the city of Oulu.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Finland1} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Oulu"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"terrain"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Finland1)}

\hlstd{Finland2} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Oulu"}\hlstd{,} \hlkwc{zoom}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{maptype}\hlstd{=}\hlstr{"roadmap"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(Finland2)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-41} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-42} 

}



\end{knitrout}

We can even search for a street address, and in this case with high zoom value, we can see the building where one of us works:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{BIO3} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki"}\hlstd{,}
                \hlkwc{zoom}\hlstd{=}\hlnum{18}\hlstd{,}
                \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(BIO3)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-5} 

}



\end{knitrout}

We will now show a simple example of plotting data on a map, first by explicitly giving the coordinates, and in the second example we show how to fetch from Google Maps coordinate values that can be then plotted. We use function \code{geocode}. In one example we use \code{geom\_point} and \code{geom\_text}, while in the second example we use \code{annotate}, but either approach could have been used for both plots:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{viikki} \hlkwb{<-} \hlkwd{get_map}\hlstd{(}\hlstr{"Viikki"}\hlstd{,}
                  \hlkwc{zoom}\hlstd{=}\hlnum{15}\hlstd{,}
                  \hlkwc{maptype}\hlstd{=}\hlstr{"satellite"}\hlstd{)}

\hlstd{our_location} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{lat}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{60.225}\hlstd{,} \hlnum{60.227}\hlstd{),}
                           \hlkwc{lon}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{25.017}\hlstd{,} \hlnum{25.018}\hlstd{),}
                           \hlkwc{label}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"BIO3"}\hlstd{,} \hlstr{"field"}\hlstd{))}
\hlkwd{ggmap}\hlstd{(viikki,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data}\hlstd{=our_location,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=lat,} \hlkwc{x}\hlstd{=lon),}
             \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{data}\hlstd{=our_location,} \hlkwd{aes}\hlstd{(}\hlkwc{y}\hlstd{=lat,} \hlkwc{x}\hlstd{=lon,} \hlkwc{label}\hlstd{=label),}
            \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.3}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)}

\hlstd{our_geocode} \hlkwb{<-} \hlkwd{geocode}\hlstd{(}\hlstr{"Viikinkaari 1, 00790 Helsinki"}\hlstd{)}
\hlkwd{ggmap}\hlstd{(viikki,} \hlkwc{extent} \hlstd{=} \hlstr{"normal"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"point"}\hlstd{,}
           \hlkwc{y}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lat"}\hlstd{],} \hlkwc{x}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lon"}\hlstd{],}
           \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom}\hlstd{=}\hlstr{"text"}\hlstd{,}
           \hlkwc{y}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lat"}\hlstd{],} \hlkwc{x}\hlstd{=our_geocode[} \hlnum{1}\hlstd{,} \hlstr{"lon"}\hlstd{],}
           \hlkwc{label}\hlstd{=}\hlstr{"BIO3"}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlopt{-}\hlnum{0.3}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"yellow"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.47\textwidth]{figure/pos-plot-maps-61} 
\includegraphics[width=.47\textwidth]{figure/pos-plot-maps-62} 

}



\end{knitrout}

Using \code{get\_map} from package \code{ggmap} for drawing a world map is not possible at the time of writing. In addition a worked out example of how to plot shape files, and how to download them from a repository is suitable as our final example. We also show how to change the map projection. The example is adapted from a blog post at \url{http://rpsychologist.com/working-with-shapefiles-projections-and-world-maps-in-ggplot}.

We start by downloading the map data archive files from \url{http://www.naturalearthdata.com} which is available in different layers. We only use three of the available layers: `physical' which describes the coastlines and a grid and bounding box, and `cultural' which gives country borders. We save them in a folder with name `maps', which is expected to already exist. After downloading each file, we unzip it.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{oldwd} \hlkwb{<-} \hlkwd{setwd}\hlstd{(}\hlstr{"./maps"}\hlstd{)}

\hlstd{url_path} \hlkwb{<-}
\hlcom{#  "http://www.naturalearthdata.com/download/110m/"}
  \hlstr{"http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/"}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"physical/ne_110m_land.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_land.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_land.zip"}\hlstd{)}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"cultural/ne_110m_admin_0_countries.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_admin_0_countries.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_admin_0_countries.zip"}\hlstd{)}

\hlkwd{download.file}\hlstd{(}\hlkwd{paste}\hlstd{(url_path,}
                    \hlstr{"physical/ne_110m_graticules_all.zip"}\hlstd{,}
                    \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{),} \hlstr{"ne_110m_graticules_all.zip"}\hlstd{)}
\hlkwd{unzip}\hlstd{(}\hlstr{"ne_110m_graticules_all.zip"}\hlstd{)}

\hlkwd{setwd}\hlstd{(oldwd)}
\end{alltt}
\end{kframe}
\end{knitrout}

We list the layers that we have downloaded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ogrListLayers}\hlstd{(}\hlkwc{dsn}\hlstd{=}\hlstr{"./maps"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ne_110m_admin_0_countries" 
## [2] "ne_110m_graticules_1"      
## [3] "ne_110m_graticules_10"     
## [4] "ne_110m_graticules_15"     
## [5] "ne_110m_graticules_20"     
## [6] "ne_110m_graticules_30"     
## [7] "ne_110m_graticules_5"      
## [8] "ne_110m_land"              
## [9] "ne_110m_wgs84_bounding_box"
## attr(,"driver")
## [1] "ESRI Shapefile"
## attr(,"nlayers")
## [1] 9
\end{verbatim}
\end{kframe}
\end{knitrout}

Next we read the layer for the coastline, and use \code{fortify} to convert it into a data frame. We also create a second version of the data using the Robinson projection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wmap} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlkwc{dsn}\hlstd{=}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_land"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_land"
## with 127 features and 2 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{wmap.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(wmap)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{wmap_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(wmap,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{wmap_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(wmap_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

We do the same for country borders,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{countries} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_admin_0_countries"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_admin_0_countries"
## with 177 features and 63 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{countries.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(countries)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{countries_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(countries,} \hlkwd{CRS}\hlstd{(}\hlstr{"+init=ESRI:54030"}\hlstd{))}
\hlstd{countries_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(countries_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

and for the graticule at $15^\circ$ intervals, and the bounding box.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{grat} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_graticules_15"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_graticules_15"
## with 35 features and 5 fields
## Feature type: wkbLineString with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{grat.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(grat)}
\hlstd{grat_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(grat,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{grat_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(grat_robin)}

\hlstd{bbox} \hlkwb{<-} \hlkwd{readOGR}\hlstd{(}\hlstr{"./maps"}\hlstd{,} \hlkwc{layer}\hlstd{=}\hlstr{"ne_110m_wgs84_bounding_box"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## OGR data source with driver: ESRI Shapefile 
## Source: "./maps", layer: "ne_110m_wgs84_bounding_box"
## with 1 features and 2 fields
## Feature type: wkbPolygon with 2 dimensions
\end{verbatim}
\begin{alltt}
\hlstd{bbox.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(bbox)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\begin{alltt}
\hlstd{bbox_robin} \hlkwb{<-} \hlkwd{spTransform}\hlstd{(bbox,} \hlkwd{CRS}\hlstd{(}\hlstr{"+proj=robin"}\hlstd{))}
\hlstd{bbox_robin.data} \hlkwb{<-} \hlkwd{fortify}\hlstd{(bbox_robin)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Regions defined for each Polygons}}\end{kframe}
\end{knitrout}

Now we plot the world map of the coastlines, on a longitude and latitude scale, as a \code{ggplot} using \code{geom\_polygon}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(wmap.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (longlat)"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-270-1} 

}



\end{knitrout}

There is one noticeable problem in the map shown above: the Caspian sea is missing. We need to use aesthetic \code{fill} and a manual scale to correct this.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(wmap.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=hole))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (longlat)"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"#262626"}\hlstd{,} \hlstr{"#e6e8ed"}\hlstd{),}
                    \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-271-1} 

}



\end{knitrout}




When plotting a map using a projection, many default elements of the \code{ggplot} theme need to be removed, as the data is no longer in units of degrees of latitude and longitude and axes and their labels are no longer meaningful.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{theme_map_opts} \hlkwb{<-}
  \hlkwd{list}\hlstd{(}\hlkwd{theme}\hlstd{(}\hlkwc{panel.grid.minor} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{panel.grid.major} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{panel.background} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{plot.background} \hlstd{=} \hlkwd{element_rect}\hlstd{(}\hlkwc{fill}\hlstd{=}\hlstr{"#e6e8ed"}\hlstd{),}
             \hlkwc{panel.border} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.line} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.text.y} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.ticks} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.title.x} \hlstd{=} \hlkwd{element_blank}\hlstd{(),}
             \hlkwc{axis.title.y} \hlstd{=} \hlkwd{element_blank}\hlstd{()))}
\end{alltt}
\end{kframe}
\end{knitrout}

Finally we plot all the layers using the Robinson projection. This is still a \code{ggplot} and consequently one can plot data on top of the map, being aware of the transformation of the scale needed to make the data location match locations in a map using a certain projection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(bbox_robin.data,} \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group))} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{fill}\hlstd{=}\hlstr{"white"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_polygon}\hlstd{(}\hlkwc{data}\hlstd{=countries_robin.data,}
               \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,}
                   \hlkwc{fill}\hlstd{=hole))} \hlopt{+}
  \hlkwd{geom_path}\hlstd{(}\hlkwc{data}\hlstd{=countries_robin.data,}
            \hlkwd{aes}\hlstd{(long,lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=hole),}
            \hlkwc{color}\hlstd{=}\hlstr{"white"}\hlstd{,}
            \hlkwc{size}\hlstd{=}\hlnum{0.3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_path}\hlstd{(}\hlkwc{data}\hlstd{=grat_robin.data,}
            \hlkwd{aes}\hlstd{(long, lat,} \hlkwc{group}\hlstd{=group,} \hlkwc{fill}\hlstd{=}\hlkwa{NULL}\hlstd{),}
            \hlkwc{linetype}\hlstd{=}\hlstr{"dashed"}\hlstd{,}
            \hlkwc{color}\hlstd{=}\hlstr{"grey50"}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=}\hlstr{"World map (Robinson)"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_equal}\hlstd{()} \hlopt{+}
  \hlstd{theme_map_opts} \hlopt{+}
  \hlkwd{scale_fill_manual}\hlstd{(}\hlkwc{values}\hlstd{=}\hlkwd{c}\hlstd{(}\hlstr{"black"}\hlstd{,} \hlstr{"white"}\hlstd{),}
                    \hlkwc{guide}\hlstd{=}\hlstr{"none"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-274-1} 

}



\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggmap))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{rgdal))}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Advanced topics}

\section{Using \code{plotmath} expressions}

Expressions are very useful but rather tricky to use because the syntax is unusual. In \code{ggplot} one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined with \code{labs}) the expressions have to entered explicitly, or saved as such into a variable, and the variable supplied as argument. When plotting expressions using \code{geom\_text} expression arguments should be supplied as character strings and the optional argument \code{parse=TRUE} used to tell the geom to interpret the labels as expressions. We will go through a few useful examples.

We will revisit the example from the previous section, but now using subscripted Greek $\alpha$ for labels. In this example we use as subscripts numeric values from another variable in the same dataframe.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data}\hlopt{$}\hlstd{greek.label} \hlkwb{<-} \hlkwd{paste}\hlstd{(}\hlstr{"alpha["}\hlstd{, my.data}\hlopt{$}\hlstd{x,} \hlstr{"]"}\hlstd{,} \hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{)}
\hlstd{(fig} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x,y,}\hlkwc{label}\hlstd{=greek.label))} \hlopt{+}
   \hlkwd{geom_text}\hlstd{(}\hlkwc{angle}\hlstd{=}\hlnum{45}\hlstd{,} \hlkwc{hjust}\hlstd{=}\hlnum{1.2}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)} \hlopt{+} \hlkwd{geom_point}\hlstd{())}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-276-1} 

}



\end{knitrout}

Setting an axis label with superscripts. The easiest way to deal with spaces is to use `~' or `~~'. One can connect pieces that would otherwise cause errors using `*'. If we

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{x}\hlstd{=}\hlkwd{expression}\hlstd{(alpha),} \hlkwc{y}\hlstd{=}\hlkwd{expression}\hlstd{(Speed}\hlopt{~~}\hlstd{(m}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-277-1} 

}



\end{knitrout}

It is possible to store expressions in variables.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.title} \hlkwb{<-} \hlkwd{expression}\hlstd{(}\hlkwd{sqrt}\hlstd{(alpha[}\hlnum{1}\hlstd{]} \hlopt{+} \hlkwd{frac}\hlstd{(beta, gamma)))}
\hlstd{fig} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{title}\hlstd{=my.title)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-278-1} 

}



\end{knitrout}

Annotations are plotted ignoring the default aesthetics, but still make use of geoms, so labels for annotations also have to be supplied as character strings and parsed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlstr{"text"}\hlstd{,} \hlkwc{label}\hlstd{=}\hlstr{"sqrt(alpha[1] + frac(beta, gamma))"}\hlstd{,}
           \hlkwc{y}\hlstd{=}\hlnum{2.5}\hlstd{,} \hlkwc{x}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{size}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{colour}\hlstd{=}\hlstr{"red"}\hlstd{,} \hlkwc{parse}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-279-1} 

}



\end{knitrout}

We discuss how to use expressions as facet labels in section \ref{sec:facet}.

\subsection{Inset plots using same data}

Example from \url{http://stackoverflow.com/questions/20708012/embedding-a-subplot-in-ggplot-ggsubplot}, authored by Baptiste Auguié \url{http://baptiste.github.io/}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{d} \hlkwb{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{sort}\hlstd{(}\hlkwd{rlnorm}\hlstd{(}\hlnum{300}\hlstd{)),}
               \hlkwc{y} \hlstd{=} \hlkwd{sort}\hlstd{(}\hlkwd{rlnorm}\hlstd{(}\hlnum{300}\hlstd{)),}
               \hlkwc{grp} \hlstd{=} \hlnum{1}\hlstd{)}

\hlstd{main} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(d,} \hlkwd{aes}\hlstd{(x, y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+} \hlkwd{theme_bw}\hlstd{()}

\hlstd{sub} \hlkwb{<-} \hlstd{main} \hlopt{+}
  \hlkwd{geom_rect}\hlstd{(}\hlkwc{data}\hlstd{=d[}\hlnum{1}\hlstd{,],}
            \hlkwc{xmin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{ymin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{xmax}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{5}\hlstd{,}
            \hlkwc{fill}\hlstd{=}\hlstr{"grey50"}\hlstd{,} \hlkwc{alpha}\hlstd{=}\hlnum{0.3}\hlstd{)}
\hlstd{sub}\hlopt{$}\hlstd{layers} \hlkwb{<-} \hlkwd{rev}\hlstd{(sub}\hlopt{$}\hlstd{layers)} \hlcom{# draw rect below}

\hlstd{main} \hlopt{+}
  \hlkwd{annotation_custom}\hlstd{(}\hlkwd{ggplotGrob}\hlstd{(sub),}
                    \hlkwc{xmin}\hlstd{=}\hlnum{2.5}\hlstd{,} \hlkwc{xmax}\hlstd{=}\hlnum{5}\hlstd{,}
                    \hlkwc{ymin}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{ymax}\hlstd{=}\hlnum{2.5}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{5}\hlstd{))} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{4}\hlstd{))}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 28 rows containing missing values (geom\_point).}}\end{kframe}

{\centering \includegraphics[width=.95\textwidth]{figure/pos-unnamed-chunk-280} 

}



\end{knitrout}

\subsection{Adding elements using \code{grid}}

\code{ggplot2} creates the plots using package \code{grid}, consequently it is possible to manipulate \code{ggplot} objects using \code{grid} functions. Here we present a very simple example. For more information on using \code{grid} together with \code{ggplot2} please see \cite{Murriel2009}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{qplot}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{1}\hlstd{),} \hlkwc{vp}\hlstd{=}\hlkwd{viewport}\hlstd{(}\hlkwc{height}\hlstd{=}\hlnum{0.8}\hlstd{))}
\hlkwd{grid.text}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlkwd{unit}\hlstd{(}\hlnum{1}\hlstd{,}\hlstr{"npc"}\hlstd{)} \hlopt{-} \hlkwd{unit}\hlstd{(}\hlnum{1}\hlstd{,}\hlstr{"line"}\hlstd{),}
          \hlkwc{label}\hlstd{=}\hlstr{"I'm (slightly) out of here!"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.64\textwidth]{figure/pos-unnamed-chunk-282-1} 

}



\end{knitrout}

\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x}\hlstd{=}\hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x}\hlstd{=x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun}\hlstd{=dnorm)}
\hlkwd{pdf}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.pdf"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

Encapsulated Postscript output (width and height in inches):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{postscript}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.eps"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{8}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tiff}\hlstd{(}\hlkwc{file}\hlstd{=}\hlstr{"fig1.tiff"}\hlstd{,} \hlkwc{width}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{height}\hlstd{=}\hlnum{800}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{scales))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{plyr))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{Hmisc))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2))}
\hlkwd{try}\hlstd{(}\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{grid))}
\end{alltt}
\end{kframe}
\end{knitrout}



% !Rnw root = r4p.main.Rnw



\chapter{Further reading about R}\label{chap:R:readings}

\section{Temporary list}

%\nocite{*}


\chapter{Build information}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{Sys.info}\hlstd{()}
\end{alltt}
\begin{verbatim}
##                      sysname 
##                    "Windows" 
##                      release 
##                      "7 x64" 
##                      version 
## "build 7601, Service Pack 1" 
##                     nodename 
##                      "MUSTI" 
##                      machine 
##                     "x86-64" 
##                        login 
##                     "aphalo" 
##                         user 
##                     "aphalo" 
##               effective_user 
##                     "aphalo"
\end{verbatim}
\end{kframe}
\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\begin{verbatim}
## R version 3.1.2 Patched (2014-11-11 r66970)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## 
## locale:
## [1] LC_COLLATE=English_United Kingdom.1252 
## [2] LC_CTYPE=English_United Kingdom.1252   
## [3] LC_MONETARY=English_United Kingdom.1252
## [4] LC_NUMERIC=C                           
## [5] LC_TIME=English_United Kingdom.1252    
## 
## attached base packages:
## [1] splines   stats     graphics  grDevices
## [5] utils     datasets  methods   base     
## 
## other attached packages:
## [1] sp_1.0-16       Formula_1.1-2  
## [3] survival_2.37-7 lattice_0.20-29
## [5] splus2R_1.2-0   proto_0.3-10   
## [7] lubridate_1.3.3 knitr_1.8      
## 
## loaded via a namespace (and not attached):
##  [1] acepack_1.3-3.3            
##  [2] chron_2.3-45               
##  [3] cluster_1.15.3             
##  [4] colorspace_1.2-4           
##  [5] data.table_1.9.4           
##  [6] digest_0.6.4               
##  [7] evaluate_0.5.5             
##  [8] foreign_0.8-61             
##  [9] formatR_1.0                
## [10] GGally_0.4.8               
## [11] ggmap_2.3                  
## [12] ggplot2_1.0.0              
## [13] ggtern_1.0.3.2             
## [14] grid_3.1.2                 
## [15] gridExtra_0.9.1            
## [16] gtable_0.1.2               
## [17] highr_0.4                  
## [18] Hmisc_3.14-5               
## [19] labeling_0.3               
## [20] latticeExtra_0.6-26        
## [21] mapproj_1.2-2              
## [22] maps_2.3-9                 
## [23] MASS_7.3-35                
## [24] memoise_0.2.1              
## [25] munsell_0.4.2              
## [26] nnet_7.3-8                 
## [27] photobiology_0.4.6         
## [28] photobiologyFilters_0.1.13 
## [29] photobiologygg_0.1.13      
## [30] photobiologyLEDs_0.1.4     
## [31] photobiologyWavebands_0.1.0
## [32] plyr_1.8.1                 
## [33] png_0.1-7                  
## [34] RColorBrewer_1.0-5         
## [35] Rcpp_0.11.3                
## [36] reshape_0.8.5              
## [37] reshape2_1.4               
## [38] rgdal_0.9-1                
## [39] RgoogleMaps_1.2.0.6        
## [40] rjson_0.2.15               
## [41] RJSONIO_1.3-0              
## [42] rpart_4.1-8                
## [43] scales_0.2.4               
## [44] stringr_0.6.2              
## [45] tools_3.1.2
\end{verbatim}
\end{kframe}
\end{knitrout}

\backmatter

\end{document}
