\chapter{Basic operations on spectra}

\begin{abstract}
  In this chapter we describe the use of a few basic functions, which can be useful when no predifined functions are available for a given operation.
\end{abstract}

%%%%
\section{Task: uniform scaling of a spectrum}\label{sec:binoper}

In R vectorized operators are available, and `recycling' takes places when needed\footnote{Here and in many other examples \code{head} is used to limit the ammount of output to a few lines.}:
<<>>=
head(sun.data$s.e.irrad)
data(sun.data)
head(sun.data$s.e.irrad * 2)
@

Other binary operators can be used in the same way.

%%%%
\section{Task: operations between two spectra}\label{sec:binoper}

If data for two spectra are available for the same wavelength values, then we can still use the built in R math operators. These operators are vectorized, which means that an addition between two vectors adds the elements at each position. A non-sensical example follows:

<<>>=
head(with(sun.data, s.e.irrad^2 / w.length))
@

These operators cannot be used if the walengths in two spectral data sets do not match. In this situation is where functions in package \code{photobiology} come to the rescue by transparently making the two operand spectra compatible by interpolation. The result they return includes all the invididual wavelength values (the set union of the wavelengths). The functions are \code{sum\_spectra}, \code{subt\_spectra}, \code{prod\_spectra}, \code{div\_spectra}, and \code{oper\_spectra}. Here is a very simple hypothetical example:

<<eval=FALSE>>=
out.data <- sum_spectra(spc1$w.length, spc2$w.length, spc1$s.e.irrad, spc2$s.e.irrad)
@

The function \code{oper\_spectra} takes the operator to use as an argument:

<<eval=FALSE>>=
out.data <- oper_spectra(spc1$w.length, spc2$w.length, spc1$s.e.irrad, spc2$s.e.irrad, bin.oper=`+`)
@

and is used to define the functions for the four basic math operators.

\section{Task: trimming a spectrum}

This is basically a subsetting operation, but the function \code{trim\_tails} adds a few `bells and whistles'. The trimming is based on wavelengths, by default the cut points are inserted by interpolation, so that the sspectrum returned includes the limits given as arguments. By default the trimming is done by deleting both spectral irradiance and wavelength values outside the range delinited by the limits, but through parameter \code{fill} the values outside the limits can be replaced any value desired (most commonly \code{NA}or 0.)

<<>>=
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=NULL)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=NA)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=0.0)))
@

If the limits are outside the range of the input spectral data, and \code{fill} is set to a value other than \code{NULL} the output is expanded up to the limits and filled.

<<>>=
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000)))
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000, fill=NA)))
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000, fill=0.0)))
@

\section{Task: conversion from energy to photon base}

The energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ_energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ_energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ_energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ_molenergy}
\label{eq:energy:mol:photons}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ_energy} while \code{as\_quantum\_mol} uses equation \ref{equ_molenergy}. To obtain \umol we multiply by $10^6$:

<<>>=
as_quantum_mol(550, 200) * 1e6
@

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorized, so they can be applied to whole spectra, to convert \wattnm to \molnm:

<<>>=
head(sun.data$s.e.irrad, 10)
s.q.irrad <- with(sun.data, as_quantum_mol(w.length, s.e.irrad))
head(s.q.irrad, 10)
@

\section{Task: conversion from photon to energy base}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

In \cite{aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ_energy} and \ref{equ_molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output is \jmole we multiply by $10^{-3}$ to obtain \kjmole:

<<>>=
as_energy(600, 1) * 1e-3
as_energy(300, 1) * 1e-3
@

Because of vectorization we can also operate on a whole spectrum:
<<>>=
head(sun.data$s.q.irrad, 10)
s.e.irrad <- with(sun.data, as_energy(w.length, s.q.irrad))
head(s.e.irrad, 10)

@


\section{Task: interpolating a spectrum}

The function \code{interpolate\_spectrum} is used internally for interpolating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible.

In this example we generate interpolated data for the range 280~nm to 300~nm at 1~nm steps, by default output values outside the wavelength range of the input are set to \code{NA}s unless a different argument is provided for parameter \code{fill}:

<<>>=
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300))
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300, fill=0.0))
@

\begin{framed}
This function, in its current implementation, always returns
interpolated values, even when the density of wavelengths in the output is less than that in the input.
A future version will \emph{likely} include a parameter for changing this behaviour
to averaging or smoothing.
\end{framed}

\section{Internal-use functions}

The function \code{check\_spectrum} may need to be called by the user if he/she disables automatic sanity checking to increase calculation speed. The family of functions for calculating multipliers are used internally by the package.

The function \code{insert\_hinges} is used internally to insert individual interpolated values to the spectra when needed to recduce errors in calcualtions.

The function \code{integrate\_irradiance} is used internally for intergrating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible, or never. This function makes it possible to work with spectral data on the original pixel wavelengths.

