\chapter{Basic operations on spectra}\label{chap:base}

\begin{abstract}
  In this chapter we describe the use of a few basic functions, which can be useful when no predifined functions are available for a given operation.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<>>=
library(photobiology)
library(photobiologyFilters)
library(photobiologyLeds)
@

%%%%
\section{Introduction: how are example spectra stored}\label{sec:spct:objects}

The suite uses to some exent object-oriented programing. Objects are implemented using ``S3'' classes. For spectra the classes are a specialization of data.table which are in turn a specialization of data.frame. This means that they are compatible with functions that operate on these classes.

The suite defines a ``generic.spct'' class, from which two specialized classes, ``filter.spct'' and ``source.spct'' are derived. Having this class structure allows us to create special methods and operators, which use the same names than the generic ones but take into account the special properties of spectra. Each spectrum object can hold only one spectrum.

Objects of class ``source.spct'' have three components \code{w.length}, \code{s.e.irrad} and \code{s.q.irrad}. They are expected to contain data expresed always in the same units: nm, for \code{w.length}, \wattnm for \code{s.e.irrad}, and \molnm for \code{s.q.irrad}. Objects have a ``comment'' attribute with a textual description.

Objects of class ``filter.spct'' have three components \code{w.length}, \code{Tfr} and \code{Tpc}. They are expected to contain data expresed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Tfr}, and \% for \code{Tpc}. Objects have a ``comment'' attribute with a textual description.

Operators are defined for these objects. These are an easy and simple way of doing calcualtions, but are rather inflexible and performance is expected to be slower than with functions with additonal parameters. The operators are defined so that an operation between two "filter.spct" objects yields another "filter.spct" object, and operation between a "filter.spct" object and a "source.spct", or between two "source.spct" objects yields a "source.spct" object. The object returned contains data only for the overlapping region of wavelengths. The objects do NOT need to have values at the same wavelengths, as interpolation is handled transparently. All four basic math operations are supported with any combination of spectra, and the user is responsible for deciding which calculations make sense and which not. Operations can be concatenated and combined.

The same four operators are also defined for the case when the first term or factor is a spectrum and the second one a numeric vector, possibly of length one. Recycling rules apply. Package \code{phobiologyFilters} makes available many different filter spectra, from which we choose Schott filter GG400. Pacakge \code{photobiology} makes available one example solar spectrum. Using these data we will simulate the filtered solar spectrum.

<<>>=
filtered_sun.dt <- sun.dt * gg400.dt
@

The GG440 data is for internal transmittance. Let's assume an uncoated filter with 9\% reflection accross all wavelength (a gross approximation):

<<>>=
filtered_uncoated_sun.dt <- sun.dt * gg400.dt * (100 - 9) / 100
@

Calculations related to filters will be explained in detail in chapter \ref{chap:filters}. This is just an example of how the operators work.

%%%%
\section{Task: uniform scaling of a spectrum}\label{sec:base:scale}

As noted above operators are available for "generic.scpt", "source.spct", and "filter.spct" objects, and `recycling' takes places when needed\footnote{Here and in many other examples \code{head} is used to limit the ammount of output to a few lines.}:

<<>>=
head(sun.dt)
head(sun.dt * 2)
@

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, but when operating between a spectrum an a numeric value the spectrum should be the first term or factor.

%%%%
\section{Task: simple operations between two spectra}\label{sec:base:simple:opper}

<<>>=
filtered_sun.dt <- ug1.dt * sun.dt
head(filtered_sun.dt)
@

All four basic binary operators (\code{+, -, *, /}) can be used in the same way.

%%%%
\section{Task: operations between two spectra}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can still use the built in R math operators. These operators are vectorized, which means that an addition between two vectors adds the elements at each position. A non-sensical example follows:

<<>>=
head(with(sun.data, s.e.irrad^2 / w.length))
@

These operators cannot be used if the walengths in two spectral data sets do not match. In this situation is where functions in package \code{photobiology} come to the rescue by transparently making the two operand spectra compatible by interpolation. The result they return includes all the invididual wavelength values (the set union of the wavelengths). The functions are \code{sum\_spectra}, \code{subt\_spectra}, \code{prod\_spectra}, \code{div\_spectra}, and \code{oper\_spectra}. Here is a very simple hypothetical example:

<<eval=FALSE>>=
out.data <- sum_spectra(spc1$w.length, spc2$w.length, spc1$s.e.irrad, spc2$s.e.irrad)
@

The function \code{oper\_spectra} takes the operator to use as an argument:

<<eval=FALSE>>=
out.data <- oper_spectra(spc1$w.length, spc2$w.length, spc1$s.e.irrad, spc2$s.e.irrad, bin.oper=`+`)
@

and is used to define the functions for the four basic math operators.

\section{Task: trimming a spectrum}\label{sec:base:trim}

This is basically a subsetting operation, but the function \code{trim\_tails} adds a few `bells and whistles'. The trimming is based on wavelengths, by default the cut points are inserted by interpolation, so that the sspectrum returned includes the limits given as arguments. By default the trimming is done by deleting both spectral irradiance and wavelength values outside the range delinited by the limits, but through parameter \code{fill} the values outside the limits can be replaced any value desired (most commonly \code{NA}or 0.) It is possible to supply only one, or both of \code{low.limit} and \code{high.limit}, depending on the desired trimming.

<<>>=
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=NULL)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=NA)))
head(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, fill=0.0)))
@

If the limits are outside the range of the input spectral data, and \code{fill} is set to a value other than \code{NULL} the output is expanded up to the limits and filled.

<<>>=
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000)))
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000, fill=NA)))
tail(with(sun.data, trim_tails(w.length, s.e.irrad, low.limit=300, high.limit=1000, fill=0.0)))
@

\section{Task: conversion from energy to photon base}\label{sec:base:e2q}

The energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ_energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ_energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ_energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ_molenergy}
\label{eq:energy:mol:photons}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ_energy} while \code{as\_quantum\_mol} uses equation \ref{equ_molenergy}. To obtain \umol we multiply by $10^6$:

<<>>=
as_quantum_mol(550, 200) * 1e6
@

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorized, so they can be applied to whole spectra, to convert \wattnm to \molnm:

<<>>=
head(sun.data$s.e.irrad, 10)
s.q.irrad <- with(sun.data, as_quantum_mol(w.length, s.e.irrad))
head(s.q.irrad, 10)
@

\section{Task: conversion from photon to energy base}\label{sec:base:q2e}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

In \cite{aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ_energy} and \ref{equ_molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output is \jmole we multiply by $10^{-3}$ to obtain \kjmole:

<<>>=
as_energy(600, 1) * 1e-3
as_energy(300, 1) * 1e-3
@

Because of vectorization we can also operate on a whole spectrum:
<<>>=
head(sun.data$s.q.irrad, 10)
s.e.irrad <- with(sun.data, as_energy(w.length, s.q.irrad))
head(s.e.irrad, 10)

@


\section{Task: interpolating a spectrum}\label{sec:base:interpol}

The function \code{interpolate\_spectrum} is used internally for interpolating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible.

In this example we generate interpolated data for the range 280~nm to 300~nm at 1~nm steps, by default output values outside the wavelength range of the input are set to \code{NA}s unless a different argument is provided for parameter \code{fill}:

<<>>=
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300))
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300, fill=0.0))
@

\begin{framed}
This function, in its current implementation, always returns
interpolated values, even when the density of wavelengths in the output is less than that in the input.
A future version will \emph{likely} include a parameter for changing this behaviour
to averaging or smoothing.
\end{framed}

\section{Internal-use functions}\label{sec:base:internal}

The function \code{check\_spectrum} may need to be called by the user if he/she disables automatic sanity checking to increase calculation speed. The family of functions for calculating multipliers are used internally by the package.

The function \code{insert\_hinges} is used internally to insert individual interpolated values to the spectra when needed to recduce errors in calcualtions.

The function \code{integrate\_irradiance} is used internally for intergrating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible, or never. This function makes it possible to work with spectral data on the original pixel wavelengths.

