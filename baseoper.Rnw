<<echo=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(concordance=TRUE)
@

\chapter{Math operators and functions}\label{chap:baseoper}

%\begin{abstract}
%  In this chapter we describe math functions and operators for spectra and wavebands. Many of these are specializations of the generic operators and functions existing in R.
%\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<message=my.debug>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologyFilters)
@

%%%%
\section{Introduction}

The suite uses object-oriented programming for its higher level `user-friendly' syntax. Objects are implemented using ``S3'' classes. The two main distinct kinds of objects are different types of spectra, and wavebands. Spectral objects contain, as their name implies, spectral data. Wavebands contain the information needed to calculate summaries integrating a range of wavelengths, or for convoluting spectral data with a weighting function. In this chapter we do not describe functions for calculating such summaries, but instead we describe the use of the usual math operators and functions with spectra and wavebands.

\section{Operators and operations between two spectra}

\begin{table}
\newcommand{\Nrd}{\textcolor{red}{\small N}}
\newcommand{\Ygrn}{\textcolor{green}{\small Y}}
\caption[Binary operators]{Binary operators and operands. Validity and class of result. All operations marked `\Ygrn' are allowed, those marked `\Nrd' are forbidden and return \code{NA} and issue a warning.}\label{tab:operators}\vspace{0.75ex}
\centering
\begin{tabular}{lcccccll}
\toprule
e1 & \verb|+| & \verb|-| & \verb|*| & \verb|/| & \verb|^| & e2 & result \\
\midrule
cps\_spct & \Ygrn & \Ygrn &\Ygrn  & \Ygrn & \Ygrn & cps\_spct & cps\_spct \\
source\_spct & \Ygrn & \Ygrn &\Ygrn  & \Ygrn & \Ygrn & source\_spct & source\_spct \\
filter\_spct (T) & \Nrd & \Nrd & \Ygrn & \Ygrn  & \Nrd & filter\_spct & filter\_spct \\
filter\_spct (A) & \Ygrn & \Ygrn & \Nrd & \Nrd  & \Nrd & filter\_spct & filter\_spct \\
reflector\_spct & \Nrd & \Nrd & \Ygrn &\Ygrn  & \Nrd & reflector\_spct & reflector\_spct \\
object\_spct & \Nrd & \Nrd & \Nrd & \Nrd &\Nrd & object\_spct & -- \\
response\_spct & \Ygrn & \Ygrn & \Ygrn & \Ygrn & \Nrd & response\_spct & response\_spct \\
chroma\_spct & \Ygrn  & \Ygrn & \Ygrn & \Ygrn & \Ygrn & chroma\_spct & chroma\_spct \\
\midrule
cps\_spct & \Ygrn  & \Ygrn &\Ygrn  & \Ygrn & \Ygrn & numeric & cps\_spct \\
source\_spct & \Ygrn  & \Ygrn &\Ygrn  & \Ygrn & \Ygrn & numeric & source\_spct \\
filter\_spct & \Ygrn  &\Ygrn  & \Ygrn &\Ygrn  & \Ygrn & numeric & filter\_spct \\
reflector\_spct & \Ygrn &\Ygrn  &\Ygrn  &\Ygrn  & \Ygrn & numeric & reflector\_spct \\
object\_spct & \Nrd & \Nrd & \Nrd & \Nrd &\Nrd & numeric & -- \\
response\_spct & \Ygrn  & \Ygrn  & \Ygrn  & \Ygrn  & \Ygrn & numeric & response\_spct \\
chroma\_spct & \Ygrn & \Ygrn  & \Ygrn & \Ygrn  & \Ygrn & numeric & chroma\_spct \\
\midrule
source\_spct & \Nrd & \Nrd & \Ygrn &\Ygrn  & \Nrd & response\_spct & response\_spct \\
source\_spct & \Nrd & \Nrd & \Ygrn  & \Ygrn  & \Nrd & filter\_spct (T) & source\_spct \\
source\_spct & \Nrd & \Nrd & \Ygrn  & \Ygrn & \Nrd & filter\_spct (A) & source\_spct \\
source\_spct & \Nrd & \Nrd & \Ygrn  & \Ygrn  & \Nrd & reflector\_spct & source\_spct \\
source\_spct & \Nrd & \Nrd &\Nrd  & \Nrd & \Nrd & object\_spct & -- \\
source\_spct & \Nrd & \Nrd &\Ygrn  & \Nrd & \Nrd & waveband (no BSWF) & source\_spct \\
source\_spct & \Nrd & \Nrd &\Ygrn  & \Nrd & \Nrd & waveband (BSWF) & source\_spct \\
\bottomrule
\end{tabular}
\end{table}

All operations\index{mathematical operators}\index{spectral data!mathematical operations} with spectral objects affect only the required components listed in Table \ref{tab:operators}, redundant components are always deleted\footnote{e.g.\ equivalent quantities expressed in different types of units, such as spectral energy irradiance and spectral photon irradiance}, while unrecognized components, including all factors and character variables, are preserved only when one of the operands is a numeric vector of any length. There will be seldom need to add numerical components to spectral objects, and the user should take into account that the paradigm of the suite is that data from each spectral measurement is stored as a separate object. However, it is allowed, and possibly useful to have factors as components with levels identifying different bands, or color vectors with RGB values. Such ancillary information is useful for presentation and plotting and can be added with functions described in Chapter \ref{chap:plot}. Exceptionally, objects can contain spectral data from several measurements and an additional factor indexing them. Such objects cannot be directly used with operators and summary functions, but can be a convenient format for storing related spectra.

Binary maths operators  (\verb|+|, \verb|-|, \verb|*|, \verb|/|), and unary math operators (\verb|+|, \verb|-|) are defined for spectral objects as well functions (\verb|log|, \verb|log|10,\verb|sqrt|). Using operators is an easy and familiar way of doing calculations, but operators are rather inflexible (they can take at most two arguments, the operands) and performance is usually slower than with functions with additional parameters that allow optimizing the algorithm. Which operations are legal between different combinations of operands depends on the laws of Physics, but in cases in which exceptions might exist, they are allowed. This means that some mistakes can be prevented, but other may happen either with a warning or silently. So, although a class system provides a safer environment for calculations, it is not able to detect all possible `nonsensical' calculations. The user must be aware that sanity checks and good understanding of the algorithms are still a prerequisite for reliable results.

Table \ref{} list the available operators and the operands accepted as legal, together with the class of the objects returned. Only in extreme cases errors will be triggered, in most cases when errors occur an operation between two \code{reflector\_spct} yields a \code{reflector\_spct} object, and operations between a \code{filter\_spct} object and a \code{source\_spct}, between a \code{reflector\_spct} and a \code{source\_spct}, or between two \code{source\_spct} objects yield \code{source\_spct} objects. The object returned contains data only for the overlapping region of wavelengths. The objects do NOT need to have values at the same wavelengths, as interpolation is handled transparently. All four basic maths operations are supported with any combination of spectra, and the user is responsible for deciding which calculations make sense and which not. Operations can be concatenated and combined. The unary negation operator is also implemented.

We can convolute the emission spectrum of a light source and the transmittance spectrum of a filter by simply multiplying them.

<<>>=
sun.spct * polyester.spct
@

\section{Operators and operations between a spectrum and a numeric vector}

The same four basic math operators plus power (`\verb|^|') are defined for operations between a spectrum and a numeric vector, possibly of length one. Recycling rules apply for the numeric vector. Normal R type conversions also take place, so a logical vector can substitute for a numeric oneÂ´. These operations do not alter \code{w.length}, just the other \textit{required} components such as spectral irradiance and transmittance. The optional components are deleted as they can be recalculated if needed. Unrecognized `user' components are left unchanged.

For example we can divide a spectrum by a numeric value (a vector of length 1, which gets recycle). The value returned is a spectral object of the same type as the spectral argument.

<<>>=
sun.spct / 2
2 * sun.spct
sun.spct * 2
@

\section{Math functions taking a spectrum as argument}

Logarithms\index{mathematical functions}\index{spectral data!mathematical functions} (\code{log, log10}), square root (\code{sqrt}) and exponentiation (\code{exp}) are defined for spectra. These functions are not applied on \code{w.length}, but instead to the other mandatory component \code{s.e.irrad}, \code{Rfr} or \code{Tfr}. Any optional numeric components are discarded. Other user-supplied components remain unchanged.

<<>>=
log10(sun.spct)
@

\section{Task: Simulating spectral irradiance under a filter}

Package \pkg{phobiologyFilters} makes available many different filter spectra, from which we choose Schott filter GG400. Package \pkg{photobiology} makes available one example solar spectrum. Using these data we will simulate the filtered solar spectrum.

<<>>=
sun.spct * schott.mspct$GG400
@

The GG440 data is for internal transmittance, consequently the results above would be close to the truth only for filters treated with an anti-reflection multicoating. Let's assume a filter with 9\% reflectance across all wavelengths (a coarse approximation for uncoated glass):

<<>>=
sun.spct * schott.mspct$GG400 * (100 - 9) / 100
@

Calculations related to filters will be explained in detail in chapter \ref{chap:filters}. This is just an example of how the operators work, even when, as in this example, the wavelength values do not coincide between the two spectra.

%%%%
\section{Task: Uniform scaling of a spectrum}\label{sec:base:scale}

As noted above operators are available for \code{generic\_spct}, \code{source\_spct}, \code{filter\_spct} and \code{reflector\_spct} objects, and `recycling' takes place when needed:

<<>>=
sun.spct
sun.spct * 2
@

All four basic binary operators (\code{+, -, *, /}) can be used in the same way. By default all calculations are done using energy based units, and only values in these units returned. If the operands need conversion, they are silently converted before applying the operator. The default behaviour can be switched into doing operations and returning values in photon-based units by setting an R option, using the normal R \code{options} mechanism.

%%%%
\subsection{Task: Arithmetic operations within one spectrum}\label{sec:base:internal}

As spectral objects behave in many respects as data frames it is possible to do calculations involving columns as usual, e.g.\ using \code{with} or explicit selectors. A non-nonsensical example follows using R syntax on a data frame, returning a vector.

Using data frame syntax on a data frame, data table or spectral object, returning a vector:

<<eval=FALSE>>=
# not run
sun.spct$s.e.irrad^2 / sun.spct$w.length
@

<<eval=FALSE>>=
# not run
with(sun.spct, s.e.irrad^2 / w.length)
@


\subsection{Task: Using operators on underlying vectors}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can simply use the built in R math operators on the component vectors. These operators are vectorised, which means that an addition between two vectors adds the elements at the same index position in the two vectors with data, in this case for two different spectra.

However, we can achieve the same result, with simpler syntax, using spectral objects and the corresponding operators.

<<>>=
sun.spct + sun.spct
@

<<>>=
e2q(sun.spct + sun.spct)
@

In both cases only spectral energy irradiance is calculated during the summing operation, while in the second example, it is simple to convert the returned spectral energy irradiance values into spectral photon irradiance. The class of the returned spectrum depends on the classes of the operands.  In this case returned objects are \code{source\_spct}.

The function \code{oper\_spectra} takes the operator to use as an argument, and this abstraction both simplifies the package code, and also makes it easy for users to add other operators if needed:

<<eval=FALSE>>=
# not run
out.data <- oper_spectra(spc1$w.length, spc2$w.length,
                         spc1$s.e.irrad, spc2$s.e.irrad,
                         bin.oper=`^`)
@

and yields one spectrum to a power of a second one. Such additional functions are not predefined, as I cannot think of any use for them. \code{oper\_spectra} is used internally to define the functions for the four basic maths operators, and the corresponding operators.

\subsection{Task: conversion from energy to photon base}\label{sec:base:e2q}

\begin{framed}
\ilAttention{} The\index{spectral data!energy to photon base conversion}\index{spectral data!photon to energy base conversion} energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ:energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ:energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ:energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ:molenergy}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.
\end{framed}

\subsubsection{\code{numeric} vectors}

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ:energy} while \code{as\_quantum\_mol} uses equation \ref{equ:molenergy}. To obtain \umol we multiply by $10^6$:

<<>>=
as_quantum_mol(550, 200) * 1e6
@

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorised, so they can be applied to whole spectra (when data are available as vectors), to convert \wattnm to \molnm:

<<>>=
head(sun.spct$s.e.irrad, 10)
s.q.irrad <- with(sun.spct,
                  as_quantum_mol(w.length, s.e.irrad))
head(s.q.irrad, 10)
@

\subsubsection{\code{source\_spct} objects}

Once again, easiest is to use spectral objects. The default is to add \code{s.q.irrad} to the source spectrum, unless it is already present in the object in which case values are not recalculated. It can also be used as a roundabout way of removing a \code{s.e.irrad} column, which could be useful in some cases.

<<>>=
e2q(sun.spct, byref = FALSE)
@

\code{e2q} has a parameter \code{action}, with default \code{"add"}. Another valid argument value is \code{"replace"}.

<<>>=
sun.spct
e2q(sun.spct, "replace", byref = FALSE)
@

\subsubsection{\code{response\_spct} objects}

In the case of response spectra expressed per energy unit, as the energy unit is a divisor, the conversion is done with the inverse of the factor in equation \ref{equ:energy}. Although the method name is \code{e2q} as for \code{source\_spct} objects, the appropriate conversion is applied.

\subsection{Task: conversion from photon to energy base}\label{sec:base:q2e}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

\subsubsection{\code{numeric} vectors}

In \cite{Aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ:energy} and \ref{equ:molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output from \code{as\_energy} is expressed in \jmole we multiply the result by $10^{-3}$ to obtain \kjmole:

<<>>=
as_energy(600, 1) * 1e-3
as_energy(300, 1) * 1e-3
@

Because of vectorization we can also operate on a whole spectrum:

<<>>=
s.e.irrad <- with(sun.data, as_energy(w.length, s.q.irrad))
@

\subsubsection{\code{source\_spct} objects}

Function \code{q2e} is the reverse of \code{e2q}, converting spectral photon irradiance in \molnm to spectral energy irradiance in \wattnm . It can also be used as a roundabout way of removing a \code{s.e.irrad} column, which could be useful in some cases.

<<>>=
q2e(sun.spct, "replace", byref = FALSE)
@

As we have seen above by default \code{q2e} and \code{e2q} return a modified copy of the spectrum as a new object. This is safe, but inefficient in use of memory and computing resources. We first copy the data to a new object, and delete the \code{s.e.irrad} variable, so that we can test the use of the functions by reference.
When parameter \code{byref} is given \code{TRUE} as argument the original spectrum is modified.

<<>>=
my_sun.spct <- sun.spct
q2e(my_sun.spct, byref = TRUE)
@

\subsubsection{\code{response\_spct} objects}

In the case of response spectra expressed per energy unit, as the energy unit is a divisor, the conversion is done with the inverse of the factor in equation \ref{equ:energy}. Although the method name is \code{q2e} as for \code{source\_spct} objects, the appropriate conversion is applied.

\subsubsection{Task: Using options to change default behaviour of maths operators and functions}\label{sec:oper:options}

Table \ref{tab:options} lists all the recognized options\index{R options}, and their default values. Within the suite all functions have a default value which is used when the options are undefined. Options are set using base R's function \code{options}, and queried with functions \code{options} and \code{getOption}. Using options can result in more compact and terse code, but the user should clearly document the use of non-default values for options to avoid surprising the reader of the code.

\begin{table}
\caption[Options]{Options affecting calculations by functions and operators in the \PB package and their possible values. Options controlling the printing of the returned values are also listed.\label{tab:options}}\vspace{0.75ex}

\centering
\begin{footnotesize}
\begin{tabular}{lll}
\toprule
\textbf{Option} & \textbf{default} & \textbf{function} \\
\midrule
\textbf{Base R} & & \\
\addlinespace
digits & 7 & $d - 3$ used by \code{summary} \\
\midrule
\textbf{Package \pkg{tibble}} & & \\
\addlinespace
tibble.print\_max & $n_\mathrm{max}$ = 20 & nrow(\emph{spct}) $> n_\mathrm{max}$ print $n_\mathrm{min}$ lines \\
tibble.print\_min & $n_\mathrm{min}$ = 10 & nrow(\emph{spct}) $> n_\mathrm{max}$ print $n_\mathrm{min}$ lines \\
\midrule
\textbf{R4photobioloy suite} & & \\
\addlinespace
photobiology.radiation.unit & \code{"energy"} & output (\wattnm) \\
                            & \code{"photon"} & output (\molnm) \\
photobiology.filter.qty & \code{"transmittance"} & output ($/1$) \\
                        & \code{"absorptance"} & output ($/1$) \\
                        & \code{"absorbance"} & output (a.u. $\log_10$ base) \\
photobiology.use.hinges & \code{NULL} & guess automatically \\
                        & \code{TRUE} & do not insert hinges \\
                        & \code{FALSE} & do insert hinges \\
photobiology.auto.hinges.limit & 0.5 & wavelength step (nm) \\
photobiology.waveband.trim & \code{TRUE} & trim or exclude \\
photobiology.use.cached.mult & \code{FALSE} & cache intermediate results or not \\
photobiology.verbose & \code{FALSE} & give verbose output or not \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}

The behaviour of the operators\index{operators!behaviour} defined in this package depends on the value of two global options. If we would like the operators to
operate on spectral photon irradiance and return spectral photon irradiance instead of spectral energy irradiance,
this behaviour can be set, and will remain active until unset or reset.

<<>>=
options(photobiology.radiation.unit = "photon")
sun.spct * UVB()
options(photobiology.radiation.unit = "energy")
sun.spct * UVB()
@

\begin{framed}
\ilAttention{} For filters, an option controls whether transmittance, the default, or absorbance is use in the operations, and the controls the returned quantity. It is important to remember that absorbance, $A$, is always expressed on a logarithmic scale, while transmittance, $T$, is always expressed on a linear scale. So to simulate the effect of stacking two layers of polyester film, we need to sum, or in this case as there are two layers of the same material, multiply by two the spectral absorbance values, while we need to multiply the spectral transmittances of stacked filters, or use a power when the layers are identical.
\end{framed}

<<>>=
options(photobiology.filter.qty = "absorbance")
polyester.spct * 2
options(photobiology.filter.qty = "transmittance")
polyester.spct ^ 2
@

Either option can be unset, by means of the \code{NULL} value\footnote{If you are planning to continue working through the examples in later sections, do reset the options as shown in this chunk, as otherwise, the results of later calculations will differ from those shown.}.
<<>>=
options(photobiology.radiation.unit = NULL)
options(photobiology.filter.qty = NULL)
@

\sloppy
The proper use of trimming of wavebands is important, and option \code{photobiology.waveband.trim} makes changing the behaviour of the \code{trim\_spct} function and other functions accepting wavebands easier. The need to carefully assess the validity of trimming and how it can affect the interpretation of results is further discussed in Chapter \ref{chap:uw:irrad} and Chapter \ref{chap:wt:irrad}.

Other options affect the optimization of performance vs.\ precision of calculations and can be useful especially when processing huge numbers of spectra. Some options defined in base R and package \pkg{dplyr} affect printing of output (Table \ref{tab:options}).

\section{Wavebands}\label{sec:wb:objects}

\subsection{How are wavebands stored?}

Wavebands are derived from R lists. All valid R operations for lists can be also used with \code{waveband} objects. However, there are \code{waveband}-specific specializations of generic R methods.

\subsection{Operators and functions}

Multiplying any spectrum by an un-weighted waveband, is equivalent to trimming with \code{fill} set to \code{NA} (see section \ref{sec:base:trim}.

<<>>=
is_effective(UVA())
sun.spct * UVA()
@

Multiplying a \code{source\_spct} object by a weighted waveband convolutes the spectrum with weights, yielding effective spectral irradiance.

<<>>=
is_effective(CIE())
sun.spct * CIE()
@

<<>>=
try(detach(package:photobiologyFilters))
try(detach(package:photobiologyWavebands))
try(detach(package:photobiology))
@
