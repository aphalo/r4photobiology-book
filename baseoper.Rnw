\chapter{Basic operations on spectra}\label{chap:base}

\begin{abstract}
  In this chapter we describe the use of a few basic functions, which can be useful when no predefined functions are available for a given operation.
\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<>>=
library(photobiology)
library(photobiologyFilters)
library(photobiologyLEDs)
@

%%%%
\section{Introduction}\label{sec:spct:objects}

\subsection{How are example spectra stored?}

The suite uses to some extent object-oriented programming. Objects are implemented using ``S3'' classes. For spectra the classes are a specialization of data.table which are in turn a specialization of data.frame. This means that they are compatible with functions that operate on these classes.

\sloppy
The suite defines a ``generic.spct'' class, from which two specialized classes, ``filter.spct'' and ``source.spct'' are derived. Having this class structure allows us to create special methods and operators, which use the same names than the generic ones but take into account the special properties of spectra. Each spectrum object can hold only one spectrum.

Objects of class ``source.spct'' have three components \code{w.length}, \code{s.e.irrad} and \code{s.q.irrad}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, \wattnm for \code{s.e.irrad}, and \molnm for \code{s.q.irrad}. Objects have a ``comment'' attribute with a textual description.

Objects of class ``filter.spct'' have three components \code{w.length}, \code{Tfr} and \code{Tpc}. They are expected to contain data expressed always in the same units: nm, for \code{w.length}, a fraction of one for \code{Tfr}, and \% for \code{Tpc}. Objects have a ``comment'' attribute with a textual description.

\subsection{What operators are available for operations between spectra?}

Operators are defined for these objects. These are an easy and simple way of doing calculations, but are rather inflexible and performance is expected to be slower than with functions with additional parameters. The operators are defined so that an operation between two "filter.spct" objects yields another "filter.spct" object, and operation between a "filter.spct" object and a "source.spct", or between two "source.spct" objects yields a "source.spct" object. The object returned contains data only for the overlapping region of wavelengths. The objects do NOT need to have values at the same wavelengths, as interpolation is handled transparently. All four basic maths operations are supported with any combination of spectra, and the user is responsible for deciding which calculations make sense and which not. Operations can be concatenated and combined. The unary negation operator is also implemented.

\subsection{What operators are available for operations between spectra and numeric vectors?}

The same four operators plus power (`\verb|^|') are defined for the case when the first term or factor is a spectrum and the second one a numeric vector, possibly of length one. Recycling rules apply. These operations do not alter \code{w.length}, just the other components such as spectral irradiance and transmittance.

\subsection{What functions are available for operations between spectra?}

Logarithms (\code{log, log10}), square root (\code{sqrt}) and exponentiation (\code{exp}) are defined for spectra. These functions are not applied on \code{w.length}, but instead on the other components such as spectral irradiance and spectral transmittance.

\subsection{What `summary' functions are available for spectra?}

The R functions \code{summary, print} work in their predefined form, however, there are special versions of \code{range, min, max} that when applied to spectra return values corresponding to wavelengths, two generic functions defined in the suite give additional summaries of spectra \code{spread, midpoint}.

\subsection{Examples}

Package \code{phobiologyFilters} makes available many different filter spectra, from which we choose Schott filter GG400. Package \code{photobiology} makes available one example solar spectrum. Using these data we will simulate the filtered solar spectrum\footnote{Here and in many other examples \code{head} is used to limit the amount of output to a few lines.}.

<<>>=
filtered_sun.spct <- sun.spct * gg400.dt
head(filtered_sun.spct)
@

The GG440 data is for internal transmittance. Let's assume a filter with 9\% reflection across all wavelengths (a coarse approximation):

<<>>=
filtered_uncoated_sun.spct <- sun.spct * gg400.dt * (100 - 9) / 100
head(filtered_uncoated_sun.spct)
@

Calculations related to filters will be explained in detail in chapter \ref{chap:filters}. This is just an example of how the operators work.

%%%%
\section{Task: uniform scaling of a spectrum}\label{sec:base:scale}

As noted above operators are available for "generic.scpt", "source.spct", and "filter.spct" objects, and `recycling' takes places when needed:

<<>>=
head(sun.spct)
head(sun.spct * 2)
@

All four basic binary operators (\code{+, -, *, /}) can be used in the same way, but when operating between a spectrum an a numeric value the spectrum should be the first term or factor. If an operation on a ``source.spct'' would yield different values for data on energy and photon basis, only the value based on energy data is returned in \code{s.e.irrad} and \code{s.q.irrad} is set to NA.

%%%%
\section{Task: simple operations between two spectra}\label{sec:base:simple:opper}

<<>>=
filtered_sun.spct <- ug1.dt * sun.spct
head(filtered_sun.spct)
@

All four basic binary operators (\code{+, -, *, /}) can be used in the same way.

%%%%
\section{Task: other operations between two spectra}\label{sec:base:binoper}

If data for two spectra are available for the same wavelength values, then we can still use the built in R mat operators. These operators are vectorized, which means that an addition between two vectors adds the elements at each position. A non-nonsensical example follows:

<<>>=
head(with(sun.data, s.e.irrad^2 / w.length))
@

Operations using built-in R operators cannot be done if the wavelengths in two spectral data sets do not match. In this situation is where functions in package \code{photobiology} come to the rescue by transparently making the two operand spectra compatible by interpolation. The result they return includes all the individual wavelength values (the set union of the wavelengths). The functions are \code{sum\_spectra}, \code{subt\_spectra}, \code{prod\_spectra}, \code{div\_spectra}, and \code{oper\_spectra}. Here is a very simple hypothetical example:

<<eval=FALSE, tidy=FALSE>>=
out1.dt <- sum_spectra(spc1$w.length, spc2$w.length,
                       spc1$s.e.irrad, spc2$s.e.irrad)
@

This is what happens under the hood when we execute code like:

<<eval=FALSE>>=
out2.spct <- spc1 + spc2
@

with the difference that in the first case only spectral energy irradiance is calculated, while in the second both spectral energy irradiance and spectral photon irradiance are returned. \code{out1.data} is a "data.table", while the second will be an spectrum of a class dependent on the classes of \code{spc1} and \code{spc2}. Obviously, the second calculation will be slower, but in most cases unnoticeable so.

The function \code{oper\_spectra} takes the operator to use as an argument:

<<eval=FALSE, tidy=FALSE>>=
out.data <- oper_spectra(spc1$w.length, spc2$w.length,
                         spc1$s.e.irrad, spc2$s.e.irrad,
                         bin.oper=`^`)
@

and yields one spectrum to a power of a second one. Such additional functions are not predefined, as I cannot think of any use for them. \code{oper\_spectra} is used internally to define the functions for the four basic maths operators, and the corresponding operators.

\section{Task: trimming a spectrum}\label{sec:base:trim}

This is basically a subsetting operation, but the function \code{trim\_tails} adds a few `bells and whistles'. The trimming is based on wavelengths, by default the cut points are inserted by interpolation, so that the spectrum returned includes the limits given as arguments. By default the trimming is done by deleting both spectral irradiance and wavelength values outside the range delimited by the limits, but through parameter \code{fill} the values outside the limits can be replaced any value desired (most commonly \code{NA}or 0.) It is possible to supply only one, or both of \code{low.limit} and \code{high.limit}, depending on the desired trimming.

<<>>=
head(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300)))
head(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, fill=NULL)))
head(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, fill=NA)))
head(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, fill=0.0)))
@

If the limits are outside the range of the input spectral data, and \code{fill} is set to a value other than \code{NULL} the output is expanded up to the limits and filled.

<<>>=
tail(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, high.limit=1000)))
tail(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, high.limit=1000, fill=NA)))
tail(with(sun.data,
          trim_tails(w.length, s.e.irrad,
                     low.limit=300, high.limit=1000, fill=0.0)))
@

\section{Task: conversion from energy to photon base}\label{sec:base:e2q}

The energy of a quantum of radiation\index{radiation quantum}\index{photon} in a vacuum, \quantum, depends on the wavelength\index{wavelength}, $\lambda$, or frequency\index{frequency}\footnote{Wavelength and frequency are related to each other by the speed of light, according to $\nu = c / \lambda$ where $c$ is speed of light in vacuum. Consequently there are two equivalent formulations for equation \ref{equ_energy}.}, $\nu$,
%
\begin{equation}
\quantum = h \cdot \nu = h \cdot \frac{c}{\lambda} \label{equ_energy}
\end{equation}
%
with the Planck constant\index{Planck constant} $h=6.626\times 10^{-34}$ \jsecond and speed of light in vacuum $c=2.998\times 10^{8}$ \msecond. When dealing with numbers of photons, the equation (\ref{equ_energy}) can be extended by using Avogadro's number\index{Avogadro's number} $N_\mathrm{A}=6.022\times 10^{23}$ mol$^{-1}$. Thus, the energy of one mole of photons, \molequanta, is
%
\begin{equation}
\molequanta = h' \cdot \nu = h' \cdot \frac{c}{\lambda} \label{equ_molenergy}
\label{eq:energy:mol:photons}
\end{equation}
%
with $h'=h\cdot N_\mathrm{A}=3.990\times 10^{-10}$ \Unit{J\,s\,mol^{-1}}.

Function \code{as\_quantum} converts \watt into \textit{number of photons} per square meter per second, and \code{as\_quantum\_mol} does the same conversion but returns \mol. Function \code{as\_quantum} is based on the equation \ref{equ_energy} while \code{as\_quantum\_mol} uses equation \ref{equ_molenergy}. To obtain \umol we multiply by $10^6$:

<<>>=
as_quantum_mol(550, 200) * 1e6
@

The calculation above is for monochromatic light (200 \watt at 550 \Unit{nm}).

The functions are vectorized, so they can be applied to whole spectra, to convert \wattnm to \molnm:

<<>>=
head(sun.data$s.e.irrad, 10)
s.q.irrad <- with(sun.data,
                  as_quantum_mol(w.length, s.e.irrad))
head(s.q.irrad, 10)
@

\section{Task: conversion from photon to energy base}\label{sec:base:q2e}

\code{as\_energy} is the inverse function of \code{as\_quantum\_mol}:

In \cite{aphalo2012} it is written: ``Example 1: red light at 600~nm has about 200 \kjmole, therefore, 1~$\mymu$mol photons has 0.2~J. Example 2: \UVB radiation at 300~nm has about 400 \kjmole, therefore, 1~$\mymu$mol photons has 0.4~J. Equations \ref{equ_energy} and \ref{equ_molenergy} are valid for all kinds of electromagnetic waves.'' Let's re-calculate the exact values---as the output is \jmole we multiply by $10^{-3}$ to obtain \kjmole:

<<>>=
as_energy(600, 1) * 1e-3
as_energy(300, 1) * 1e-3
@

Because of vectorization we can also operate on a whole spectrum:
<<>>=
head(sun.data$s.q.irrad, 10)
s.e.irrad <- with(sun.data, as_energy(w.length, s.q.irrad))
head(s.e.irrad, 10)

@


\section{Task: interpolating a spectrum}\label{sec:base:interpol}

The function \code{interpolate\_spectrum} is used internally for interpolating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible.

In this example we generate interpolated data for the range 280~nm to 300~nm at 1~nm steps, by default output values outside the wavelength range of the input are set to \code{NA}s unless a different argument is provided for parameter \code{fill}:

<<>>=
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300))
with(sun.data,
     interpolate_spectrum(w.length, s.e.irrad, 290:300, fill=0.0))
@

\begin{framed}
This function, in its current implementation, always returns
interpolated values, even when the density of wavelengths in the output is less than that in the input.
A future version will \emph{likely} include a parameter for changing this behaviour
to averaging or smoothing.
\end{framed}

\section{Internal-use functions}\label{sec:base:internal}

The function \code{check\_spectrum} may need to be called by the user if he/she disables automatic sanity checking to increase calculation speed. The family of functions for calculating multipliers are used internally by the package.

The function \code{insert\_hinges} is used internally to insert individual interpolated values to the spectra when needed to reduce errors in calculations.

The function \code{integrate\_irradiance} is used internally for integrating spectra, and accepts spectral data measured at arbitrary wavelengths. Raw data from array spectrometers is not available with a constant wavelength step. It is always best to do any interpolation as late as possible, or never. This function makes it possible to work with spectral data on the original pixel wavelengths.

