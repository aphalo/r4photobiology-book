<<echo=FALSE, cache=FALSE>>=
set_parent('r4p.main.Rnw')
opts_knit$set(concordance=TRUE)
@

\chapter{Astronomy}\label{chap:astronomy}

%\begin{abstract}
%  In this chapter we explain how to code some astronomical computations in R.
%\end{abstract}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:
<<>>=
library(photobiology)
library(lubridate)
library(ggplot2)
library(ggmap)

cache <- TRUE
@

%%%%
\section{Introduction}\label{sec:astro:intro}

This chapter deals with calculations that require times and/or dates as arguments. One could use R's built-in functions for POSIXct but package \code{lubridate} makes working with dates and times, much easier. Package \code{lubridate} defines functions for decoding dates represented as character strings, and for manipulating dates and doing calculations on dates. Each one of the different functions shown in the code chunk below can decode dates in different formats as long as the year, month and date order in the string agrees with the name of the function.

<<>>=
ymd("20140320")
ymd("2014-03-20")
ymd("14-03-20")
ymd("2014-3-20")
ymd("2014/3/20")
dmy("20.03.2014")
dmy("20032014")
mdy("03202014")
@

Similar functions including hours, minutes and seconds are defined by \code{lubridate} as well as functions for manipulating dates, and calculating durations with all the necessary and non-trivial corrections needed for leap years, summer time, and other idiosyncracies of the calendar system.

For astronomical calculations we also need as argument the geographical coordinates. It is, of course, possible to enter latitude and longitude values recorded with a GPS instrument or manually obtained from a map. However, when the location is searchable through Google Maps, it is also possible to obtain the coordinates by means of a query from within R using packages \code{RgoogleMaps}, or package \code{ggmap}, as done here. When inputing coordinate values manually, they should in degrees as numeric values (in other words the fractional part is given as part of floating point number in degrees, and not as separate integers representing minutes and seconds of degree).

<<astro-geocode-1, message=FALSE, cache=cache>>=
geocode("Helsinki")
geocode("Viikinkaari 1, 00790 Helsinki, Finland")
@

%%%%
\section{Task: calculating the length of the photoperiod}\label{sec:astro:photoperiod}

Functions \texttt{day\_length} and \texttt{night\_length} have same parameter signature. They are vectorized for the
\texttt{date} parameter.

Northern hemisphere latitudes are given as positive numbers and Southern hemisphere latitudes are given as negative numbers, in degrees, possibly with decimal fractions. The default date is \texttt{today}.
<<>>=
day_length(lat =  60, lon = 0)
day_length(lat = -60, lon = 0)
@

Longitudes can be given similarly, with East of Greenwich being negative and West of Greenwhich positive.

Function \texttt{geocode} from package \texttt{ggmap} returns suitable values in a \texttt{data.frame} based on search term(s). It uses Google to do the search, so some use restrictions apply.

<<message=FALSE>>=
my.city <- geocode('helsinki')
my.city
@

We can calculate the photoperiod for the current day as

<<>>=
day_length(lon = my.city$lon, lat = my.city$lat)
@

Or also give a date explicitly using functions from package \texttt{lubridate}.

<<>>=
day_length(ymd("2015-06-09", tz = "EET"),
           lon = my.city$lon, lat = my.city$lat)
day_length(dmy("9.6.2015", tz = "EET"),
           lon = my.city$lon, lat = my.city$lat)
@

The complementary function \texttt{night\_length} gives

<<>>=
night_length(ymd("2015-06-09", tz = "EET"),
             lon = my.city$lon, lat = my.city$lat)
@

It is also possible to use a vector of dates, for example created as a sequence in the next chunk using functions from package \texttt{lubridate}.

Default time zone of \texttt{ymd} is UTC or GMT, but one should set the same time zone as will be used for further calculations.

<<>>=
dates <- seq(from = ymd("2015-01-01", tz = "EET"),
             to = ymd("2015-12-31", tz = "EET"),
             by = "7 day")
photoperiods.df <-
  data.frame(date = dates,
             photoperiod = day_length(dates,
                                       lon = my.city$lon,
                                       lat = my.city$lat))
@

The 10 lines at the top of the output are

<<>>=
head(photoperiods.df, 10)
@

A further option described in section \ref{sec:sun:times} allow setting the twilight angle to be used for the day length calculations.

\section{Task: Calculating times of sunrise, solar noon and sunset}\label{sec:sun:times}

Functions \texttt{sunrise\_time}, \texttt{sunset\_time}, and \texttt{noon\_time} have all the same parameter signature.

Default latitude is zero (the Equator), the default longitude is zero (Greenwich), and default time zone for the functions in the \texttt{photobiology} package is \texttt{"UTC"}. Be also aware that for summer dates the times are expressed accordingly. In the examples below this can be recognized for example, by the time zone being reported as EEST instead of EET for Eastern Europe.

The default for \texttt{date} is the current day in time zone UTC.

<<>>=
sunrise_time(lat = 60)
@

Both latitude and longitude can be supplied, but be aware that if the returned value is desired in the local time coordinates, the time zone should match the longitude.

<<>>=
sunrise_time(today(tz = "UTC"), lat = 60, lon = 0, tz = "UTC")
sunrise_time(today(tz = "EET"), lat = 60, lon = 25, tz = "EET")
@

Finally the angle used in the twilight calculation can be supplied, either as the name of a standard definition, or as an angle in degrees (negative for sun positions below the horizon). Positive angles can be used when the time of sun occlusion behind a building, mountain, or other obstacle needs to be calculated.

<<>>=
sunrise_time(today(tzone = "EET"), lat = 60, lon = 25, tz = "EET",
             twilight = "civil")
sunrise_time(today(tzone = "EET"), lat = 60, lon = 25, tz = "EET",
             twilight = -10)
sunrise_time(today(tzone = "EET"), lat = 60, lon = 25, tz = "EET",
             twilight = +12)
@

We can reuse the array of dates from section \ref{sec:astro:photoperiod}, and the coordinates of Joensuu, to calculate the time at sunrise through the year.

<<>>=
time_at_sunrise.df <-
  data.frame(date = dates,
             sunrise_at =
               sunrise_time(dates,
                            lon = my.city$lon, lat =  my.city$lat,
                            tz = "EET", unit.out = "hour"))
@

The 10 lines at the top of the output are

<<>>=
head(time_at_sunrise.df, 10)
@

Functions \code{day\_night} from our \code{photobiology} package uses function \code{sun\_angles}, which is a modified version of function \code{sunAngle} from package \code{ode}, to calculate the elevation of the sun. We first find local solar noon by finding the maximal solar elevation, and then search for sunrise in the first half of the day and for sunset in the second half, defined based on the local solar noon. Sunset and sunrise are by default based on a solar elevation angle equal to zero. The argument \code{twilight} can be used to set the angle according to different conventions.

In the examples we use \code{geocode} to get the latitude and longitude of cities. \code{geocode} accepts any valid Google Maps search terms, including street addresses, and postal codes within cities. \code{day\_length} returns a numeric vector. This first example is for Buenos Aires on two different dates, by use of the optional argument \code{tz} we request the results to be expressed in local time for Buenos Aires.

<<astro-geocode-2, message=FALSE, cache=cache>>=
geo_code_BA <- geocode("Buenos Aires")
day_night(ymd("2013-12-21"),
          lon = geo_code_BA[["lon"]],
          lat = geo_code_BA[["lat"]],
          tz = "America/Argentina/Buenos_Aires")
@

And with \texttt{unit.out} set to \texttt{"hour"}

<<astro-geocode-2a, message=FALSE, cache=cache>>=
day_night(ymd("2013-12-21"),
          lon = geo_code_BA[["lon"]],
          lat = geo_code_BA[["lat"]],
          tz = "America/Argentina/Buenos_Aires",
          unit.out = "hour")
@

Next, we calculate day length  based on different definitions of twilight for Helsinki, at the equinox:

<<astro-geocode-4, message=FALSE, cache=cache>>=
geo_code_He <- geocode("Helsinki")
geo_code_He
day_length(ymd("2013-09-21"),
          lon = geo_code_He[["lon"]], lat = geo_code_He[["lat"]])
day_length(ymd("2013-09-21"),
          lon = geo_code_He[["lon"]], lat = geo_code_He[["lat"]],
          twilight = "civil")
day_length(ymd("2013-09-21"),
          lon = geo_code_He[["lon"]], lat = geo_code_He[["lat"]],
          twilight = "nautical")
day_length(ymd("2013-09-21"),
          lon = geo_code_He[["lon"]], lat = geo_code_He[["lat"]],
          twilight = "astronomical")
@

Or for a given angle in degrees, which for example can be positive in the case of an obstacle like a building or mountain, instead of negative as used for twilight definitions. In the case of obstacles the angle will be different for morning and afternoon, and can be entered as a numeric vector of length two.

<<>>=
day_length(ymd("2013-09-21"),
          lon = geo_code_He[["lon"]], lat = geo_code_He[["lat"]],
          twilight = c(20, 0))
@

In addition, function \texttt{day\_night} returns a list containing all the quantities returned by the other functions. As other functions described in this chapter, \texttt{day\_night} is vectorized for the \texttt{date} parameter.

<<astro-geocode-A2, message=FALSE, cache=cache>>=
day_night(ymd("2013-12-21"),
          lon = geo_code_BA[["lon"]],
          lat = geo_code_BA[["lat"]],
          tz = "America/Argentina/Buenos_Aires")
@

And with \texttt{unit.out} set to \texttt{"hour"}

<<astro-geocode-A2a, message=FALSE, cache=cache>>=
day_night(ymd("2013-12-21"),
          lon = geo_code_BA[["lon"]],
          lat = geo_code_BA[["lat"]],
          tz = "America/Argentina/Buenos_Aires",
          unit.out = "hour")
@

\section{Task: calculating the position of the sun}\label{sec:astro:position}

\code{sun\_angles} not only returns solar elevation, but all the angles defining the position of the sun. The time argument to \code{sun\_angles} is internally converted to UTC (universal time coordinates, which is equal to GMT) time zone, so time defined for any time zone is valid input. The time zone used for the output is by default that currently in use in the computer on which R is running, but we can easily specify the time coordinates used for the output with parameter \code{tz}, using any string accepted by package \code{lubridate}.

<<astro-geocode-5, message=FALSE, cache=cache>>=
geo_code_Jo <- geocode("Joensuu")
geo_code_Jo
my_time <- ymd_hms("2014-05-29 18:00:00", tz="EET")
sun_angles(my_time,
         lon = geo_code_Jo[["lon"]], lat = geo_code_Jo[["lat"]])
@

We can calculate the current position of the sun, in this case giving the position of the sun in the sky of Joensuu when this .PDF file was generated.

<<>>=
sun_angles(now(),
         lon = geo_code_Jo[["lon"]], lat = geo_code_Jo[["lat"]])
@

\section{Task: plotting sun elevation through a day}

Function \code{sun\_angles} described above is vectorized, so it is very easy to calculate the position of the sun throughout a day at a given location on Earth. The example here uses sun only elevation, plotted for Helsinki through the course of 23 June 2014. We first a vector of times, using \code{seq} which can not only be used with numbers, but also with dates. Note that \code{by} is specified as a string.

<<>>=
opts_chunk$set(opts_fig_wide)
@

<<astro-6, cache=cache>>=
hours <- seq(from=ymd("2014-06-23", tz="EET"),
             by="10 min",
             length=24 * 6)
sun_elev_hel <- data.frame(time_eet = hours,
                           elevation =
                             sun_angles(hours,
                                        lon = geo_code_He[["lon"]],
                                        lat = geo_code_He[["lat"]])$elevation,
                           location = "Helsinki",
                           lon = geo_code_He[["lon"]],
                           lat = geo_code_He[["lat"]])
@

We also create a small data frame with data for plotting and labeling the different twilight conventions.

<<astro-7, cache=cache>>=
twilight <-
  data.frame(angle = c(0, -6, -12, -18),
             label = c("Horizon", "Civil twilight",
                       "Nautical twilight",
                       "Astronomical twilight"),
             time = rep(ymd_hms("2014-06-23 12:00:00",
                                tz="EET"),
                        4) )
@

We draw a plot using the data frames created above.

<<astro-8>>=
ggplot(sun_elev_hel,
       aes(x = time_eet, y = elevation)) +
  geom_line() +
  geom_hline(data=twilight,
             aes(yintercept = angle, linetype=factor(label))) +
  annotate(geom="text",
           x=twilight$time, y=twilight$angle,
           label=twilight$label, vjust=-0.4, size=4) +
  labs(y = "Solar elevation at Helsinki (degrees)",
       x = "Time EEST")
@

\section{Task: plotting day length through the year}

For this we first need to generate a sequence of dates. We use \code{seq} as in the previous section, but instead of supplying a length as argument we supply an ending time. Instead of giving \code{by} in minutes as above, we now use days:

<<astro-9, cache=cache>>=
days <- seq(from=ymd("2014-01-01"), to=ymd("2014-12-31"),
            by="3 day")
@

To calculate the length of each day, we need to use an explicit loop as function \code{day\_night} is not vectorized. We repeat the calculations for three locations at different latitudes, then row bind the data frames into a single data frame. Each individual data frame contains information to identify the sites:

<<astro-geocode-10a, message=FALSE, cache=cache>>=
geo_code_He <- geocode("Helsinki")
daylengths_hel <-
  data.frame(day = days,
             daylength = day_length(days,
                                    lon = geo_code_He[["lon"]],
                                    lat = geo_code_He[["lat"]],
                                    tz = "EET"),
             location = "Helsinki",
             lon = geo_code_He[["lon"]],
             lat = geo_code_He[["lat"]])
@

<<astro-geocode-10b, message=FALSE, cache=cache>>=
geo_code_Iv <- geocode("Ivalo")
daylengths_ivalo <-
  data.frame(day = days,
             daylength = day_length(days,
                                    lon = geo_code_Iv[["lon"]],
                                    lat = geo_code_Iv[["lat"]],
                                    tz = "EET"),
             location = "Ivalo",
             lon = geo_code_Iv[["lon"]],
             lat = geo_code_Iv[["lat"]])
@

<<astro-geocode-10c, message=FALSE, cache=cache>>=
geo_code_At <- geocode("Athens, Greece")
daylengths_athens <-
  data.frame(day = days,
             daylength = day_length(days,
                            lon = geo_code_At[["lon"]],
                            lat = geo_code_At[["lat"]],
                            tz = "EET"),
             location = "Athens",
             lon = geo_code_At[["lon"]],
             lat = geo_code_At[["lat"]])
@

<<astro-geocode-10d>>=
daylengths <- rbind(daylengths_hel,
                    daylengths_ivalo,
                    daylengths_athens)
@

Once we have the data available, plotting is simple:

<<astro-10e>>=
ggplot(daylengths,
       aes(x = day, y = daylength, colour=factor(location))) +
  geom_line() +
  scale_y_continuous(breaks=c(0,6,12,18,24), limits=c(0,24)) +
  labs(x = "Date", y = "Daylength (h)", colour="Location")
@

\section{Task: plotting local time at sunrise}

For this we reuse \texttt{days} from the previous sections. We repeat the calculations for three locations at different latitudes, then row bind the data frames into a single data frame. Data frames contain information to identify the sites:

<<astro-geocode-11a, message=FALSE, cache=cache>>=
geo_code_He <- geocode("Helsinki")
sunrise_hel <-
  data.frame(day = days,
             sunrise = sunrise_time(days,
                                    lon = geo_code_He[["lon"]],
                                    lat = geo_code_He[["lat"]],
                                    tz = "EET", unit.out = "hour"),
             location = "Helsinki",
             lon = geo_code_He[["lon"]],
             lat = geo_code_He[["lat"]])
@

<<astro-geocode-11b, message=FALSE, cache=cache>>=
geo_code_Iv <- geocode("Ivalo")
sunrise_ivalo <-
  data.frame(day = days,
             sunrise = sunrise_time(days,
                                    lon = geo_code_Iv[["lon"]],
                                    lat = geo_code_Iv[["lat"]],
                                    tz = "EET", unit.out = "hour"),
             location = "Ivalo",
             lon = geo_code_Iv[["lon"]],
             lat = geo_code_Iv[["lat"]])
@

<<astro-geocode-11c, message=FALSE, cache=cache>>=
geo_code_At <- geocode("Athens, Greece")
sunrise_athens <-
  data.frame(day = days,
             sunrise = sunrise_time(days,
                            lon = geo_code_At[["lon"]],
                            lat = geo_code_At[["lat"]],
                            tz = "EET", unit.out = "hour"),
             location = "Athens",
             lon = geo_code_At[["lon"]],
             lat = geo_code_At[["lat"]])
@

<<astro-geocode-11d, message=FALSE, cache=cache>>=
sunrises <- rbind(sunrise_hel,
                  sunrise_ivalo,
                  sunrise_athens)
@

Once we have the data available, plotting is simple:

<<astro-11e>>=
ggplot(sunrises,
       aes(x = day, y = sunrise, colour=factor(location))) +
  geom_line() +
  scale_y_continuous(breaks=c(0,6,12), limits=c(0,12)) +
  labs(x = "Date", y = "Time-of-day at sunrise (h)", colour="Location")
@

The breaks in the lines are the result of the changes between winter and summer time coordinates.

<<>>=
try(detach(package:photobiology))
try(detach(package:lubridate))
try(detach(package:ggmap))
try(detach(package:ggplot2))
@
